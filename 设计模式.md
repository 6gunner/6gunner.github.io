# 对象关系

我们可以把对象的关系总结为以下3种：

1. 对象之间的关系——继承
2. 对象性质在其继承关系上的关系——多态
3. 对象性质分为`属性`与`方法`之后带来的关系——可见性

除此之外，在对象之间、对象的性质之间、对象的性质与对象之间，还有哪些关系呢？

设计模式在一定程度上是对上述问题的回应。从"目的"的视角出发，设计模式可以基本分为3类：

- 创建型：基本关系，对象的定义与获得；
- 结构型：将对象理解为数据时，除继承关系外的其他关系，比如组合、分类；
- 行为型：观察对象的行为能力时，对象关于行为的可能关系；

|      | 创建型    | 结构型                | 行为型                  |
| ---- | --------- | --------------------- | ----------------------- |
|      | Abstract  | Adapter               | Chain of Responsibility |
|      | Factory   | Bridge                | Command(指令模式)       |
|      | Builder   | Composite(复合模式)   | Iterator(迭代模式)      |
|      | Prototype | Decorator(装饰者模式) | Mediator(中介者模式)    |
|      | Singleton | Facade(外观模式)      | Memento(备忘录模式)     |
|      |           | Flyweight             | Observer(观察者模式)    |
|      |           | Proxy                 | State(状态模式)         |
|      |           |                       | Strategy(策略模式)      |
|      |           |                       | Visitor(访问者模式)     |
|      |           |                       | Template Method         |



## 结构型设计模式

类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。

### Proxy



## 行为性设计模式





## 1.loader

在公司里面，因为后台的业务接口里面有很多关联查询没有带出来name字段；

所以中间层这边设计了一个缓存机制，将很多name缓存在内存中。当前端服务需要用到name时候，通过缓存去过滤动态设置这些name。

这里想总结的不是缓存机制，而是如何去加载缓存以及更新缓存的一种设计。

首先上图：



服务端启动时候，先加载出有多少loader，每个loader都代表着需要缓存的类。每个类里面的execute方法各自去实现了自己加载缓存的逻辑。

需要更新缓存的话，先通过mq或者redis的消息订阅消息，然后来通知loader去重新加载缓存。

这套模式可以用在分布式的架构里，因为消息中间件很好的解耦了通知消息的。







## 多线程设计模式

### 线程安全的Singleton

```java
public class SingletonDemo {
	
	private static SingletonDemo singletonDemo = null;
	
	private SingletonDemo() {
	
	}
	
	public static SingletonDemo getInstance() {
		
		if (singletonDemo == null) {
			synchronized (SingletonDemo.class) {
        // 效率低下
			singletonDemo = new SingletonDemo();
		}
		return singletonDemo;
	}
	
	public static void main(String[] args) {
		for (int i = 0; i < 1000; i++) {
			new Thread(() -> {
				SingletonDemo singletonDemo = SingletonDemo.getInstance();
				System.out.println(singletonDemo.hashCode());
			}).start();
		}
	}
}
```



饿汉式写法



利用静态内部类 或者 static代码块



```java

public class MySingleton {

	//内部类
	private static class MySingletonHandler{
		private static MySingleton instance = new MySingleton();
	} 
	
	private MySingleton(){}
	 
	public static MySingleton getInstance() { 
		return MySingletonHandler.instance;
	}
}

	public class MySingleton{
	 
	private static MySingleton instance = null;
	 
	private MySingleton(){}
 // static 代码块
	static{
		instance = new MySingleton();
	}
	
	public static MySingleton getInstance() { 
		return instance;
	} 
}


```




工厂模式

代理模式

静态代理

JDK动态代理

CGLIB动态代理