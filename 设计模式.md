# 设计模式

学习设计模式，需要明白每一个模式的道理和用处，然后通过经典应用，来体会它的使用场景。

在这基础上，进行多思考，多使用。

https://www.kancloud.cn/digest/xing-designpattern/143721

## 设计

设计和模式是分开的概念，首先有设计，好的设计，总结沉淀下来的东西，我们称之为模式。

### 设计准则

1. 小及是美
2. 让程序专注于一件事情
3. 快速建立模型、快速迭代
4. 舍弃高效，强调可移植性（==批注：因为性能方面可以被硬件升级来替代==）
5. 采用纯文本来存储数据（==批注：强调可读性==）

#### 小准则

1. 各部分之和大于整体
2. 寻求90%的解决方案

3. 沉默是金（批注：在程序没有错误的情况下，不要去添加任何提示信息。比如liux环境下，找不要数据，就返回空，而不是提示“no data”，这样反而会造成问题）



### 5大设计原则

和准则类似，但是这个原则是放之世界而皆准的

**SOLID**

- S：职责单一原则：应该仅具有一种单一功能的
- O：开放封闭原则：对扩展开放，对修改关闭
- L：里氏转换原则： 一个父类，可以在不改变程序正确性的前提下，被它的子类所替换的
- I：接口隔离原则：==多个特定接口==要好于一个==宽泛用途的接口==
- D：依赖反转原则：对接口编程而不是对实现编程，依赖于抽象接口而不是一个实例



**开放封闭原则**

对扩展开放，对修改封闭

==增加需求时，扩展新代码，而不是修改已有代码==



**接口独立**

保持接口单一、独立，避免出现“胖接口”



**依赖倒置原则**

面向接口编程，依赖于抽象，而不依赖于具体实现。

就是你没必要去知道类的具体实现，只需要知道接口的输入、输出就可以。







## 模式



### ==设计模式的分类==

从"目的"的视角出发，设计模式可以基本分为3类：

- 创建型：基本关系，对象的定义与获得；
- 结构型：将对象理解为数据时，除继承关系外的其他关系，比如组合、分类；
- 行为型：观察对象的行为能力时，对象关于行为的可能关系；

|      | 创建型                     | 结构型                    | 行为型                                    |
| ---- | -------------------------- | ------------------------- | ----------------------------------------- |
| 1    | ==Factory（工厂模式）==    | ==Adapter（适配器模式）== | ==Observer(观察者模式)==                  |
| 2    | ==Singleton （单例模式）== | Bridge                    | Command(指令模式)                         |
| 3    | Builder（创建者模式）      | Composite(复合模式)       | Iterator(迭代模式)                        |
| 4    | Prototype（原型模式）      | ==Decorator(装饰者模式)== | Mediator(中介者模式)                      |
| 5    | Abstract Factory           | ==Facade(外观模式)==      | Memento(备忘录模式)                       |
| 6    |                            | Flyweight                 | ==Chain of Responsibility（责任链模式）== |
| 7    |                            | ==Proxy==                 | ==State(状态模式)==                       |
| 8    |                            |                           | ==Strategy(策略模式)==                    |
| 9    |                            |                           | Visitor(访问者模式)                       |
| 10   |                            |                           | Template Method                           |



## 详解

### 创建型设计模式

创建型模式，就是创建对象的模式。

将==创建对象的过程进行了抽象==，也可以理解为将创建对象的过程进行了封装，作为客户程序仅仅需要去使用对象，而不再关系创建对象过程中的逻辑。

#### 工厂模式

**应用场景**：

- jquery里创建dom的方式 `$('div')`

- React.createElement

  <img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-04-04-134140.png" alt="image-20200404214140075" style="zoom:33%;float:left" />

- vue的组件创建 `Vue.component('tagName', {})`;

  

**代码示例：**

```
class Product {
	constructor(name){
		this.name = name;
	}
	sayHello() {
		console.log("Hello " + this.name);
	}
}
// 创建工厂
function createProduct(name) {
	return new Product(name);
}

createProduct("KeYang").sayHello();
```



**总结：**

虽然工厂模式看起来很简单，但是他的好处却是很多的。

第一，可以简化复杂的创建对象的方法，不用去管对象是如何创建的。

第二，可以避免==构造函数变化==后导致所有使用的地方都要改变的问题



#### 单例模式

**使用场景**

window.$只初始化一次 ；

vuex和redux中的store对象实例是单例的；

模态框modal的显示

**代码示例：**

```
class SingleInstance {
}

SingleInstance.getInstance = (function () {
	let instance
	return function () {
		if (instance) {
			return instance
		}
		instance = new SingleInstance()
		return instance
	};
})();
```



**总结**

单例模式可以很好的控制程序里某一个对象的实例个数，

比如==全局只有1个对象实例==，或者只初始化一次对象。





### 结构型设计模式

在解决了对象的创建问题之后，就需要关注如何设计对象的结构。

如何设计好对象的结构，以及对象间的继承和依赖关系，会影响到后续程序的维护性、代码的健壮性、耦合性等。

结构型模式就关注于如何设计对象结果，它包含了对很多问题的解决方式。例如：扩展性（外观、组成、代理、装饰）、封装（适配器、桥接）



#### ==对象关系==

1. 对象之间的关系可以总结为大致3种：——继承、组合、依赖。
2. 对象性质分为`属性`与`方法`。
3. 对象的`方法`性质，在继承关系上，衍生出==多态==的关系。



#### 适配器模式

**使用场景**：

- Vue的computed方法，可以理解为一个简单的适配器



**UML图**：

![image-20200405074318522](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-04-04-234319.png)



**总结**：

当新的和旧的方法不兼容时，可以用来适配器的模式，封装旧的方法，实现新方法的调用。

现实生活中，国外和国内插头上的转化器，mac电脑上的typec转usb的插头，都运用到了适配器模式。



#### 装饰器模式

**使用场景**

- es7的decorator
- [core-decorators](https://github.com/jayphelps/core-decorators)



**代码示例**

```js
// 带参数的装饰， 装饰类
@isTestable(true)
class MyClass { }

function isTestable(value) {
   return function decorator(target) {
      target.isTestable = value;
   }
}

// 装饰方法、属性
class MyClass {
	@log
	add(a, b) {
		return a + b;
	}
}

function log(target, name, descriptor) {
	const old = descriptor.value;
	descriptor.value = function () {
		console.log(`${name}方法被调用，参数为${JSON.stringify(arguments)}`);
		return old.apply(this, arguments);
	}
}

const demo = new MyClass();
const result = demo.add(1, 2);
console.log('result', result);
```





**UML图**

![image-20200405083731706](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-04-05-003732.png)

**对比**

装饰器模式和适配器模式有一点类似，都是在原有的方法上做了扩展。

但是不同点的在于：适配器模式主要用来去做一些新旧接口上的兼容，或者做一些逻辑的封装，去修改原有逻辑，从而适应变化的业务或者功能需求。

装饰器模式是对原有的方法，做一些额外的扩展，比如去修改样式等等，本身的方法也依然能用，有点锦上添花的效果。



**总结**

装饰器可以达到 ==不改变原有代码，但是可以在原有类上进行添加功能== 的作用。



#### 代理模式

**使用场景**

dom事件代理

es6的proxy

dva里的app start方法

```js
export default function(opts = {}) {

  // ...初始化 route ，和添加 route 中间件的方法。

  /**
   * 1. 新建 function ，函数内实例化一个 app 对象。
   * 
   */
  const app = core.create(opts, createOpts);
  /**
   * 2. 新建变量指向该对象希望代理的方法
   * 
   */
  const oldAppStart = app.start;
  app.router = router;
  /**
   * 4. 令 app.start = start，完成对 app 对象的 start 方法的代理。
   * @type {[type]}
   */
  app.start = start;
  return app;

  // router 赋值

  /**
   * 3.1 新建同名方法 start，
   * 
   */
  function start(container) {
    // 合法性检测代码

    /**
     * 3.2 在其中使用 call，指定 oldStart 的调用者为 app。
     */
    oldAppStart.call(app);
	
	// 因为有 3.2 的执行才有现在的 store
    const store = app._store;

	// 使用高阶组件创建视图
  }
}
```



**UML图**

![image-20200407075944059](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-04-06-235944.png)

client没有权限去直接访问BaseImage, 只能通过ProxyImage来间接的访问BaseImage。





**总结**

代理模式的作用是：当使用者因为权限、安全性等原因，无法访问目标对象时。==我们不可能去修改目标对象的属性去适应客户的访问需求==，所以需要通过增加一个代理类，来实现访问目标对象的效果。 。

代理类和目标类的**==方法名==**应该保持一致，这样才能让客户端无感知的访问目标对象。

生活中比较常见的代理模式有：vpn代理来进行局域网的访问、经纪人来代理明星的业务。



#### 比较：适配器 vs 装饰器 vs 代理模式

适配器模式是：原有接口可以使用，但是数据格式不支持，或者因为其他因素而匹配不上。==需要创建一个新接口进行转换，新接口和原有接口不一致。==

代理模式是：原有接口无法访问，需要通过代理来开通权限，或者只使用一些阉割版的功能。创建的新接口和原有接口一模一样。

装饰器模式是：原有接口可以访问，在这个基础上做了一个新接口，做了一些功能增强，或者样式改变。



#### 外观模式

**使用场景**

多个子系统的情况下，如果有一个业务需要用到多个接口的功能，那么可以使用外观模式，来提供一个组合接口去调用多个子接口，避免用户端调用多个子接口，难以理解。这个模式有点类似于==中层==的概念。

**UML图**

<img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-04-07-231000.png" alt="image-20200408070959901" style="zoom: 33%;" />



**总结**

外观模式通过提供一个外观接口，可以对屏蔽子系统组件，减少了客户处理的接口数目。

子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，减少系统相互依赖。

但是外观模式==不符合单一原则==，在开发过程中，要谨慎使用，避免出现过于庞大的接口。





### 行为型设计模式

#### 观察者模式

**使用场景**

观察者模式是目前前端运用最多的设计模式。

- 前端的事件绑定、监听；
- 消息的pub、sub

使用的都是观察者模式

**代码实例**

1. 事件监听

```
emitter.on('key1', () => {
	// do some thing
});

```

可以将回调函数，认为是观察者的onNotify()方法

emitter.on('key', callback)方法类似于`addSubscriber`方法将callback添加到自身的`subscribers`数组里进行维护。

当事件触发时，去遍历`subscribers`数组，执行回调方法。



**类图**

![image-20200412160431413](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-04-12-080431.png)









#### 迭代器模式

**概念**

顺序访问一个集合

使用的人不需要知道集合内部的数据结构



**使用场景**

- Iterator对象，可以用来遍历各类对象。
- Genertor的函数。generator里也是通过Iterator来实现遍历的。 generator.next();

**UML类图**

![image-20200413062328153](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-04-12-222328.png)

**代码示例**

用一个迭代器，去遍历一个容器对象。

```js
class Iterator {
	constructor (container) {
		this.index = 0
		this.list = container.list
	}

	hasNext () {
		return this.list.length > this.index
	}

  // 这里可以封装各种数据结构，支持多种containner
	next () {
		return this.list[this.index++]
	}

}

class Container {
	constructor (list) {
		this.list = list
		this.iterator = new Iterator(this)
	}

	getIterator () {
		return this.iterator
	}

	each (callback) {
		let iterator = this.getIterator()
		let i = 0
		while (iterator.hasNext()) {
			let item = iterator.next()
			callback(item, i);
			i++;
		}
	}

}

const testArray = [1, 2, 3]
const testContainer = new Container(testArray)

testContainer.each((item, index) => {
	console.log(`${index} = ${item}`)
})


```



目前，es6已经支持Iterator语法。

每一个容器对象的`__proto__`原型对象上都有一个`Symbol.iterator`属性，返回一个Iterator对象。

Iterator对象可以调用next()方法，返回一个`{done, value}`的数据格式对象。

```js
let es6Iterator = testArray[Symbol.iterator]();
let item = es6Iterator.next();
while(!item.done) {
	console.log(item);
	item = es6Iterator.next();
}

// for item of data 也可以实现上面的效果
```



**总结**

迭代器模式最大的好处是，访问者不需要了解list的数据结构 ，就可以遍历list。

用专业的话说就是：将迭代器和目标对象分开，达到使用者和目标对象的隔离效果。





#### 状态模式

**介绍**

状态模式，又可以成为有限状态机。

程序中，有固定的几个状态。

状态之间的变化，会产生一定的业务逻辑。

触发一定的条件后，状态会发生固定的变化。
#### 责任链模式

**概念**

发起者和审批者角色分开，通过链式进行串联调用。

**应用场景**

请假流程

- 现实生活中，最常见的状态模式就是红绿灯。
- 在前端代码里，比较常见的就是Promise函数。 有3种状态，pendding、fullfiled、rejected。
**简单示例**

```js
step1.setNext(step2);
step2.setNext(step3);

// 调用
function handle() {
  if (this.hasNext()) {
    getNext().handle();
  }
}

```















# 设计-实际应用场景

## loader

在公司里面，因为后台的业务接口里面有很多关联查询没有带出来name字段；

所以中间层这边设计了一个缓存机制，将很多name缓存在内存中。当前端服务需要用到name时候，通过缓存去过滤动态设置这些name。

这里想总结的不是缓存机制，而是如何去加载缓存以及更新缓存的一种设计。

首先上图：



服务端启动时候，先加载出有多少loader，每个loader都代表着需要缓存的类。每个类里面的execute方法各自去实现了自己加载缓存的逻辑。

需要更新缓存的话，先通过mq或者redis的消息订阅消息，然后来通知loader去重新加载缓存。

这套模式可以用在分布式的架构里，因为消息中间件很好的解耦了通知消息的。







# 设计模式-多线程

### 线程安全的Singleton

```java
public class SingletonDemo {
	
	private static SingletonDemo singletonDemo = null;
	
	private SingletonDemo() {
	
	}
	
	public static SingletonDemo getInstance() {
		
		if (singletonDemo == null) {
			synchronized (SingletonDemo.class) {
        // 效率低下
			singletonDemo = new SingletonDemo();
		}
		return singletonDemo;
	}
	
	public static void main(String[] args) {
		for (int i = 0; i < 1000; i++) {
			new Thread(() -> {
				SingletonDemo singletonDemo = SingletonDemo.getInstance();
				System.out.println(singletonDemo.hashCode());
			}).start();
		}
	}
}
```



饿汉式写法



利用静态内部类 或者 static代码块



```java

public class MySingleton {

	//内部类
	private static class MySingletonHandler{
		private static MySingleton instance = new MySingleton();
	} 
	
	private MySingleton(){}
	 
	public static MySingleton getInstance() { 
		return MySingletonHandler.instance;
	}
}

	public class MySingleton{
	 
	private static MySingleton instance = null;
	 
	private MySingleton(){}
 // static 代码块
	static{
		instance = new MySingleton();
	}
	
	public static MySingleton getInstance() { 
		return instance;
	} 
}


```




工厂模式

代理模式

静态代理

JDK动态代理

CGLIB动态代理
