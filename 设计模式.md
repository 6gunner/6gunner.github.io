# 对象关系

我们可以把对象的关系总结为以下3种：

1. 对象之间的关系——继承
2. 对象性质在其继承关系上的关系——多态
3. 对象性质分为`属性`与`方法`之后带来的关系——可见性

除此之外，在对象之间、对象的性质之间、对象的性质与对象之间，还有哪些关系呢？

设计模式在一定程度上是对上述问题的回应。从"目的"的视角出发，设计模式可以基本分为3类：

- 创建型：基本关系，对象的定义与获得；
- 结构型：将对象理解为数据时，除继承关系外的其他关系，比如组合、分类；
- 行为型：观察对象的行为能力时，对象关于行为的可能关系；

|      | 创建型    | 结构型                | 行为型                  |
| ---- | --------- | --------------------- | ----------------------- |
|      | Abstract  | Adapter               | Chain of Responsibility |
|      | Factory   | Bridge                | Command(指令模式)       |
|      | Builder   | Composite(复合模式)   | Iterator(迭代模式)      |
|      | Prototype | Decorator(装饰者模式) | Mediator(中介者模式)    |
|      | Singleton | Facade(外观模式)      | Memento(备忘录模式)     |
|      |           | Flyweight             | Observer(观察者模式)    |
|      |           | Proxy                 | State(状态模式)         |
|      |           |                       | Strategy(策略模式)      |
|      |           |                       | Visitor(访问者模式)     |
|      |           |                       | Template Method         |



## 结构型设计模式

类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。

### Proxy



## 行为性设计模式





## 1.loader

在公司里面，因为后台的业务接口里面有很多关联查询没有带出来name字段；

所以中间层这边设计了一个缓存机制，将很多name缓存在内存中。当前端服务需要用到name时候，通过缓存去过滤动态设置这些name。

这里想总结的不是缓存机制，而是如何去加载缓存以及更新缓存的一种设计。

首先上图：



服务端启动时候，先加载出有多少loader，每个loader都代表着需要缓存的类。每个类里面的execute方法各自去实现了自己加载缓存的逻辑。

需要更新缓存的话，先通过mq或者redis的消息订阅消息，然后来通知loader去重新加载缓存。

这套模式可以用在分布式的架构里，因为消息中间件很好的解耦了通知消息的。





饿汉式写法

工厂模式

代理模式

静态代理

JDK动态代理

CGLIB动态代理