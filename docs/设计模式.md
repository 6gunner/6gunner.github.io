# 设计模式

学习设计模式，需要明白每一个模式的道理和用处，然后通过经典应用，来体会它的使用场景。

在这基础上，进行多思考，多使用。

https://www.kancloud.cn/digest/xing-designpattern/143721

## 设计

设计和模式是分开的概念，首先有设计，好的设计，总结沉淀下来的东西，我们称之为模式。

### 设计准则

1. 小及是美
2. 让程序专注于一件事情
3. 快速建立模型、快速迭代
4. 舍弃高效，强调可移植性（==批注：因为性能方面可以被硬件升级来替代==）
5. 采用纯文本来存储数据（==批注：强调可读性==）

#### 小准则

1. 各部分之和大于整体
2. 寻求90%的解决方案

3. 沉默是金（批注：在程序没有错误的情况下，不要去添加任何提示信息。比如liux环境下，找不要数据，就返回空，而不是提示“no data”，这样反而会造成问题）



### 5大设计原则

和准则类似，但是这个原则是放之世界而皆准的

**SOLID**

- S：==职责单一原则==：应该仅具有一种单一功能的
- O：==开放封闭原则==：对扩展开放，对修改关闭
- L：里氏转换原则： 一个父类，可以在不改变程序正确性的前提下，被它的子类所替换的
- I：接口隔离原则：==多个特定接口==要好于一个==宽泛用途的接口==
- D：依赖反转原则：对接口编程而不是对实现编程，依赖于抽象接口而不是一个实例



**开放封闭原则**

对扩展开放，对修改封闭

==增加需求时，扩展新代码，而不是修改已有代码==



**接口独立**

保持接口单一、独立，避免出现“胖接口”



**依赖倒置原则**

面向接口编程，依赖于抽象，而不依赖于具体实现。

就是你没必要去知道类的具体实现，只需要知道接口的输入、输出就可以。







## 模式

### ==设计模式的分类==

从"目的"的视角出发，设计模式可以基本分为3类：

- 创建型：基本关系，对象的定义与获得；
- 结构型：将对象理解为数据时，除继承关系外的其他关系，比如组合、分类；
- 行为型：观察对象的行为能力时，对象关于行为的可能关系；

|      | 创建型                     | 结构型                    | 行为型                                |
| ---- | -------------------------- | ------------------------- | ------------------------------------- |
| 1    | ==Factory（工厂模式）==    | ==Adapter（适配器模式）== | ==Observer(观察者模式)==              |
| 2    | ==Singleton （单例模式）== | Bridge（桥接模式）        | Command(指令模式)                     |
| 3    | Builder（创建者模式）      | Composite(复合模式)       | ==Iterator(迭代模式)==                |
| 4    | Prototype（原型模式）      | ==Decorator(装饰者模式)== | Mediator(中介者模式)                  |
| 5    | Abstract Factory           | ==Facade(外观模式)==      | Memento(备忘录模式)                   |
| 6    |                            | Flyweight                 | Chain of Responsibility（责任链模式） |
| 7    |                            | ==Proxy（代理模式）==     | ==State(状态模式)==                   |
| 8    |                            |                           | Strategy(策略模式)                    |
| 9    |                            |                           | Visitor(访问者模式)                   |
| 10   |                            |                           | Template Method                       |



## 详解

### 创建型设计模式

创建型模式，就是创建对象的模式。

将==创建对象的过程进行了抽象==，也可以理解为将创建对象的过程进行了封装，作为客户程序仅仅需要去使用对象，而不再关系创建对象过程中的逻辑。



#### 单例模式

**使用场景**

window.$只初始化一次 ；

vuex和redux中的store对象实例是单例的；

模态框modal的显示

**代码示例：**

```js
class SingleInstance {
}

SingleInstance.getInstance = (function () {
	let instance
	return function () {
		if (instance) {
			return instance
		}
		instance = new SingleInstance()
		return instance
	};
})();
```



**总结**

单例模式可以很好的控制程序里某一个对象的实例个数，

比如==全局只有1个对象实例==，或者只初始化一次对象。





#### 工厂模式

**概念**

工厂模式用来创建一个固定类型的对象。

**应用场景**：

- jquery里创建dom的方式 `$('div')`

- React.createElement，创建了一个vnode。

  <img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-04-04-134140.png" alt="image-20200404214140075" style="zoom:33%;float:left" />

- vue的组件创建 `Vue.component('tagName', {})`;

  

**代码示例1：**

```js
class Product {
	constructor(name){
		this.name = name;
	}
	sayHello() {
		console.log("Hello " + this.name);
	}
}
// 创建工厂
function createProduct(name) {
	return new Product(name);
}

// 调用: 隐藏了createProduct方法的内部实现
createProduct("KeYang").sayHello();
```



**代码实例2：**

```js
function Tools(){
  if(!(this instanceof Tools)){
    return new Tools()
  }
  this.name = 'js工具库'
  // 获取dom的方法
  this.getEl = function(elem) {
    return document.querySelector(elem)
  }
  // 判断是否是数组
  this.isArray = function(arr) {
    return Array.isArray(arr)
  }
  // 其他通用方法...
}
// 调用
Tools();
new Tools();
```



**总结：**

工厂模式可以很简单的去==创建一个固定类型的对象==。

虽然工厂模式看起来很简单，但是他的好处却是很多的。

第一，对逻辑和业务进行封装，简化复杂的创建对象的方法。

第二，可以避免==构造函数变化==后导致所有使用的地方都要改变的问题。



#### 创建者模式

**概念**

创建者模式的作用是将一个==很复杂==的对象创建过程，一一分解出来。

对于用户而言，==只需要指定创建对象的类型（也就是传入参数即可），不需要知道内部的实现==



**案例**

- jquery的ajax的封装。
- jquery插件封装
- react/vue某一具体组件的设计



**代码**

```js
// 框架实例
(function(){
    function Gcode(el, option) {
        this.el = typeof el === 'string' ? document.querySelector(el) : el;
        this.option = option;
        this.init();
    }
    Gcode.prototype = {
        constructor: Gcode,
        init: function() {
        	this.drawLine(ctx, lineNum, cw, ch);
        	this.drawText(ctx, text, ch);
        },
        // 画干扰线
        drawLine: function(ctx, lineNum, maxW, maxH) {
        },
        // 画文字
        drawText: function(ctx, text, maxH) {            
        }
    }
  // 调用
	new Gcode('#canvas_code', {
  	lineNum: 6
	})
})();
```



**总结**

##### **==与工厂模式的区别==**

两者的概念都是封装创建的过程

但和工厂模式对比，创建者模式描述的==逻辑更加宏观==，工厂模式描述的更加具体。

举例来说：构建一个辆汽车，汽车里有很多小的零件。这些零件都需要创建，并且规格不同。

工厂模式就是用来创建这些不同的零件。

而创建者模式是将这些零件，一步一步的再构建成一辆完整的汽车。



### 结构型设计模式

在解决了对象的创建问题之后，就需要关注如何设计对象的结构。

如何设计好对象的结构，以及对象间的继承和依赖关系，会影响到后续程序的维护性、代码的健壮性、耦合性等。

结构型模式就关注于如何设计对象结果，它包含了对很多问题的解决方式。例如：扩展性（外观、组成、代理、装饰）、封装（适配器、桥接）



#### 适配器模式

**使用场景**：

- Vue的computed方法，可以理解为一个简单的适配器



**UML图**：

![image-20200405074318522](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-04-04-234319.png)



**总结**：

当新的和旧的方法不兼容时，可以用来适配器的模式，封装旧的方法，实现新方法的调用。

现实生活中，国外和国内插头上的转化器，mac电脑上的typec转usb的插头，都运用到了适配器模式。



#### 装饰器模式

**使用场景**

- es7的decorator
- [core-decorators](https://github.com/jayphelps/core-decorators)



**代码示例**

```js
// 带参数的装饰， 装饰类
@isTestable(true)
class MyClass { }

function isTestable(value) {
   return function decorator(target) {
      target.isTestable = value;
   }
}

// 装饰方法、属性
class MyClass {
	@log
	add(a, b) {
		return a + b;
	}
}

function log(target, name, descriptor) {
	const old = descriptor.value;
	descriptor.value = function () {
		console.log(`${name}方法被调用，参数为${JSON.stringify(arguments)}`);
		return old.apply(this, arguments);
	}
}

const demo = new MyClass();
const result = demo.add(1, 2);
console.log('result', result);
```





**UML图**

![image-20200405083731706](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-04-05-003732.png)

**对比**

装饰器模式和适配器模式有一点类似，都是在原有的方法上做了扩展。

但是不同点的在于：适配器模式主要用来去做一些新旧接口上的兼容，或者做一些逻辑的封装，去修改原有逻辑，从而适应变化的业务或者功能需求。

装饰器模式是对原有的方法，做一些额外的扩展，比如去修改样式等等，本身的方法也依然能用，有点锦上添花的效果。



**总结**

装饰器可以达到 ==不改变原有代码，但是可以在原有类上进行添加功能== 的作用。



#### 代理模式

**概念**

代理模式用到的非常多，现实生活里场景也很多。

核心的概念就是：通过代理对象，来控制某一个`被代理对象`的访问权限。



**作用**

- 安全代理（保护真实对象的访问权限）
- 虚拟代理(对于需要创建开销很大的对象，比如渲染网页大图时可以先用缩略图代替真图)

- 缓存代理(一些开销比较大的运算提供暂时的存储，下次运算时，如果传递进来的参数跟之前相同，则可以直接返回前面存储的运算结果)

**使用场景**

生活中比较常见的代理模式有：

​	vpn代理来进行局域网的访问、经纪人来代理明星的业务。

前端里的代理场景有：

- dom事件代理。将子node的绑定事件代理到父node上去，让父node代为处理且传递。（委托模式多了个一层真实对象的转化）
- es6的proxy语法。将get、set方法用另一个方法进行代理。
- 图片占位符/骨架屏/预加载等



**代码**

dva里用一个start方法代替了react的start方法

```js
export default function(opts = {}) {

  // ...初始化 route，和添加 route 中间件的方法。

  //1. 新建 function，函数内实例化一个 app 对象。
  const app = core.create(opts, createOpts);

  // 2. 新建变量指向该对象希望代理的方法
  const oldAppStart = app.start;

  /**
   * 3.1 新建同名方法 start，
   * 
   */
  function start(container) {
    // 合法性检测代码

    // 3.2 在其中使用 call，指定 oldStart 的调用者为 app。
    oldAppStart.call(app);
	
	// 因为有 3.2 的执行才有现在的 store
    const store = app._store;

	// ...使用高阶组件创建视图
  }
  
  //4. 令 app.start = start，完成对 app 对象的 start 方法的代理。
  app.start = start;
  return app;
  
}
```



**UML图**

![image-20200407075944059](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-04-06-235944.png)

client没有权限去直接访问BaseImage, 只能通过ProxyImage来间接的访问BaseImage。





**总结**

代理模式的作用是：当使用者因为权限、安全性等原因，无法访问目标对象时。==我们不可能去修改目标对象的属性去适应客户的访问需求==，所以需要通过增加一个代理类，来实现访问目标对象的效果。 

代理类和目标类的**==方法名==**应该保持一致，这样才能让客户端无感知的访问目标对象。





#### 比较：适配器 vs 装饰器 vs 代理模式

适配器模式是：原有接口可以使用，但是数据格式不支持，或者因为其他因素而匹配不上。==需要创建一个新接口进行转换，新接口和原有接口不一致。==

代理模式是：原有接口无法访问，需要通过代理来开通权限，或者只使用一些阉割版的功能。创建的新接口和原有接口一模一样。

装饰器模式是：原有接口可以访问，在这个基础上做了一个新接口，做了一些功能增强，或者样式改变。



#### 外观模式

**概念**

这个模式有点类似于==中层==的概念。为子系统中的一组接口提供一个一致的表现, 使得子系统更容易使用而不需要关注内部复杂而繁琐的细节.

**使用场景**

- 多个子系统的情况下，如果有一个业务需要用到多个接口的功能，那么可以使用外观模式，来提供一个组合接口去调用多个子接口，避免用户端调用多个子接口，难以理解。
- 有一个接口或者方法，需要兼容多个版本的系统，可以用外观模式进行封装。



**UML图**

<img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-04-07-231000.png" alt="image-20200408070959901" style="zoom: 33%;" />

**代码**

通过实现一个兼容不同浏览器的事件监听函数来让大家理解外观模式如何使用.

```js
function on(type, fn){
  // 对于支持dom2级事件处理程序
  if(document.addEventListener){
      dom.addEventListener(type,fn,false);
  }else if(dom.attachEvent){
  // 对于IE9一下的ie浏览器
      dom.attachEvent('on'+type,fn);
  }else {
      dom['on'+ type] = fn;
  }
}
```

**总结**

外观模式通过提供一个外观接口，可以对屏蔽子系统组件，减少了客户处理的接口数目。

子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，减少系统相互依赖。

但是外观模式==不符合单一原则==，在开发过程中，要谨慎使用，避免出现过于庞大的接口。





### 行为型设计模式

#### 观察者模式

**概念**

定义了一种一对多的关系, 所有观察对象同时监听某一主题对象, 当主题对象状态发生变化时就会通知所有观察者对象,使得他们能够自动更新自己。



**使用场景**

观察者模式是目前前端运用最多的设计模式。

- 前端的事件绑定、监听；
- 消息的pub、sub
- 系统消息通知 （ws）
- 网站日志记录 （监听全局的事件）
- react/vue等的观察者



**类图**

![image-20200412160431413](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-04-12-080431.png)



**代码实例**

1. 事件监听

```
emitter.on('key1', () => {
	// do some thing
});

```

一般前端的观察者都是主业务逻辑，不会单独再创建一个实例对象。可以将回调函数，认为是观察者的onNotify()方法。

`emitter.on('key', callback)`方法类似于`addSubscriber`方法将callback添加到自身的`subscribers`数组里进行维护。

当事件触发时，去遍历`subscribers`数组，执行回调方法。类似于调用`observer.onNotify()`



2.观察者、监听者

```js
class Subject {
  constructor() {
    this.subscribers = {}
  }

  addSubscribers(key, fn) {
    const subArr = this.subscribers[key]
    if (!subArr) {
      this.subscribers[key] = []
    }
    this.subscribers[key].push(fn)
  }

  trigger(key, message) {
    const subArr = this.subscribers[key]
    if (!subArr || subArr.length === 0) {
      return false
    }
    for(let i = 0, len = subArr.length; i < len; i++) {
      const fn = subArr[i]
      fn(message)
    }
  }

  unSub(key, fn) {
    const subArr = this.subscribers[key]
    if (!subArr) {
      return false
    }
    if (!fn) {
      this.subscribers[key] = []
    } else {
      for (let i = 0, len = subArr.length; i < len; i++) {
        const _fn = subArr[i]
        if (_fn === fn) {
          subArr.splice(i, 1)
        }
      }
    }
  }
}

// 测试
// 观察者
let subA = new Subject()
let A = (message) => {
  console.log('订阅者收到信息: ' + message)
}
subA.addSubscriber('A', A)

// 发布
subA.trigger('A', 'balbaasds')
```



#### 迭代器模式

**概念**

顺序访问一个集合

使用的人不需要知道集合内部的数据结构



**使用场景**

- Iterator对象，可以用来遍历各类对象。
- Genertor的函数。generator里也是通过Iterator来实现遍历的。 generator.next();

**UML类图**

![image-20200413062328153](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-04-12-222328.png)

**代码示例**

用一个迭代器，去遍历一个容器对象。

```js
class Iterator {
	constructor (container) {
		this.index = 0
		this.list = container.list
	}

	hasNext () {
		return this.list.length > this.index
	}

  // 这里可以封装各种数据结构，支持多种containner
	next () {
		return this.list[this.index++]
	}

}

class Container {
	constructor (list) {
		this.list = list
		this.iterator = new Iterator(this)
	}

	getIterator () {
		return this.iterator
	}

	each (callback) {
		let iterator = this.getIterator()
		let i = 0
		while (iterator.hasNext()) {
			let item = iterator.next()
			callback(item, i);
			i++;
		}
	}

}

const testArray = [1, 2, 3]
const testContainer = new Container(testArray)

testContainer.each((item, index) => {
	console.log(`${index} = ${item}`)
})


```



目前，es6已经支持Iterator语法。

每一个容器对象的`__proto__`原型对象上都有一个`Symbol.iterator`属性，返回一个Iterator对象。

Iterator对象可以调用next()方法，返回一个`{done, value}`的数据格式对象。

```js
let es6Iterator = testArray[Symbol.iterator]();
let item = es6Iterator.next();
while(!item.done) {
	console.log(item);
	item = es6Iterator.next();
}

// for item of data 也可以实现上面的效果
```



**总结**

迭代器模式最大的好处是，访问者不需要了解list的数据结构 ，就可以遍历list。

用专业的话说就是：将迭代器和目标对象分开，达到使用者和目标对象的隔离效果。



#### ==状态模式==

**介绍**

状态模式，又可以成为==有限状态机。==

程序中，有固定的几个状态。

状态之间的变化，会产生一定的业务逻辑。

触发一定的条件后，状态会发生固定的变化。



**结构图**



**实际应用**

- 现实生活中，最常见的状态模式就是红绿灯。
- 在前端代码里，比较常见的就是Promise函数。 有3种状态，pendding、fullfiled、rejected。



------

以下的设计模式不是很通用，或者说场景不是很经典，往往和业务相关，但是使用起来非常方便





#### 策略模式

**概念**

策略模式将不同算法进行拆分，让不同算法之间可以互相替换而不会影响到算法的使用者。

比如图书的打折策略

我们将每一种计算价格的方法都封装成一个策略类，在客户端中可以动态的设定，这种书使用哪种策略，当有新的打折方式时，我们可以增加一个新的策略类，而不需要去修改书的代码，将书和算法完全分离开来，减小了耦合度，符合“开-闭”原则。

**类图**

![image-20200424081005834](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-04-24-001006.png)



**应用案例**

- 实现更优雅的表单验证
- 图书的打折策略
- 棋牌类游戏的输赢算法（不同的棋牌游戏，单独拥有一个自己的输赢策略）



**总结**

如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。

策略模式的好处：

- 调用方式相同,降低了使用成本以及不同算法之间的耦合。避免大量冗余的代码判断,比如if else等

- 单独定义算法模型, 方便单元测试

  

#### 责任链模式

**概念**

发起者和审批者角色分开，通过链式进行串联调用。

**应用场景**

请假流程

**简单示例**

```js
step1.setNext(step2);
step2.setNext(step3);

// 调用
function handle() {
  if (this.hasNext()) {
    getNext().handle();
  }
}

```







#### Memento(备忘录模式)

将一些操作步骤或者一些状态的变化记录下来，可以在需要的时候进行备份恢复。



**应用场景**

比较常见的场景是编辑器的编辑、撤销步骤。





#### 中介者模式

中介者模式将两两对象之间直接的联系，通过一个中间人，转换成间接的联系。

可以很好的控制对象与对象之间复杂的耦合关系。



**结构图**

![image-20200421075030450](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-04-20-235030.png)





**实际应用场景**

现实生活中，最常见的场景就是 `房屋租赁`市场上的房东、租客、中介的关系。



 



# 设计记录

## loader

**背景**

在公司里面，因为后台的业务接口里面有很多关联查询没有带出来name字段；

所以中间层这边设计了一个缓存机制，将很多name缓存在内存中。当前端服务需要用到name时候，通过缓存去过滤动态设置这些name。（**代理模式**）

**观察者模式**

服务端启动时候，先加载出有多少loader，每个loader都代表着需要缓存的类。每个类里面的execute方法各自去实现了自己加载缓存的逻辑。

需要更新缓存的话，先通过mq或者redis的消息订阅消息，然后来通知loader去重新加载缓存。







# 设计模式-多线程

### 线程安全的Singleton

```java
public class SingletonDemo {
	
	private static SingletonDemo singletonDemo = null;
	
	private SingletonDemo() {
	
	}
	
	public static SingletonDemo getInstance() {
		
		if (singletonDemo == null) {
			synchronized (SingletonDemo.class) {
        // 效率低下
			singletonDemo = new SingletonDemo();
		}
		return singletonDemo;
	}
	
	public static void main(String[] args) {
		for (int i = 0; i < 1000; i++) {
			new Thread(() -> {
				SingletonDemo singletonDemo = SingletonDemo.getInstance();
				System.out.println(singletonDemo.hashCode());
			}).start();
		}
	}
}
```



饿汉式写法



利用静态内部类 或者 static代码块



```java

public class MySingleton {

	//内部类
	private static class MySingletonHandler{
		private static MySingleton instance = new MySingleton();
	} 
	
	private MySingleton(){}
	 
	public static MySingleton getInstance() { 
		return MySingletonHandler.instance;
	}
}

	public class MySingleton{
	 
	private static MySingleton instance = null;
	 
	private MySingleton(){}
 // static 代码块
	static{
		instance = new MySingleton();
	}
	
	public static MySingleton getInstance() { 
		return instance;
	} 
}


```




工厂模式

代理模式

静态代理

JDK动态代理

CGLIB动态代理
