

## 单元测试框架

### mocha

Mocha 是一个灵活的测试框架，==但它只是一个结构==，你需要引入其他插件来实现一些测试功能，比如断言库、覆盖统计等。

[中文文档](https://mochajs.cn/) 

[官方文档](https://mochajs.org/)

#### **安装依赖**

 ```bash
 $ npm install --global mocha
 ```


#### 断言库 - assert

正如上面说的，需要用到一些其他库，来实现测试功能。

示例的测试脚本会用到断言库，需要安装`assert`库。

![image-20200402112021692](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-04-02-032022.png)

```bash
$ npm install assert --save-dev
```



#### 写测试脚本

一般测试脚本的后缀格式有2种：

- `.test.js`（表示单个测试）
- `.spec.js`（表示规格）

简单示例

 ```
// 引入需测试的模块或类
const add = require("./add");
const assert = require("assert");

// describe：定义一组测试
describe("加法函数测试", function() {
    before(function() {
        // runs before all tests in this block
    });
    
    // it: 定义一个测试用例
    it("1 加 1 应该等于 2", function() {
        // assert: nodejs内置断言模块
        assert.equal(add(1, 1), 2);
    });
    
    after(function() {
        // runs after all test in this block
    });
});
 ```



#### 运行test

```
"test": "mocha test/*.test.js"
```



超时设置



### 断言库 - chai

https://www.chaijs.com/



```js
const chai = require('chai')
const {expect, assert, should } = chai;

// 断言不为null
expect(markets).to.not.a('null')

// 断言对象结构
		expect(brokerInfo).to.have.any.keys('timezone', 'serverTime', 'rateLimits', 'contracts')

// 断言equals
expect(orderInfo.status).to.equal('CANCELED')
```







# 怎么使用es6语法

安装依赖

```json
"@babel/plugin-transform-runtime": "^7.9.0",
"@babel/preset-env": "^7.9.0",
"@babel/register": "^7.9.0",
"@babel/runtime": "^7.9.2",
```

配置babelrc

```json
{
  "presets": [
    [
      "@babel/preset-env"
    ]
  ],
  "plugins": [
    [
      "@babel/plugin-transform-runtime",
      {
        "regenerator": true
      }
    ]
  ]
}

```

运行unit test

```json
"test-mocha": "mocha --require @babel/register --bail test/**"
```





# unit test写法

https://github.com/dvajs/dva/blob/master/packages/dva-core/test/reducers.test.js

[复杂model的测试](https://github.com/dvajs/dva-example-user-dashboard/pull/15/commits/df7b5fed8fe9a778b9f802a6a9944192cc1a80bb)

因为effects是saga的写法，实际是返回一个generator。所以测试时，只需要一步步next，就可以了。

主要测试流程，确认方法被调用，而且参数一致即可。

```js
import assert from 'assert'
import { describe, it } from 'mocha'
import { effects } from 'dva/saga';
import product from '../../src/models/product'
import Api from '../../src/services/index'
import apis from '../../src/apis';

const { call, put } = effects

describe('product model测试', () => {
	it('effect测试', () => {
		const saga = product.effects.watchFetchProducts
		const generator = saga({}, { call, put })
		assert.deepEqual(
			generator.next().value,
			call(Api.fetch, apis.products, { method: 'get'}),
			'fetchProducts should yield an Effect call(Api.fetch, \'./products\')'
		)
		const products = [];
		const ret = {
			data: products
		};
		assert.deepEqual(
			generator.next(ret).value,
			put({ type: 'UPDATE_PRODUCTS', products}),
			'fetchProducts should yield an Effect put({ type: \'UPDATE_PRODUCTS\', products })'
		)
	})
});

```





单元测试问题