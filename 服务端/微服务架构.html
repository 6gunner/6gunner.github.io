<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>微服务架构 | Coda的博客</title>
    <meta name="generator" content="VuePress 1.5.1">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="闲着无聊？那就读书吧">
    <link rel="preload" href="/assets/css/0.styles.c3659042.css" as="style"><link rel="preload" href="/assets/js/app.b01f8b87.js" as="script"><link rel="preload" href="/assets/js/2.7c7b516a.js" as="script"><link rel="preload" href="/assets/js/107.9df00bbf.js" as="script"><link rel="prefetch" href="/assets/js/10.173dc7ad.js"><link rel="prefetch" href="/assets/js/100.eae183ae.js"><link rel="prefetch" href="/assets/js/101.3ee1db68.js"><link rel="prefetch" href="/assets/js/102.da53b891.js"><link rel="prefetch" href="/assets/js/103.16bc5390.js"><link rel="prefetch" href="/assets/js/104.b19a4efb.js"><link rel="prefetch" href="/assets/js/105.c08b9aed.js"><link rel="prefetch" href="/assets/js/106.fbac5ec5.js"><link rel="prefetch" href="/assets/js/108.36713137.js"><link rel="prefetch" href="/assets/js/109.8bfddf69.js"><link rel="prefetch" href="/assets/js/11.0b45a4d2.js"><link rel="prefetch" href="/assets/js/110.09e4266c.js"><link rel="prefetch" href="/assets/js/111.895134a4.js"><link rel="prefetch" href="/assets/js/112.4ee4d403.js"><link rel="prefetch" href="/assets/js/113.6e981f22.js"><link rel="prefetch" href="/assets/js/114.da95feb6.js"><link rel="prefetch" href="/assets/js/115.f360a622.js"><link rel="prefetch" href="/assets/js/116.5adcbc0c.js"><link rel="prefetch" href="/assets/js/117.6781680b.js"><link rel="prefetch" href="/assets/js/118.e0c665e7.js"><link rel="prefetch" href="/assets/js/119.e5d260ea.js"><link rel="prefetch" href="/assets/js/12.92c6e45c.js"><link rel="prefetch" href="/assets/js/120.71ba7382.js"><link rel="prefetch" href="/assets/js/13.f01235bf.js"><link rel="prefetch" href="/assets/js/14.6f36b30a.js"><link rel="prefetch" href="/assets/js/15.6c792851.js"><link rel="prefetch" href="/assets/js/16.c610593a.js"><link rel="prefetch" href="/assets/js/17.d424583c.js"><link rel="prefetch" href="/assets/js/18.f2df71d6.js"><link rel="prefetch" href="/assets/js/19.5fc8cebd.js"><link rel="prefetch" href="/assets/js/20.8995b21e.js"><link rel="prefetch" href="/assets/js/21.86b9bfb1.js"><link rel="prefetch" href="/assets/js/22.a0f9800b.js"><link rel="prefetch" href="/assets/js/23.c600b58d.js"><link rel="prefetch" href="/assets/js/24.48ac403d.js"><link rel="prefetch" href="/assets/js/25.27aa9981.js"><link rel="prefetch" href="/assets/js/26.603bdaff.js"><link rel="prefetch" href="/assets/js/27.5d192a7d.js"><link rel="prefetch" href="/assets/js/28.4f3e5982.js"><link rel="prefetch" href="/assets/js/29.716c51bf.js"><link rel="prefetch" href="/assets/js/3.507fd7ae.js"><link rel="prefetch" href="/assets/js/30.aafc607e.js"><link rel="prefetch" href="/assets/js/31.bdfd52fb.js"><link rel="prefetch" href="/assets/js/32.0d011539.js"><link rel="prefetch" href="/assets/js/33.748e0e64.js"><link rel="prefetch" href="/assets/js/34.8349e309.js"><link rel="prefetch" href="/assets/js/35.084d406c.js"><link rel="prefetch" href="/assets/js/36.0b2dce78.js"><link rel="prefetch" href="/assets/js/37.85f03f45.js"><link rel="prefetch" href="/assets/js/38.584eaacf.js"><link rel="prefetch" href="/assets/js/39.67c1dd42.js"><link rel="prefetch" href="/assets/js/4.484f1216.js"><link rel="prefetch" href="/assets/js/40.d1352a35.js"><link rel="prefetch" href="/assets/js/41.694d5292.js"><link rel="prefetch" href="/assets/js/42.571072a6.js"><link rel="prefetch" href="/assets/js/43.dba2fb81.js"><link rel="prefetch" href="/assets/js/44.d16f3d43.js"><link rel="prefetch" href="/assets/js/45.a80fe4d5.js"><link rel="prefetch" href="/assets/js/46.c6ea187c.js"><link rel="prefetch" href="/assets/js/47.e3f37508.js"><link rel="prefetch" href="/assets/js/48.7f49a9ad.js"><link rel="prefetch" href="/assets/js/49.2e431e0e.js"><link rel="prefetch" href="/assets/js/5.5858b048.js"><link rel="prefetch" href="/assets/js/50.d55d5479.js"><link rel="prefetch" href="/assets/js/51.f098c778.js"><link rel="prefetch" href="/assets/js/52.a7a42528.js"><link rel="prefetch" href="/assets/js/53.c8988d92.js"><link rel="prefetch" href="/assets/js/54.4af29f73.js"><link rel="prefetch" href="/assets/js/55.d96ea8bf.js"><link rel="prefetch" href="/assets/js/56.cc7e9b8c.js"><link rel="prefetch" href="/assets/js/57.e807c88e.js"><link rel="prefetch" href="/assets/js/58.13ed5ef4.js"><link rel="prefetch" href="/assets/js/59.a0830e9b.js"><link rel="prefetch" href="/assets/js/6.f73da795.js"><link rel="prefetch" href="/assets/js/60.8d8691b9.js"><link rel="prefetch" href="/assets/js/61.ebbc571f.js"><link rel="prefetch" href="/assets/js/62.bb6a1508.js"><link rel="prefetch" href="/assets/js/63.3655fdf8.js"><link rel="prefetch" href="/assets/js/64.5ccf4ac4.js"><link rel="prefetch" href="/assets/js/65.e48b166a.js"><link rel="prefetch" href="/assets/js/66.e10e2464.js"><link rel="prefetch" href="/assets/js/67.5ef309f9.js"><link rel="prefetch" href="/assets/js/68.ff92bb0f.js"><link rel="prefetch" href="/assets/js/69.538bbf7e.js"><link rel="prefetch" href="/assets/js/7.85224d23.js"><link rel="prefetch" href="/assets/js/70.aecadc23.js"><link rel="prefetch" href="/assets/js/71.7dd797e5.js"><link rel="prefetch" href="/assets/js/72.bbbb62c8.js"><link rel="prefetch" href="/assets/js/73.44a64935.js"><link rel="prefetch" href="/assets/js/74.5734e0fe.js"><link rel="prefetch" href="/assets/js/75.9eaaa3ea.js"><link rel="prefetch" href="/assets/js/76.888799eb.js"><link rel="prefetch" href="/assets/js/77.05d11301.js"><link rel="prefetch" href="/assets/js/78.e2a28ba2.js"><link rel="prefetch" href="/assets/js/79.8f1962e9.js"><link rel="prefetch" href="/assets/js/8.95d07ea6.js"><link rel="prefetch" href="/assets/js/80.df29dcd6.js"><link rel="prefetch" href="/assets/js/81.393d4b6c.js"><link rel="prefetch" href="/assets/js/82.bf8f0cdc.js"><link rel="prefetch" href="/assets/js/83.a1a88c99.js"><link rel="prefetch" href="/assets/js/84.a26427b1.js"><link rel="prefetch" href="/assets/js/85.666c5e39.js"><link rel="prefetch" href="/assets/js/86.eea33505.js"><link rel="prefetch" href="/assets/js/87.19fa760b.js"><link rel="prefetch" href="/assets/js/88.530eedcd.js"><link rel="prefetch" href="/assets/js/89.eb06a80b.js"><link rel="prefetch" href="/assets/js/9.041b6deb.js"><link rel="prefetch" href="/assets/js/90.2f263238.js"><link rel="prefetch" href="/assets/js/91.f0fd5d45.js"><link rel="prefetch" href="/assets/js/92.82878d0f.js"><link rel="prefetch" href="/assets/js/93.c34f020a.js"><link rel="prefetch" href="/assets/js/94.2543f30a.js"><link rel="prefetch" href="/assets/js/95.2c54472d.js"><link rel="prefetch" href="/assets/js/96.7ba419b3.js"><link rel="prefetch" href="/assets/js/97.03e5d4c8.js"><link rel="prefetch" href="/assets/js/98.0f492bd7.js"><link rel="prefetch" href="/assets/js/99.780751c2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c3659042.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Coda的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/服务端/" class="nav-link">
  服务端
</a></div><div class="nav-item"><a href="/前端/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/android/" class="nav-link">
  android
</a></div><div class="nav-item"><a href="/DevOps/" class="nav-link">
  devOps
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/服务端/" class="nav-link">
  服务端
</a></div><div class="nav-item"><a href="/前端/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/android/" class="nav-link">
  android
</a></div><div class="nav-item"><a href="/DevOps/" class="nav-link">
  devOps
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>微服务架构</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#微服务架构" class="sidebar-link">微服务架构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#微服务架构概述" class="sidebar-link">微服务架构概述</a></li><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#微服务与soa的区别" class="sidebar-link">微服务与SOA的区别</a></li><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#微服务的利与弊" class="sidebar-link">微服务的利与弊</a></li></ul></li><li><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#企业何时引入微服务架构？" class="sidebar-link">企业何时引入微服务架构？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#演进式架构师应该承担的职责" class="sidebar-link">演进式架构师应该承担的职责</a></li><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#微服务的组织架构" class="sidebar-link">微服务的组织架构</a></li><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#中台战略" class="sidebar-link">中台战略</a></li><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#一个清晰简洁的微服务分层" class="sidebar-link">一个清晰简洁的微服务分层</a></li></ul></li><li><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#微服务的技术架构模型" class="sidebar-link">微服务的技术架构模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#引入微服务架构需要解决的问题" class="sidebar-link">引入微服务架构需要解决的问题</a></li><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#通信协议rpc-vs-rest" class="sidebar-link">通信协议RPC VS REST</a></li><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#服务发现机制" class="sidebar-link">服务发现机制</a></li><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#service-mesh" class="sidebar-link">Service Mesh</a></li><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#api网关" class="sidebar-link">API网关</a></li><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#zuul网关架构" class="sidebar-link">Zuul网关架构</a></li><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#netflix的微服务路由发现机制" class="sidebar-link">Netflix的微服务路由发现机制</a></li><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#配置中心" class="sidebar-link">配置中心</a></li><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#微服务治理" class="sidebar-link">微服务治理</a></li><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#服务监控体系" class="sidebar-link">服务监控体系</a></li><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#调用链监控" class="sidebar-link">调用链监控</a></li><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#熔断限流" class="sidebar-link">熔断限流</a></li><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#容器技术" class="sidebar-link">容器技术</a></li><li class="sidebar-sub-header"><a href="/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html#蓝绿部署和灰度发布" class="sidebar-link">蓝绿部署和灰度发布</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="微服务架构"><a href="#微服务架构" class="header-anchor">#</a> 微服务架构</h2> <h3 id="微服务架构概述"><a href="#微服务架构概述" class="header-anchor">#</a> 微服务架构概述</h3> <img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-09-15-015353.png" alt="image-20190915095352570" style="zoom:43%;"> <p><strong>Q1:独立部署给业务带来什么好处？</strong></p> <p>服务可以根据业务划分，不同业务之间可以独立开发，分开上线。</p> <p>和集中化部署相比，不会依赖于整体业务开发完成才能上线，业务拓展能力比较强。</p> <p>可以频繁发布不同的服务，同时保持系统其他部分可用。</p> <p>每个微服务团队能够选择自己擅长的技术栈；</p> <h3 id="微服务与soa的区别"><a href="#微服务与soa的区别" class="header-anchor">#</a> 微服务与SOA的区别</h3> <p><strong>SOA</strong>：面向服务的架构。服务之间通过相互依赖最终提供一系列的功能。每个服务独立存在于系统之中，各个服务之间通过网络调用。</p> <p><strong>微服务</strong>：它和SOA类似，是在SOA的基础上做的升华。但微服务架构强调的重点是==业务需要彻底的组件化和服务化==。业务需要更细粒度的拆分成可以独立开发、运行、部署的小应用。</p> <p><strong>主要区别</strong></p> <table><thead><tr><th>区别点</th> <th>SOA</th> <th>微服务</th></tr></thead> <tbody><tr><td><strong>拆分依据</strong></td> <td>大块业务逻辑</td> <td>单独任务、小块业务逻辑</td></tr> <tr><td><strong>耦合</strong></td> <td>通常是松耦合</td> <td>总是松耦合，高内聚</td></tr> <tr><td><strong>适用公司架构</strong></td> <td>任何类型</td> <td>小型、专注于功能交叉的团队</td></tr> <tr><td><strong>服务管理</strong></td> <td>集中管理</td> <td>分散管理</td></tr></tbody></table> <h3 id="微服务的利与弊"><a href="#微服务的利与弊" class="header-anchor">#</a> 微服务的利与弊</h3> <p><strong>利</strong></p> <ul><li>可以用微服务的模式来模块化开发业务，让每个团队的边界都很清晰，相互调用；</li> <li>可以独立部署服务</li> <li>技术可以多样性，每个团队可以用自己擅长的技术；</li></ul> <p><strong>弊</strong></p> <ul><li>分布式服务一般都很复杂；</li> <li>测试复杂性很高；</li> <li>最终一致性:  每个团队开发的服务，数据需要保证一致，所以需要同步。</li> <li>运维部署很复杂，维护稳定性也很困难，对运维的要求也很高。要有固定的docker容器，也要有故障演练；</li></ul> <h2 id="企业何时引入微服务架构？"><a href="#企业何时引入微服务架构？" class="header-anchor">#</a> <strong>企业何时引入微服务架构？</strong></h2> <blockquote><p>好的微服务架构是演变出来的，不是设计出来的；</p> <p>应该设计一个合理的框架，在这个框架下可以慢慢演变出正确的系统；</p></blockquote> <p><strong>前期不建议直接上手微服务</strong>：</p> <p>1.是前期对业务理解不深，业务不好拆分，而且系统一开始也不会很复杂；</p> <p>2.是前期微服务投入成本过高，甚至业务模式都没被商业认证，可能开发出来都不会被市场接受，采用微服务代价太大。</p> <p>3.前期微服务复杂度高，生产力并不高，应该在业务发展的过程中，找到一个点去切换微服务；</p> <p><strong>中期逐渐转化成微服务</strong>：</p> <p>1.业务务不断拓展，复杂度增加，产品本身的生产力会下降</p> <p>2.团队规模不断扩大，可以有更多的人投入到微服务上；</p> <p><strong>总结：</strong></p> <p>过早的将一个系统划分成为微服务的代价非常高，尤其是面对新领域的时候。很多时候，将一个已有的系统划分成为微服务，要比从头开始构建微服务简单的多；</p> <h3 id="演进式架构师应该承担的职责"><a href="#演进式架构师应该承担的职责" class="header-anchor">#</a> 演进式架构师应该承担的职责</h3> <ul><li><p><strong>愿景</strong></p> <p>确保在系统级有一个经过充分沟通的技术愿景，这个愿景应该可以帮助你满足客户和组织的需求；</p></li> <li><p><strong>同理心</strong></p> <p>理解你所做的决定对客户和同事带来的影响；</p></li> <li><p><strong>合作</strong></p> <p>和尽量多的同事进行沟通，从而更好地对愿景进行定义、修订以及执行</p></li> <li><p><strong>适应性</strong></p> <p>确保在你的客户和组织需要的时候，调整基数愿景</p></li> <li><p><strong>自治性</strong></p> <p>在标准化和团队自治之间寻找一个正确的平衡点</p></li> <li><p><strong>治理</strong></p> <p>确保系统按照技术愿景的要求实现</p></li></ul> <p>成功要靠不断的取舍来实现。总会有一些原因需要你改变工作的方式，但是具体做哪些改变就只能依赖于自己的经验了。</p> <h3 id="微服务的组织架构"><a href="#微服务的组织架构" class="header-anchor">#</a> 微服务的组织架构</h3> <blockquote><p>康威法则: 设计系统的组织以及所产生的架构，等价于企业的组织架构；</p></blockquote> <p><s>传统的组织架构：产品部门、用户体验部门、研发部门、测试部门、。。。运维部门等；</s></p> <p>微服务组织架构：跨职能微服务产品团队</p> <p>微服务架构实际上是组织架构的一种重组：从以前的职能部门，转换成跨职能部门的组织架构；</p> <p>团队人员不再只是&quot;围绕项目建立，当项目结束以后就回到职能部门”；而是围绕着微服务来建立团队，不断的开发迭代，从而提供一个API、平台产品。</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040706.png" alt="246c7f96401297282f4a5e7574d81c71_403x359"></p> <p>微服务核心概念：<strong>端到端 （End to End</strong> <strong>Ownership</strong>）团队内部之间能够形成一个闭环。</p> <img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-09-16-124506.jpg" width="300"> <p>每个团队自行负责产品的设计，架构，开发，构建，部署，运维，支持。团队各自发布自己的模块，团队间模块解耦，升级时向下版本兼容，互不影响。一个团队规模大致12人左右。</p> <h3 id="中台战略"><a href="#中台战略" class="header-anchor">#</a> 中台战略</h3> <p>中台概念的由来：2013年，马云带领阿里的高管，参观了supercell。一家位于芬兰的移动游戏公司。发现他们公司的虽然团队特别小，但是居然能够在几周时间内就做出一款游戏。其中除了敏捷开发、快速试错以外，其成功还有一个最关键的要素就是supercell的中台能力。supercell的中台架构模式给阿里高管很大的震撼，这也催生了阿里巴巴的中台战略。</p> <p>阿里中台战略：&quot;大中台、轻前台&quot;。通过厚实的中台架构，来向前台输送弹药。让前台业务更加灵活，并且能快速适应市场的需求。</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040708.png" alt="中台架构"></p> <p>中台：</p> <p>最后推荐一篇文章：互联网公司中所谓中台是怎么定义的？ -  知乎
https://www.zhihu.com/question/57717433/answer/719218827</p> <h3 id="一个清晰简洁的微服务分层"><a href="#一个清晰简洁的微服务分层" class="header-anchor">#</a> 一个清晰简洁的微服务分层</h3> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040721.png" alt="5a7a5ed7818d8bb427548f493b3d3924_1193x541"></p> <p>从业务逻辑上：我们把服务分为<code>聚合服务</code>和<code>基础服务</code>两层；</p> <p><code>基础服务</code>主要提供比较基础的、通用的接口服务。这些服务一般都是核心业务，比如订单服务、账户服务。</p> <p><code>聚合服务</code>，一般也叫适配服务，BFF。它根据业务需要，将多个基础服务组合在一起，或者对服务的返回数据进行相应裁剪。以减少基础服务的重复开发，也避免了客户端过多的请求调用，减少开销。</p> <h2 id="微服务的技术架构模型"><a href="#微服务的技术架构模型" class="header-anchor">#</a> 微服务的技术架构模型</h2> <p><strong>6层架构模型</strong></p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040710.png" alt="e7e9618ee6bd013513ffc85a67b5da26_1468x881"></p> <h3 id="引入微服务架构需要解决的问题"><a href="#引入微服务架构需要解决的问题" class="header-anchor">#</a> 引入微服务架构需要解决的问题</h3> <p>微服务之间如何通信？</p> <p>微服务之间如何互相发现</p> <p>微服务的部署、更新、扩容</p> <h3 id="通信协议rpc-vs-rest"><a href="#通信协议rpc-vs-rest" class="header-anchor">#</a> 通信协议RPC VS REST</h3> <table><thead><tr><th></th> <th>RPC</th> <th>REST</th></tr></thead> <tbody><tr><td>耦合性</td> <td>强耦合</td> <td>松散耦合</td></tr> <tr><td>消息协议</td> <td>二进制协议</td> <td>JSON 、XML文本协议</td></tr> <tr><td>通讯协议</td> <td>TCP</td> <td>HTTP/HTTP2</td></tr> <tr><td>性能</td> <td>高</td> <td>低于RPC</td></tr> <tr><td>接口契约</td> <td>thrift、profobuf</td> <td>Swagger 接口定义</td></tr> <tr><td>客户端</td> <td>强类型客户端，可以支持多语言客户端</td> <td>一般http client可访问，支持多客户端语言。</td></tr> <tr><td>案例 - 框架</td> <td>Dubbo(阿里), motan,  grpc(google), thrift</td> <td>SpringMVC, SpringBoot, jax-rs, dropwizard</td></tr> <tr><td>开发者友好</td> <td>客户端比较方便，但是二进制消息不可读。调试比较麻烦；</td> <td>文本可读，通过浏览器可访问</td></tr> <tr><td>对外开放</td> <td>对外暴露时，一般需要转换成REST协议的形式</td> <td>直接对外开放</td></tr></tbody></table> <h3 id="服务发现机制"><a href="#服务发现机制" class="header-anchor">#</a> 服务发现机制</h3> <blockquote><p>消费者发现生产者服务</p></blockquote> <ol><li><strong>传统模式：基于LB</strong></li></ol> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040709.png" alt="image-20190915101129140"></p> <p>服务上线时，向运维申请域名，运维人员根据域名配置负载均衡，然后提供域名给客户端去调用；</p> <p>客户端通过域名DNS解析到负载均衡服务器上，从而调用服务；</p> <p><strong>缺点：</strong></p> <ul><li><p>需要运维人工介入，每加一个服务，都需要去配置一下；</p></li> <li><p>负载均衡器很可能是单节点的，如果 LB挂了，所有的服务都可能无法访问；</p></li> <li><p>性能会有损失, 因为客户端所有需要访问的服务都必须穿透LB。</p></li></ul> <ol start="2"><li><strong>进程内LB模式</strong></li></ol> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040736.png" alt="775cf00315d405b94adae2d1ed717319_599x318"></p> <p><code>服务提供方(Service Provider)</code>通过服务注册方式(服务注册表)向外发布服务，并且定期发送心跳，告诉服务注册表我还活着</p> <p><code>服务消费者Consumer</code>自带LB, 用来支持服务发现和负载均衡功能。LB发现并调用后台服务，同时定期去同步服务注册表中的服务；</p> <p>好处：</p> <ol><li><p>解决了单点的问题，没有集中LB。</p></li> <li><p>同时解决了LB消耗性能的问题，因为都是进程内服务；</p></li></ol> <p>缺点：</p> <p>1.每个进程内有一个独立LB，那么LB需要开发不同的语言版本，支持多种开发语言；</p> <p>2.升级维护很麻烦；</p> <ol start="3"><li><strong>主机独立LB</strong></li></ol> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040722.png" alt="f8a5f8babc09866d8f4117f214c00336_597x262"></p> <p>把LB以独立进程部署, 和消费者放在一个主机上；LB可以支持多语言。</p> <p>可以用容器的方式来部署服务+LB；</p> <blockquote><p>问题：以容器的方式来部署，是将LB部署在容器上，容器内服务共享？还是部署在容器主机上，所有容器共享？</p></blockquote> <p>容器部署的话，建议每个容器部署一个独立进程LB（如Service Mesh），这样隔离性更好，容器内的LB挂了，只影响那个容器，主机上其它容器不受影响。</p> <p>如果容器共享主机上的独立进程LB的话，则如果主机上的LB挂了，则整个主机上的容器全部受影响。</p> <h3 id="service-mesh"><a href="#service-mesh" class="header-anchor">#</a> Service Mesh</h3> <blockquote><p>Service Mesh/服务网格，是一个基础层设施，功能在于处理服务间的通信，职责是负责实现请求的可靠传递；</p></blockquote> <h4 id="sidecar"><a href="#sidecar" class="header-anchor">#</a> SideCar</h4> <p>首先需要了解一下<code>SideCar/边车</code>的设计模式。他主要的作用是用来发现服务，转发客户端的请求，调用服务。</p> <p>他的设计灵感有点类似于摩托车的边车，它不一定应用程序中的一部分，但是可以连接服务的一部分，也可以放在服务程序的任意一个位置。</p> <p>看一下Service Mesh中SideCar的架构：</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040734.jpg" alt="5a5491d2835ec"></p> <p>客户端通过简单RCP，来连接到Sidecar服务，Sidecar再通过服务注册中心发现服务，最后将客户端请求代理转发到最终的目标服务；</p> <p>这里的Sidecar并不是传统意义上的Sidecar，而是Service Mesh单应用场景下的表现形式；</p> <p>Sidecar和Service Mesh的区别主要有三点：</p> <table><thead><tr><th></th> <th>Sidecar</th> <th>Service Mesh</th></tr></thead> <tbody><tr><td>整体性</td> <td>单组件</td> <td>强调整体的网络</td></tr> <tr><td>适用性</td> <td>只能适用于特定的框架</td> <td>可以通用适配</td></tr> <tr><td>可选择性</td> <td>可选的，允许直连</td> <td>必须经过ServiceMesh</td></tr></tbody></table> <p>多个微服务调用的结构：</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-10-01-074011.jpg" alt="5a54921232d1a"></p> <p>Service Mesh在所有的服务下面，负责处理所有的服务连接，这一层也称为：<code>服务间通讯专用基础设施层</code></p> <p>如果有大量的服务连接，呈现出来的就是一个网格状(Service Mesh)。绿色部分代表应用，蓝色部分代表SideCar。</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040737.jpg" alt="5a5492269b895"></p> <p>大量服务连接的网格里，ServiceMesh不再被视为单个进程，而是强调整个代理连接形成的网络；这也是它和Sidecar的不同点。</p> <h4 id="service-mesh的演变"><a href="#service-mesh的演变" class="header-anchor">#</a> Service Mesh的演变</h4> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040730.jpg" alt="9ef38cc2efaa4d7cb16a4cce3110864f"></p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040738.jpg" alt="d8f1b8d7e1f54b91a6d56ee622c0e9d3"></p> <p>似乎框架层帮我们解决了微服务的很多问题：负载均衡，限流熔断，安全限制等等。但是每个微服务都需要这些基础的功能，而微服务开发的语言可能又大不相同，并且类似于SpringCloud、Dubbo这些微服务框架也会造成很多痛点。</p> <p><strong>痛点1</strong>：门槛高。框架的学习门槛比较高，简单入门比较容易，但是熟练应用和深入了解需要大量的时间。而业务团队的优势往往不是技术，而是业务的理解和对系统的了解。</p> <p><strong>痛点2</strong>：功能不全<img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040717.png" alt="b456e3c0500f4e6ead2730a9eb639b9d"></p> <p>传统的Spring Cloud、Dubbo框架提供的功能有限，不具备一整套生态系统；基于Spring Cloud的基础版本做完整补充、扩展、加强需要巨大的精力；</p> <p><strong>痛点3</strong>: 跨语言</p> <p>微服务可以采用最适合的语言来编写。理论上说，不同的团队，不同的微服务，可以根据实际情况选择团队最擅长，或者最适合当前应用的编程语言。但是这样就要提供不同语言的框架，实际需要面临巨大的开发工作量，代价极高；</p> <p><strong>痛点4</strong>：升级困难</p> <p>当服务端数以百计起，客户端数以千计起时。服务端升级，客户端可能不会选择升级，那么就必须去兼容每个版本，再加上不同的语言版本，试想下需要消耗多大的精力，投入多少工作量！</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040725.jpg" alt="b4209fab90db42cbb8893e38782442b2"></p> <p>借鉴当年TCP/IP的思路，对于服务间通讯，在传统的侵入式框架外，出现了另外一种思路：</p> <p>既然我们可以把网络通讯的技术栈剥离并下沉为TCP，我们是否也可以用类似的方式来处理微服务中服务间通讯的技术栈。于是出现了上面的演变方案，通过配置文件来实现反向代理，将请求路由到服务；</p> <p>虽然这个方案很简陋，但是依然有值得借鉴的地方：客户端和服务器端应该隔离，部分功能下沉到中间层来实现请求转发。</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-40724.jpg" alt="ed2a3bf738dc4b868cb9bf3d9e65d885"></p> <p>Sidecar借鉴了Proxy的模式，但是他的设计局限性很强，表现为<strong>为特定的基础设施而设计</strong>。只适用于特定的框架或者需求场景，很难对外推广。</p> <p><strong>第一代Service Mesh</strong></p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040723.jpg" alt="52055434dac2409dba020b102f22136c"></p> <p><strong>第二代Service Mesh</strong></p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040732.jpg" alt="d71ab7aaf1eb446b848d215a9dce8130"></p> <p><strong>总结</strong></p> <p>Service Mes应需而生，解决了传统微服务框架带来的4个痛点：</p> <p>内容高，门槛多；——&gt; 交给Service Mesh，应用只需要关注与业务逻辑；</p> <p>服务治理功能不齐全； ——&gt; Service Mesh功能齐全</p> <p>升级困难； ——&gt; 可单独升级</p> <p>跨语言； ——&gt; 客户端简化，通过rest或其他简单远程调用方式；服务端只需要做服务注册的事情；</p> <h3 id="api网关"><a href="#api网关" class="header-anchor">#</a> API网关</h3> <blockquote><p>为什么要使用API网关？</p> <p>API网关是一个系统与外界连接的入口。可以理解为一个企业的大门，用来做安全防护，限制访问，请求路由等工作；</p></blockquote> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040724.png" alt="3912920-df6b13ad41a9ce3d"></p> <p>网关的作用：</p> <p>网关服务最主要的作用，是为内部服务提供统一的对外出口，向外部访问者提供统一的服务入口。可以屏蔽内部的服务细节。</p> <p>网关可以对外界访问做一个安全防护，比如限制外部访问、统一鉴权、熔断等。</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040725.png" alt="13e53557b2a76cb69144c23a8fa7db36_851x449"></p> <p>最上层是用户接入设备</p> <p>通过负载均衡器（一般网关服务都是无状态服务，无论通过哪一个网关服务，都可以提供同样的服务。所以做了一层负载均衡，避免单点故障）</p> <p>转发到网关服务，从而最终请求各个微服务。</p> <ul><li><strong>反向路由</strong>：将内部的服务转化成为对外服务</li> <li>安全认证：用于检测请求，识别身份</li> <li>限流熔断：防止大流量的访问</li> <li>日志监控：记录日志</li></ul> <h4 id="无状态服务vs有状态服务"><a href="#无状态服务vs有状态服务" class="header-anchor">#</a> 无状态服务VS有状态服务</h4> <p>无状态服务：对于单次的请求，不依赖于其他请求数据就能完成。也就是，客户端每次发过来的请求，服务端只需要根据这次请求传入的信息，可能再加上一些外部的依赖服务（如数据库），就可以完成对请求处理，服务本身不存储任何信息。</p> <p>有状态服务：在服务端保存了一些数据信息，请求的先后顺序有一定的关联性。比如发送验证码和校验验证码；</p> <h3 id="zuul网关架构"><a href="#zuul网关架构" class="header-anchor">#</a> Zuul网关架构</h3> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040728.png" alt="18adb3e66cedfa991acbead83c8ae970_1150x832"></p> <p>框架的核心特点：</p> <p>​	1. 3层Filter；</p> <p>​	2. 可插拔Filter配置；</p> <p>​	Zuul的Filter可以很灵活的配置。开发者开发完Filter过滤器后。</p> <p>​	a. 首先通过publisher存储在<code>Filter Database</code>中，</p> <p>​	b. 通过poller轮训上传到<code>Filter Directories</code>里。</p> <p>​	c. 上层的<code>Filter File Manager</code>会定期扫描<code>Filter Directories</code>，</p> <p>​	4. 最后通知loader将Filter加载到Runner里，应用起来；</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040735.png" alt="0fc714c1ce4966d8f095075b9162d860_1498x905"></p> <p>核心模块：</p> <p>​	Pre Filters前置路由：请求进来，先经过<code>Pre Filters</code>, 例如可以做日志记录；</p> <p>​	Routing Filters路由：主要作用就是路由并找到具体的微服务，请求服务；</p> <p>​	Post Filters后置路由：主要是处理需要返回给客户的消息;</p> <p>​	Error Filters: 所有路由拦截的过程中出现的错误，都可以抛给Error Filter来统一处理，最后交给Post Filters来返回；</p> <h3 id="netflix的微服务路由发现机制"><a href="#netflix的微服务路由发现机制" class="header-anchor">#</a> Netflix的微服务路由发现机制</h3> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040731.png" alt="050291d25a274c5611651e1a27f21c02_1726x906"></p> <p>Netflix服务注册中心组件： Eureka</p> <p>Netflix网关组件：Zuul</p> <p>两个组件支撑了整个netflix的路由发现体系：</p> <p>第一层服务发现机制：</p> <p>基础服务启动时，会向Eureka注册服务，内部的聚合服务需要用到基础服务时，通过<code>服务注册中心</code>来发现服务。</p> <p>第二层服务发现机制：</p> <p>聚合服务也会向注册中心注册服务，网关层作为客户的统一接入点，会通过注册中心的路由表，来找到对应的聚合服务。</p> <blockquote><p>问题：现在市面上有很多组件，比如Zookeeper,Consul,还有nginx等等。那么用这些组件, 该如何做微服务发现机制呢?</p></blockquote> <h3 id="配置中心"><a href="#配置中心" class="header-anchor">#</a> 配置中心</h3> <blockquote><p>问题：问什么需要配置中心？</p></blockquote> <p>大部分时候，我们的配置都是写在配置文件中的。会有一些缺点或者会造成一些问题：</p> <ol><li>配置不标准, 格式不统一</li> <li>生效周期长</li> <li>配置被修改了并不知道，往往部署到线上了才发现；</li> <li>而且没有审计功能,  很难追溯谁调整的，只能查看代码记录；</li></ol> <blockquote><p>一般有哪些可以配置的项？</p></blockquote> <ul><li>数据库连接字符串</li> <li>超时参数</li> <li>业务开关</li> <li>功能开关等</li></ul> <h4 id="基本原理"><a href="#基本原理" class="header-anchor">#</a> 基本原理</h4> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040734.png" alt="img"></p> <p>开发人员可以对配置中心更改配置, 然后服务可以实时更改自己配置。
2种读取配置的方式：(各有优劣)</p> <ol><li>自己不断的去拉,然后更新自己(这个可以保证拉到,这次没拉到,下次再拉)</li> <li>配置中心自己主动推送(这个可以实时,但是没推成功,就不是实时)</li></ol> <h4 id="apollo配置中心架构"><a href="#apollo配置中心架构" class="header-anchor">#</a> Apollo配置中心架构</h4> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040716.png" alt="164492343a4d7c4fc78c336a9c901c72_1597x782"></p> <h3 id="微服务治理"><a href="#微服务治理" class="header-anchor">#</a> 微服务治理</h3> <blockquote><p>服务治理一般包含哪些内容？</p></blockquote> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040726.png" alt="ebe8f11b112897e58ff36732b222ce40_1709x867"></p> <ul><li><p><strong>服务发现</strong>：好的微服务框架需要能够有服务发现机制；</p></li> <li><p><strong>负载均衡</strong>：大规模的服务发布需要负载均衡，保证服务不会单点故障；也可以应用到服务升级上，蓝绿升级。</p></li> <li><p><strong>监控</strong></p> <ul><li><strong>日志监控</strong>：日志监控、日志查看用来排查线上问题；</li> <li><strong>Metrics</strong>：多角度去监控服务</li> <li><strong>调用链监控</strong>：在错综复杂的微服务系统中，调用逻辑往往很复杂，需要通过调用链监控系统查看具体哪个环节出现问题；</li></ul></li> <li><p><strong>熔断限流</strong>：高并发情况下，任意一个服务崩溃都会导致整个系统的崩溃；所以需要加入限流熔断，避免高频率的访问；</p></li> <li><p><strong>安全</strong>&amp;<strong>访问控制</strong>：网关的基础功能，限制功能访问；</p></li> <li><p><strong>REST</strong>/<strong>RPC</strong>: 支持两种协议的访问；</p></li> <li><p><strong>统一异常处理</strong>：统一规范错误模式，方便查看日志。</p></li> <li><p><strong>文档</strong>：对外对内的API文档输出，最好能自动生成；</p></li> <li><p><strong>配置集成</strong>：通过配置中心，来实现动态修改配置，实时发布服务；</p></li></ul> <h3 id="服务监控体系"><a href="#服务监控体系" class="header-anchor">#</a> 服务监控体系</h3> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040737.png" alt="4a9f578da1eace0ca6c0666acae5e17f_1757x909"></p> <blockquote><p>5个层次，从下往上依次为</p></blockquote> <p><strong>基础设施监控</strong>: 一般都是服务运营商去进行监控；</p> <p><strong>系统层监控</strong>：主要监控对象为物理机、虚拟机、操作系统，监控指标一般是cpu、内存、网络、硬盘等；</p> <p><strong>应用层监控</strong>：应用层一般针对服务进行监控，主要关心<code>服务接口</code>是否可用、平均响应时间、（qbs）每秒钟处理请求数量、是否存在慢查询等等。</p> <p><strong>业务监控</strong>：主要监控核心业务，比如看下下单情况、注册登录情况。产品部门会针对业务层的监控数据进行分析，来判断产品是否满足市场需求、推广的效果是否符合预期等；</p> <p><strong>端用户体验监控</strong>：这个一般就是针对客户端进行监控。比如对客户端版本进行监控，接入的运营商是移动还是电信等等。用户体验监控主要是产品经理比较关心的地方；</p> <h4 id="监控内容"><a href="#监控内容" class="header-anchor">#</a> 监控内容</h4> <ul><li>健康检查</li> <li>告警系统</li> <li>调用链监控</li> <li>日志监控</li> <li>Metrics监控</li></ul> <h4 id="监控方案"><a href="#监控方案" class="header-anchor">#</a> 监控方案</h4> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040733.png" alt="1bfb36ddd14d2375188465288b87b226_1704x866"></p> <p><strong>方案理解：</strong></p> <p>微服务一般会在进程内部或者主机上加一个<code>agent（代理）</code>，这个代理会去收集并分发日志</p> <p>如果日志量过大，可以通过消息队列（Kafka）做一个缓冲，</p> <p>所有的日志会通过<code>ELK</code>方案，进行全文搜索分析；</p> <p>同时会通过<code>Metrics</code>来监控<code>度量</code>，将不同维度的度量数据存储在<code>InfluxDB</code> 的时间序列数据库中，Grafana针对数据进行可视化展示。</p> <p>最后通过一个<code>健康检查机制</code>sensu/Nagios/Kubernetes，来去检查微服务的监控情况</p> <p><strong>方案技术框架</strong></p> <blockquote><p><code>ELK</code>是Elasticsearch + logstash + kibana三个结合在起一起缩写；</p> <p>Elasticsearch是实时全文搜索和引擎分析</p> <p>logstash是用来搜集、分析、过滤日志的工具</p> <p>kibana是基于web的图形界面，用于搜索、分析和可视化数据</p></blockquote> <h3 id="调用链监控"><a href="#调用链监控" class="header-anchor">#</a> 调用链监控</h3> <blockquote><p>调用链监控来源于google的一篇论文：Google Dapper</p></blockquote> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040718.png" alt="323d71a2e7c3f4d8df325d12d51f037c_1505x853"></p> <p>如图所示：http请求 经过 web 容器，再在内部经过一些列服务转换，进入service1 ，再到 DB 再返回；</p> <p>每个请求经过一层调用，都会生成一个<code>span</code>;</p> <p>每个span，会生成自己的trace_id，span_id, 并且关联上层的parent_id. 这样，通过这3个id的关系，来生成调用链；</p> <h4 id="监控框架工具："><a href="#监控框架工具：" class="header-anchor">#</a> 监控框架工具：</h4> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-09-040720.png" alt="f53e7bdf7fa23d869f741aa8aca76df5_1825x852"></p> <h3 id="熔断限流"><a href="#熔断限流" class="header-anchor">#</a> 熔断限流</h3> <h4 id="hystrix框架"><a href="#hystrix框架" class="header-anchor">#</a> Hystrix框架</h4> <p>封装请求：熔断、隔离、限流、降级</p> <p>如果打开了限流措施，直接短路。</p> <p>如果线程满了</p> <p>如果运行超时：降级；</p> <h3 id="容器技术"><a href="#容器技术" class="header-anchor">#</a> 容器技术</h3> <h3 id="蓝绿部署和灰度发布"><a href="#蓝绿部署和灰度发布" class="header-anchor">#</a> 蓝绿部署和灰度发布</h3> <img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-09-18-125511.png" width="500"> <p>蓝绿部署：蓝色代表是老版本，绿色代表是新版本；</p> <p>灰度发布：不是一次性把流量全部切换到新版本上，而是先切一部分流量，确保没问题后，再全部切换到新版本上。</p> <p>微服务</p> <p>Mesos的服务框架</p> <p>Master - Slaver 模式；</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.b01f8b87.js" defer></script><script src="/assets/js/2.7c7b516a.js" defer></script><script src="/assets/js/107.9df00bbf.js" defer></script>
  </body>
</html>
