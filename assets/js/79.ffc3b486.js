(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{438:function(v,_,t){"use strict";t.r(_);var a=t(25),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"_1-栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-栈"}},[v._v("#")]),v._v(" 1.栈")]),v._v(" "),t("h3",{attrs:{id:"栈的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈的作用"}},[v._v("#")]),v._v(" 栈的作用")]),v._v(" "),t("p",[v._v("栈是用来存储临时的变量的，如果是基础数据类型，内存存放在栈里。")]),v._v(" "),t("p",[v._v("如果是引用数据类型，内存放在堆里，然后栈里存放==“堆内存的地址”的引用==。")]),v._v(" "),t("p",[v._v("栈还会存储函数的调用栈，每一个函数被调用时，函数解释器会把被执行的这个“函数”添加到调用栈里（表现为在栈里加一根栈针）。栈针可以保证这个函数有独立的作用域，栈针里存储了函数运行时产生的==局部变量==、==操作符这些信息==、==函数的出口==。")]),v._v(" "),t("p",[v._v("在一个函数里，如果调用了另一个函数，那么新的函数会被继续加入到调用栈里。等到函数执行完后，栈针被销毁。")]),v._v(" "),t("p",[v._v("然后栈里面还存储了程序的计数器，用来定位程序到底运行到哪一个行代码。")]),v._v(" "),t("h3",{attrs:{id:"栈溢出的原因？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈溢出的原因？"}},[v._v("#")]),v._v(" 栈溢出的原因？")]),v._v(" "),t("p",[v._v("一般都是因为程序出现递归调用，无法结束。这样就会因为调用栈过多，栈针无法被销毁，导致分配的栈空间被占满，就会引起“栈溢出”的问题。")]),v._v(" "),t("h3",{attrs:{id:"为什么基础数据会放在栈里？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么基础数据会放在栈里？"}},[v._v("#")]),v._v(" 为什么基础数据会放在栈里？")]),v._v(" "),t("p",[v._v("https://juejin.im/post/5d116a9df265da1bb47d717b")]),v._v(" "),t("p",[v._v("因为基础数据类型的变量一般大小固定，操作也比较简单。存放在栈内存里，运行效率高。")]),v._v(" "),t("p",[v._v("而引用数据类型的变量大小不固定，所以分配在堆内存里，一方面可以动态扩充内存；另一个方面，就是堆的内存区域比较大，存放不会引起太大性能问题。")]),v._v(" "),t("h2",{attrs:{id:"_2-堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-堆"}},[v._v("#")]),v._v(" 2.堆")]),v._v(" "),t("h3",{attrs:{id:"堆的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆的作用"}},[v._v("#")]),v._v(" 堆的作用")]),v._v(" "),t("p",[v._v("堆是一类特殊的树，堆的特点是父节点会大于或者小于所有子节点。")]),v._v(" "),t("p",[v._v("堆空间存储的数据比较复杂，分为5个区域。")]),v._v(" "),t("ul",[t("li",[v._v("代码区")]),v._v(" "),t("li",[v._v("Map区 （）")]),v._v(" "),t("li",[v._v("Large Object区")]),v._v(" "),t("li",[v._v("新生代")]),v._v(" "),t("li",[v._v("老生代")])]),v._v(" "),t("h3",{attrs:{id:"堆内存的垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆内存的垃圾回收"}},[v._v("#")]),v._v(" 堆内存的垃圾回收")]),v._v(" "),t("p",[v._v("内存回收主要发生在"),t("strong",[v._v("新生代")]),v._v("和"),t("strong",[v._v("老生代")]),v._v("两个区域。")]),v._v(" "),t("p",[v._v("==新生代内存==是临时分配的内存。它的回收算法主要是用到了==scavenge==算法来处理。")]),v._v(" "),t("p",[t("strong",[v._v("scavenge算法")])]),v._v(" "),t("p",[v._v("新生代内存空间会被划分为2个区域：from、to区域。")]),v._v(" "),t("p",[v._v("每次回收时，会对from区域进行扫描，对于没有任何变量引用的内存地址，进行回收，将存活（有变量引用）的对象复制到to区域进行保存。")]),v._v(" "),t("p",[v._v("扫描完成之后，将from区和to区域进行对调。")]),v._v(" "),t("p",[v._v("之后下次GC时，重新执行这个步骤。")]),v._v(" "),t("p",[v._v("==老生代内存==")]),v._v(" "),t("p",[v._v("对象在新生代内存的from和to区域来回转移，每次转移，这些对象都会更新一个gc的年龄标志。当gc的年龄达到一定值时，这个对象会被移动到老生代。（java是15次，js是1次）")]),v._v(" "),t("p",[v._v("还有一种情况，从from转移到to空间时，如果to空间内存占用率已经超过25%，那么对象会被直接转移到老生代。")]),v._v(" "),t("p",[t("strong",[v._v("标记-清除 算法")])]),v._v(" "),t("p",[v._v("因为老生代的空间比较大(64位系统为1.4G，32位为700M)，所以它的内存回收主要用到了“标记-清除”和 “标记-整理”算法。标记阶段，会遍历老生代的所有对象，然后对存活的对象进行标记，清除阶段会对未标记的对象进行清除。但是这种清除会造成内存中存在很多碎片的内存。")]),v._v(" "),t("p",[t("strong",[v._v("标记-整理 算法")])]),v._v(" "),t("p",[v._v("标记整理在标记清除算法的基础上，将清除的阶段变为紧缩阶段。在整理的过程中，会将存活的对象向内存区的一段移动，移动完成后，直接清理边界外的内存。https://segmentfault.com/a/1190000000440270")]),v._v(" "),t("p",[v._v("// todo v8引擎内存问题")]),v._v(" "),t("p",[v._v("https://www.cnblogs.com/cangqinglang/p/12668374.html")])])}),[],!1,null,null,null);_.default=s.exports}}]);