(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{416:function(e,t,v){"use strict";v.r(t);var r=v(25),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"框架"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#框架"}},[e._v("#")]),e._v(" 框架")]),e._v(" "),v("h2",{attrs:{id:"mvvm"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mvvm"}},[e._v("#")]),e._v(" MVVM")]),e._v(" "),v("p",[e._v("mvvm的核心理念是：将vm层和view层进行双向绑定，并且将model层和viiew层之间的联系切断。所有的业务逻辑都放在viewmodel层进行处理。")]),e._v(" "),v("p",[e._v("它的演变过程是：mvc -> mvp -> mvvm。")]),e._v(" "),v("p",[v("strong",[e._v("传统的MVC模式")])]),e._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-10-131118.jpg",alt:"image-20191206175541570"}}),e._v(" "),v("p",[e._v("如图虚线所示，用户在view层进行操作，触发controller层的action，controller对model层进行修改，model层修改后，反馈到view层。这是一个单的数据流变化过程。")]),e._v(" "),v("p",[e._v("但是实际实现过程中，view层的变化是经过controller进行操作的。（比如对dom进行操作修改，如下图）")]),e._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-10-131124.jpg",alt:"image-20191206173503281"}}),e._v(" "),v("p",[e._v("所以：实际开发过程中，所有的操作都是controller层在执行。")]),e._v(" "),v("p",[v("strong",[e._v("MVP模式")])]),e._v(" "),v("img",{staticStyle:{zoom:"60%"},attrs:{src:"https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-10-125941.png",alt:"img"}}),e._v(" "),v("p",[e._v("那么为了将数据划分的更清晰，索性就出现了mvp架构。将view和model层之间的联系彻底切断。")]),e._v(" "),v("p",[e._v("presenter负责准备展示view的数据；")]),e._v(" "),v("p",[e._v("view层所有的逻辑都通过presenter进行操作；")]),e._v(" "),v("p",[e._v("view和presenter强耦合，presenter对model进行操作；")]),e._v(" "),v("p",[e._v("这种模式带来的一个问题是：每新增一个view层就必须新增一个presenter层。")]),e._v(" "),v("p",[e._v("view层和presenter层强关联，不好拆分，也不好复用。")]),e._v(" "),v("p",[v("strong",[e._v("MVVM模式")])]),e._v(" "),v("p",[e._v("mvvm用vm替代了presenter。不仅仅是名字上的替代，viewmodel也在presenter的基础上丰富了一些概念。")]),e._v(" "),v("p",[e._v("两者都会有一些业务逻辑的处理，起到了controller的作用。但是viewmodel强调的是和view的双向绑定，是对model层的数据封装处理。")]),e._v(" "),v("p",[e._v("presenter更像是一个中间代理者，用来分发view的事件、处理view需要的model数据结果。")]),e._v(" "),v("h2",{attrs:{id:"mvvm双向绑定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mvvm双向绑定"}},[e._v("#")]),e._v(" MVVM双向绑定")]),e._v(" "),v("h3",{attrs:{id:"双向绑定原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#双向绑定原理"}},[e._v("#")]),e._v(" 双向绑定原理")]),e._v(" "),v("blockquote",[v("p",[e._v("Angular脏检测")])]),e._v(" "),v("p",[e._v("通过zone来实现，做一个了解。实际没有看过，也没有用过。")]),e._v(" "),v("h2",{attrs:{id:"生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[e._v("#")]),e._v(" 生命周期")]),e._v(" "),v("p",[e._v("vue的组件的声明周期：")]),e._v(" "),v("div",{staticClass:"language-mermaid extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("graph TD\nbeforeCreate --\x3e created\ncreated --\x3e beforeMount\nbeforeMount --\x3e mounted\nmounted --\x3e beforeUpdate\nbeforeUpdate --\x3e updated\nupdated --\x3e mounted\nmounted --\x3e beforeDestroy\nbeforeDestroy --\x3e destroyed\n")])])]),v("h2",{attrs:{id:"vue的父组件和子组件生命周期钩子执行顺序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue的父组件和子组件生命周期钩子执行顺序"}},[e._v("#")]),e._v(" Vue的父组件和子组件生命周期钩子执行顺序")]),e._v(" "),v("h3",{attrs:{id:"挂载流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#挂载流程"}},[e._v("#")]),e._v(" 挂载流程")]),e._v(" "),v("p",[v("code",[e._v("父组件created")]),e._v(" -> "),v("code",[e._v("父组件beforeCreated")]),e._v(" -> "),v("code",[e._v("父组件beforeMount")]),e._v(" -> "),v("code",[e._v("子组件created")]),e._v(" -> "),v("code",[e._v("子组件beforeCreated")])]),e._v(" "),v("p",[e._v("-> "),v("code",[e._v("子组件beforeMount")]),e._v(" -> "),v("code",[e._v("子组件mounted")]),e._v(" -> "),v("code",[e._v("父组件mounted")])]),e._v(" "),v("p",[e._v("因为vue的组件渲染经历了3个过程，都是通过递归的形式来的。")]),e._v(" "),v("p",[e._v("createComponent -> create vnode -> patch vnode -> 子组件初始化 -> 子组件render  -> 子组件patch")]),e._v(" "),v("p",[e._v("先创建父组件，然后在patch的时候，去初始化子组件，子组件渲染patch之后，才会去渲染父组件")]),e._v(" "),v("h2",{attrs:{id:"数据绑定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据绑定"}},[e._v("#")]),e._v(" 数据绑定")]),e._v(" "),v("h2",{attrs:{id:"virtual-dom"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom"}},[e._v("#")]),e._v(" Virtual Dom")]),e._v(" "),v("p",[e._v("虚拟dom其实很简单，就是用js来模拟DOM对象的结构。将这些对象存放在内存中。")]),e._v(" "),v("p",[e._v("虚拟dom出现的原因：因为dom的操作很昂贵，浏览器的dom对象上有很多属性、很多事件。通过浏览器去修改dom，会造成页面的卡顿。")]),e._v(" "),v("p",[e._v("虚拟dom的原理：通过js来模拟基础的属性，只需要绑定属性、child、事件等。其他的都可以不用去关心。")]),e._v(" "),v("p",[e._v("虚拟dom的核心API")]),e._v(" "),v("p",[e._v("diff算法：")]),e._v(" "),v("h2",{attrs:{id:"vue为什么不能用index作为key？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue为什么不能用index作为key？"}},[e._v("#")]),e._v(" Vue为什么不能用index作为key？")]),e._v(" "),v("p",[e._v("https://juejin.im/post/5e8694b75188257372503722?utm_source=gold_browser_extension#heading-10")]),e._v(" "),v("p",[e._v("针对于列表形式的组件，如果用index作为key，会导致两种情况的问题。")]),e._v(" "),v("p",[e._v("第一种：数据发生顺序上的变化，比如说，只是进行了数组的reverse。那么原本vue可以直接复用dom，只是改变一下顺序即可。但是因为key没有变化，导致vue做diff判断时，认为是子组件的props发生变化，所以进行了 patch-> render等一系列的变化操作。造成了性能损耗。")]),e._v(" "),v("p",[e._v("第二种：如果是删除了某一个数据。比如说，对数组进行了splice(0, 1)的操作。那么vue在diff比较时，同样因为key没有变化，所以复用了0~n-1的子组件。但是，再对props进行比较的时候，发现props都变化了，就对所有的子item组件进行了更新。 ==实际上，我们知道，vue只需要删除第0个子item就可以了。==")]),e._v(" "),v("p",[e._v("以上，就是用index作为key带来的副作用。")])])}),[],!1,null,null,null);t.default=a.exports}}]);