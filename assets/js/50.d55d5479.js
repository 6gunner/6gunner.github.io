(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{410:function(e,s,t){"use strict";t.r(s);var a=t(25),r=Object(a.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_1-uglify-压缩报错问题及-es5-imcompatible-versions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-uglify-压缩报错问题及-es5-imcompatible-versions"}},[e._v("#")]),e._v(" 1. uglify 压缩报错问题及 es5-imcompatible-versions")]),e._v(" "),t("h2",{attrs:{id:"缘起"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缘起"}},[e._v("#")]),e._v(" 缘起")]),e._v(" "),t("p",[e._v("由于维护 roadhog 和 umi，收到构建方面的问题反馈比较多，其中一个常见的是打包时 uglify 压缩的问题。类似下面的报错都是这个引起的，")]),e._v(" "),t("div",{staticClass:"language-text extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Failed to minify the bundle. Error: 0.0f3f4c41.async.js from UglifyJs\n\nxx.async.js from UglifyJs Unexpected token: keyword (const)\n\n0.570d21b1.async.js from UglifyJs\nUnexpected token: punc ()) [0.570d21b1.async.js:13245,19]\n\nxx.async.js from UglifyJs Unexpected token: operator (>)\n")])])]),t("p",[e._v("为啥会有这个问题？")]),e._v(" "),t("p",[e._v("通常 webpack 在构建时，是不会让 node_modules 下的文件走 babel tranpile 的，一是会慢很多，二是 babel@6 时编译编译过的代码会不安全（据说 babel@7 下没问题了），所以业界有个潜在的约定，npm 包发布前需要先用 babel 转出一份 es5 的代码。")]),e._v(" "),t("p",[e._v("但是有些 npm 包不遵守这个约定，没有转成 es5 就发上去，比如 "),t("a",{attrs:{href:"https://link.zhihu.com/?target=https%3A//github.com/sindresorhus/query-string/blob/597f14a/index.js%23L8%3A31",target:"_blank",rel:"noopener noreferrer"}},[e._v("query-string@6"),t("OutboundLink")],1),e._v("。然后压缩工具 uglify 又只支持 es5 的语法，遇到 "),t("code",[e._v("const")]),e._v("、"),t("code",[e._v("let")]),e._v("、"),t("code",[e._v("()=>")]),e._v(" 类似的语法，就抛错了。")]),e._v(" "),t("h2",{attrs:{id:"解决"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决"}},[e._v("#")]),e._v(" 解决")]),e._v(" "),t("p",[e._v("有多个解决方法，但各有利弊。")]),e._v(" "),t("h2",{attrs:{id:"使用-uglify-es-进行压缩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-uglify-es-进行压缩"}},[e._v("#")]),e._v(" 使用 uglify-es 进行压缩")]),e._v(" "),t("p",[e._v("uglify-es 支持 es6 语法，所以不会报错。但问题是如果你需要在 IE11 及以下，或者其他的低版本浏览器里跑时，就会报错、白屏了。")]),e._v(" "),t("h2",{attrs:{id:"让-babel-编译-node-modules-下的文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#让-babel-编译-node-modules-下的文件"}},[e._v("#")]),e._v(" 让 babel 编译 node_modules 下的文件")]),e._v(" "),t("p",[e._v("由于 babel@7 可以保证编译编译过的代码不会出问题，这不失为一个好的解决方案，比如 create-react-app 会在下个版本考虑用这个方案，参考 facebook/create-react-app#3776。问题是会让本来就比较慢的 dev、build 流程雪上加霜。")]),e._v(" "),t("h2",{attrs:{id:"babel-engine-plugin"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#babel-engine-plugin"}},[e._v("#")]),e._v(" babel-engine-plugin")]),e._v(" "),t("p",[e._v("跟进 npm 包的 engine 配置做按需编译。缺点是使用者比较少，如果 npm 包开发者不遵循这个规则一样会出问题。")]),e._v(" "),t("h2",{attrs:{id:"umi-roadhog-提供的-extrababelincludes-配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#umi-roadhog-提供的-extrababelincludes-配置"}},[e._v("#")]),e._v(" umi/roadhog 提供的 extraBabelIncludes 配置")]),e._v(" "),t("p",[e._v("umi/roadhog 默认也是仅用 babel 编译项目文件，但提供了额外的 extraBabelInclude 配置可以指定 node_modules 下的文件。比如：")]),e._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"extraBabelIncludes:"')]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"node_modules/a"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"node_modules/b"')]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),t("p",[e._v("问题是无法提前预知，都是出错了一脸那啥，翻 issue 或者提问后才知道。而且找到哪个依赖用了 es6 语法也比较麻烦。")]),e._v(" "),t("p",[e._v("所以，有没有一种能提前预知（用户无感知），并且不降低 webpack 构建速度的方案")]),e._v(" "),t("h1",{attrs:{id:"_2-使用browserhistory时不能刷新，报错：uncaught-syntaxerror-unexpected-token"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-使用browserhistory时不能刷新，报错：uncaught-syntaxerror-unexpected-token"}},[e._v("#")]),e._v(" 2.使用browserHistory时不能刷新，报错："),t("code",[e._v("Uncaught SyntaxError: Unexpected token <")])]),e._v(" "),t("h2",{attrs:{id:"缘起-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缘起-2"}},[e._v("#")]),e._v(" 缘起")]),e._v(" "),t("p",[e._v("因为dva在代理配置的路径是相对路径")]),e._v(" "),t("h2",{attrs:{id:"解决-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决-2"}},[e._v("#")]),e._v(" 解决")]),e._v(" "),t("ul",[t("li",[e._v("在index.html中修改 .js 引入路径，使用绝对地址进行引入！")])]),e._v(" "),t("p",[e._v("假如说是 host:800/first/second 那么 你的引用如果是相对路径 那么 浏览器会去请求 host:800/first/src/somefile.js 而实际你的js路径为 host:800/src/somefiile.js")]),e._v(" "),t("ul",[t("li",[e._v("打包时publicPath 使用/publicPath/, 而不是/publicPath. 否则动态js会加载不到。")])])])}),[],!1,null,null,null);s.default=r.exports}}]);