(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{423:function(e,t,a){"use strict";a.r(t);var r=a(25),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"mvvm双向绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvvm双向绑定"}},[e._v("#")]),e._v(" MVVM双向绑定")]),e._v(" "),a("h3",{attrs:{id:"双向绑定原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双向绑定原理"}},[e._v("#")]),e._v(" 双向绑定原理")]),e._v(" "),a("blockquote",[a("p",[e._v("Angular脏检测")])]),e._v(" "),a("p",[e._v("通过zone来实现，做一个了解。实际没有看过，也没有用过。")]),e._v(" "),a("h2",{attrs:{id:"生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[e._v("#")]),e._v(" 生命周期")]),e._v(" "),a("p",[e._v("vue的组件的声明周期：")]),e._v(" "),a("div",{staticClass:"language-mermaid extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("graph TD\nbeforeCreate --\x3e created\ncreated --\x3e beforeMount\nbeforeMount --\x3e mounted\nmounted --\x3e beforeUpdate\nbeforeUpdate --\x3e updated\nupdated --\x3e mounted\nmounted --\x3e beforeDestroy\nbeforeDestroy --\x3e destroyed\n")])])]),a("h2",{attrs:{id:"vue的父组件和子组件生命周期钩子执行顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue的父组件和子组件生命周期钩子执行顺序"}},[e._v("#")]),e._v(" Vue的父组件和子组件生命周期钩子执行顺序")]),e._v(" "),a("h3",{attrs:{id:"挂载流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#挂载流程"}},[e._v("#")]),e._v(" 挂载流程")]),e._v(" "),a("p",[a("code",[e._v("父组件created")]),e._v(" -> "),a("code",[e._v("父组件beforeCreated")]),e._v(" -> "),a("code",[e._v("父组件beforeMount")]),e._v(" -> "),a("code",[e._v("子组件created")]),e._v(" -> "),a("code",[e._v("子组件beforeCreated")])]),e._v(" "),a("p",[e._v("-> "),a("code",[e._v("子组件beforeMount")]),e._v(" -> "),a("code",[e._v("子组件mounted")]),e._v(" -> "),a("code",[e._v("父组件mounted")])]),e._v(" "),a("p",[e._v("因为vue的组件渲染经历了3个过程，都是通过递归的形式来的。")]),e._v(" "),a("p",[e._v("createComponent -> create vnode -> patch vnode -> 子组件初始化 -> 子组件render  -> 子组件patch")]),e._v(" "),a("p",[e._v("先创建父组件，然后在patch的时候，去初始化子组件，子组件渲染patch之后，才会去渲染父组件")]),e._v(" "),a("h2",{attrs:{id:"数据绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据绑定"}},[e._v("#")]),e._v(" 数据绑定")]),e._v(" "),a("h2",{attrs:{id:"virtual-dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom"}},[e._v("#")]),e._v(" Virtual Dom")]),e._v(" "),a("p",[e._v("虚拟dom其实很简单，就是用js来模拟DOM对象的结构。将这些对象存放在内存中。")]),e._v(" "),a("p",[e._v("虚拟dom出现的原因：因为dom的操作很昂贵，浏览器的dom对象上有很多属性、很多事件。通过浏览器去修改dom，会造成页面的卡顿。")]),e._v(" "),a("p",[e._v("虚拟dom的原理：通过js来模拟基础的属性，只需要绑定属性、child、事件等。其他的都可以不用去关心。")]),e._v(" "),a("p",[e._v("虚拟dom的核心API")]),e._v(" "),a("p",[e._v("diff算法：")]),e._v(" "),a("h2",{attrs:{id:"vue为什么不能用index作为key？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue为什么不能用index作为key？"}},[e._v("#")]),e._v(" Vue为什么不能用index作为key？")]),e._v(" "),a("p",[e._v("https://juejin.im/post/5e8694b75188257372503722?utm_source=gold_browser_extension#heading-10")]),e._v(" "),a("p",[e._v("针对于列表形式的组件，如果用index作为key，会导致两种情况的问题。")]),e._v(" "),a("p",[e._v("第一种：数据发生顺序上的变化，比如说，只是进行了数组的reverse。那么原本vue可以直接复用dom，只是改变一下顺序即可。但是因为key没有变化，导致vue做diff判断时，认为是子组件的props发生变化，所以进行了 patch-> render等一系列的变化操作。造成了性能损耗。")]),e._v(" "),a("p",[e._v("第二种：如果是删除了某一个数据。比如说，对数组进行了splice(0, 1)的操作。那么vue在diff比较时，同样因为key没有变化，所以复用了0~n-1的子组件。但是，再对props进行比较的时候，发现props都变化了，就对所有的子item组件进行了更新。 ==实际上，我们知道，vue只需要删除第0个子item就可以了。==")]),e._v(" "),a("p",[e._v("以上，就是用index作为key带来的副作用。")])])}),[],!1,null,null,null);t.default=v.exports}}]);