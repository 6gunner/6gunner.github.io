(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{444:function(v,e,_){"use strict";_.r(e);var t=_(25),p=Object(t.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"架构理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#架构理解"}},[v._v("#")]),v._v(" 架构理解")]),v._v(" "),_("h2",{attrs:{id:"对前后端分离的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对前后端分离的理解"}},[v._v("#")]),v._v(" 对前后端分离的理解")]),v._v(" "),_("p",[v._v("这个前后端的体会比较深刻，让我好好想想。自身体会-提示开发效率-组件化设计-架构设计-")]),v._v(" "),_("p",[v._v("大概2010年的时候，那时候还是java开发工程师。那时候做开发都是一个系统的某一个模块的功能。会先设计数据库、设计接口、设计返回的数据结构。然后再设计jsp页面，将controller里面的data通过jsp的里内置的session或者request对象，渲染到页面里。所以那时候前端和后端大部分都是由一个人去完成，使用的也都是模板语言，会一些css和jquery操作。代码都耦合在一起。")]),v._v(" "),_("p",[v._v("那时候前后端开发其实效率很低，而且后端开发一般都不会写样式，都是东拼西凑，复制黏贴别人的样式代码。")]),v._v(" "),_("p",[v._v("记得那时候bootstrap、jquery-ui的代码用的很多。")]),v._v(" "),_("p",[v._v("后来前端的一些mvc框架组件出现了，比如backbone。")]),v._v(" "),_("p",[v._v("这个时候逐渐有了一些前后端分离的影子，后台通过@ApplicationData（具体忘了）的注解，返回json数据，前端就通过ajax异步请求，去加载数据，处理逻辑。那时候前端还不能叫工程话，但是有了模块化开发的概念。单页面应用、不用每次刷新页面。再加上用到了一些requirejs，有了cmd、amd的模块化开发规范。")]),v._v(" "),_("p",[v._v("部署也可以单独通过nginx进行配置，不用依赖后端。所以前后端就算是真正可以分开了。")]),v._v(" "),_("p",[v._v("这个时间段，nodejs的崛起，再加上组件化开发的概念逐渐形成。前端的开发者提供了很多通用的组件，提升了代码的复用性，很多人开始重复造轮子，发布组件到npm上。")]),v._v(" "),_("p",[v._v("再后来，前端框架崛起，更加让前后端分离成为了一个潮流，甚至说不前后端分离都不知道怎么写代码了。最开始angular，然后有了vue、react。最开始了解下angular的用法，但是没理解里面的概念，再加上变化特别快，就没入坑。真正用起来的是vue框架，那时候觉得vue的概念特别好理解，template + script + css。这就是一个模块、就可以是一个组件。每一个页面都是模块，通用的组件可以单独封装定义复用。")]),v._v(" "),_("p",[v._v("最后还有一个很关键的东西，webpack。webpack让组件化更加容易。在开发的时候，可以提供dev-server，可以结合mock来提供数据。打包的时候，能根据模块的依赖关系，为我们将需要的代码一起打包，通过loader进行编译，plugins进行打包过程中各种声明周期环节的代码处理等等。")]),v._v(" "),_("p",[v._v("使得前后端完全就是两个独立的东西。")]),v._v(" "),_("p",[v._v("前后端分离的好处")]),v._v(" "),_("p",[v._v("第一：可以讲后台、前端的开发任务完全独立开，各尽其职。符合程序设计里面的，专一原则。就是一个模块只处理自己的某一块功能，不耦合。")]),v._v(" "),_("p",[v._v("第二：刚才也说到，解耦。后台只需要提供接口数据即可，其他的时间就可以去提示系统的性能，比如并发处理能力、每s种吞吐量。提升负载能力等等。前端可以根据接口去自己实现各式各样的页面。比如web端、h5、app等。")]),v._v(" "),_("p",[v._v("第三：前后端可以独立发布。")]),v._v(" "),_("p",[v._v("第四：提升开发效率，尤其是一个系统刚刚设计的时候。")]),v._v(" "),_("p",[v._v("怎么实施？")]),v._v(" "),_("p",[v._v("设计 ：后台去设计系统的框架，比如数据库、中间件、缓存架构。考虑容量、性能可扩展性。")]),v._v(" "),_("p",[v._v("​\t\t\t前端就去设计UI、根据设计页面的组件，设想需要的数据格式，需要哪些接口。和后端去定义好。")]),v._v(" "),_("p",[v._v("开发：前后端各自去按照接口定义去开发，前端可以按照mock数据去开发页面，实现无后台的路由跳转、交互。")]),v._v(" "),_("p",[v._v("​\t\t后端也只需要提供规定的接口数据即可。")]),v._v(" "),_("p",[v._v("测试：")]),v._v(" "),_("p",[v._v("​\t前端就测试页面实现UI、交互、传参、页面跳转呀等等。")]),v._v(" "),_("p",[v._v("​\t后端就保证接口的正确性，测试一些异常情况是否能抛出错误，验证用户的权限这些。")]),v._v(" "),_("p",[v._v("部署：")]),v._v(" "),_("p",[v._v("​\t前后端独立部署，只要不出现很大的接口变化，可以单独发布。")]),v._v(" "),_("h2",{attrs:{id:"对mvc以及mvvm的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对mvc以及mvvm的理解"}},[v._v("#")]),v._v(" 对MVC以及MVVM的理解")]),v._v(" "),_("p",[_("strong",[v._v("传统的MVC模式")])]),v._v(" "),_("p",[v._v("我理解的mvc是一种使用在10年前的软件架构分层思想上。那时候做JSP（java web）开发，理解的特别深刻。Model可以理解为数据库，也可以理解为后台服务传输给前端的pojo对象。")]),v._v(" "),_("p",[v._v("Controller就是前端和后端交互时使用的action")]),v._v(" "),_("p",[v._v("View就是前端页面。")]),v._v(" "),_("p",[v._v("用户通过通过view层，提交请求，然后由controller处理后，存储并且返回新的model，反馈给view层。")]),v._v(" "),_("p",[v._v("这时候还是单向的数据流")]),v._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-07-18-081832.jpg",alt:"img"}}),v._v(" "),_("p",[v._v("但是后来随着框架的演变，前后端的分离，mvc的思想变得难以理解，mvc的分层变得越来越模糊。")]),v._v(" "),_("p",[v._v("比如，前端的表单数据，用户可以直接修改，也可以通过controller的来提交修改状态。这样，model既和view来关联，又和controller来关联。")]),v._v(" "),_("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-10-131124.jpg",alt:"image-20191206173503281"}}),v._v(" "),_("p",[v._v("然后controller又可以通过操作dom来控制view，view也会根据model来控制展示。")]),v._v(" "),_("p",[v._v("整个mvc的联系就变成了双向的。")]),v._v(" "),_("p",[v._v("为了解决，或者说更好的设计出一个软件分层，就出现了mvvm的架构思想。")]),v._v(" "),_("p",[_("strong",[v._v("MVP模式")])]),v._v(" "),_("img",{staticStyle:{zoom:"60%"},attrs:{src:"https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-10-125941.png",alt:"img"}}),v._v(" "),_("p",[v._v("那么为了将数据划分的更清晰，索性就出现了mvp架构。将view和model层之间的联系彻底切断。")]),v._v(" "),_("p",[v._v("presenter负责准备展示view的数据；")]),v._v(" "),_("p",[v._v("view层所有的逻辑都通过presenter进行操作；")]),v._v(" "),_("p",[v._v("view和presenter强耦合，presenter对model进行操作，presenter来控制view的更新。")]),v._v(" "),_("p",[v._v("==但是这种模式带来的一个问题是：每新增一个view层就必须新增一个presenter层。==")]),v._v(" "),_("p",[v._v("view层和presenter层强关联，不好拆分，也不好复用。")]),v._v(" "),_("p",[_("strong",[v._v("MVVM")])]),v._v(" "),_("p",[v._v("mvvm的核心理念是：将vm层和view层进行双向绑定，vm对于model也做了一层转化，然后提供给view进行展示。但是vm和v的关系不是callback，vm可以随时复用，而view可以根据需要，替换不同的模板或者样式。")]),v._v(" "),_("p",[_("strong",[v._v("mvvm和mvp的区别")])]),v._v(" "),_("p",[v._v("mvvm用vm替代了presenter。不仅仅是名字上的替代，viewmodel也在presenter的基础上丰富了一些概念。")]),v._v(" "),_("p",[v._v("两者都会有一些业务逻辑的处理，起到了controller的作用。")]),v._v(" "),_("p",[v._v("但是viewmodel强调的是和view的双向绑定，model的变化，会同步到view上进行反馈。")]),v._v(" "),_("p",[v._v("presenter更像是一个中间代理者，主要是通过callback回调来进行联系。用来分发view的事件、处理view需要的model数据结果。")])])}),[],!1,null,null,null);e.default=p.exports}}]);