## 前端工作总结

## 大纲



## [框架整理沉淀](./前端工作总结-框架沉淀)



## [架构理解](./前端工作总结-架构理解)



## [解决方案](./前端工作总结-解决方案)



## 新技术学习



### React学习

#### 异常问题排查1

> #### 堆栈信息：

<img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-02-113014.png" alt="image-20200102193014405" style="zoom: 50%;" />



> #### 排查过程：



> #### 定位：

![image-20200102192921583](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-02-112922.png)



> #### 解决方案：

⚠️Only one input can be used within a FormControl.

因为FormControl里面只能有一个输入组件，所以进行了调整；

![image-20200102203141716](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-02-123141.png)



看源码，涉及到[Hooks](#React.Hook)



FormControl代码

![image-20200102210426794](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-02-130426.png)

Input代码

![image-20200102210545652](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-02-130546.png)

![image-20200102210616866](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-02-130617.png)

### Hook

> #### useState

`initialState` 参数是初始渲染期间使用的状态。 在随后的渲染中，它会被忽略了。 如果初始状态是高开销的计算结果，则可以改为提供函数，该函数仅在初始渲染时执行：

```
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
```



> useCallback

> useMemoize

返回一个缓存了结果的函数；





### Next.js学习

> 一种服务端渲染的框架；功能比较简单，配置也很简单，不需要依赖别的服务。
>
> 内部应该整合了webpack和babel，可以支持热部署，以及es6



unzip

```javascript
function unzip(b64Data){
    var strData = atob(b64Data);
    // Convert binary string to character-number array
    var charData  = strData.split('').map(function(x){return x.charCodeAt(0);});
    // Turn number array into byte-array
    var binData   = new Uint8Array(charData);
    // // unzip
    var data    = pako.inflate(binData);
    // However, the Uint8Array has a limit of buffer size. It will crashes on big buffers, the rude max size is 246300 and sometimes it not correct in different browser.
    // Convert gunzipped byteArray back to ascii string:
  //	下面这个方法会报超过最大调用次数，造成堆溢出。
    // strData   = String.fromCharCode.apply(null, new Uint16Array(data));
    strData = new TextDecoder("utf-8").decode(data);
    return strData;
}
```

zip



### [Webpack学习](./Webpack)



### [Dva学习](./Dva)



### Yarn学习

yarn的好处在于，他不仅可以和npm一样对package进行管理，而且可以保证在不同环境上，项目里所用到的依赖都是一致的。 

这依赖于yarn.lock这个文件，它应该被提交到git上进行版本控制。

除此之外，yarn还增加了一些缓存的功能，可以比npm更稳定，下载速度更快；

> ### 依赖版本



> ### 依赖类型

除了常见的devDependencies、dependencies之外，今天了解到了一些其他类型的依赖：

**`peerDependencies`**

这是“上级依赖”，一种特殊的依赖，在发布包的时候需要。有这种依赖意味着安装此包的用户也需要和包同样的依赖。 

**`optionalDependencies`**

可选依赖。即使安装失败，yarn也会认为整个过程是成功的；

**`bundledDependencies`**

"打包依赖"。打包的时候，会将这里的依赖项一起打包进来。

例如：

```
"name": "awesome-web-framework",
"version": "1.0.0",
"bundledDependencies": [
    'renderized', 'super-streams'
   ]
```

`npm pack`会将`renderized `和`super-streams`放入生成的包**awesome-web-framework-1.0.0.tgz**中，并且在`npm install awesome-web-framework-1.0.0.tgz`时，`renderized `和`super-streams`也会被一同安装。



### [WebWorker学习](./WebWorker)



### 单元测试学习

mocha

http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html

```
"test": "mocha test/*.test.js"
```







