# 解决方案

## 1.前端可配置化logo的设计方案

> 这个方案是在工作当中运用到的最小化、最简易版的设计方案

### 需求背景

给公司做了一个基于sass服务的运营——管理端界面。因为是给客户使用的，有一些客户希望能用自己的公司的logo、海报背景等等。相当于个性化定制。

所以需要把一些配置提炼出来，作为可配置化的功能。



### 解决方案

> 一、方案思路

首先定义一个配置文件，可以是.json的后缀，也可以是.js的后缀。配置的内容主要就是需要配置的各种logo、title等信息。

通过后台的相关接口，知道引入哪一个配置文件。

根据接口，引入这个配置文件，可以是通过ajax来请求这个json，又或者是动态import这个js文件，取决于你的文件格式。



> 二、关键代码

**配置文件格式**

```json
{
  "default": {
    "loginBg": "/static/img/default/login-bg.png",
    "footerLogo": "/static/img/default/footer-logo.png",
    "logo": "/static/img/default/logo.png",
    "welcome": "/static/img/default/welcome-bg.png",
    "favicon": "/static/img/default/favicon.ico"
  }
}

```

这里就简单举个例子，“default”就是配置的唯一id，不同的配置会分配一个id给他。

default下面的key就是配置项。



**设置为全局变量**

```html
 <% if (process.env.NODE_ENV === 'production') { %>
      window.__config = {
        #if ($third_type)
          thirdType: '<%= "$!third_type" %>',
        #else
          thirdType: 'default',
        #end
        #if ($title)
          title: '<%= "$!title" %>',
        #else
          title: '管理平台',
        #end
      }
   <% } %>
```

这里其实用到了模板语言，` <% if (process.env.NODE_ENV === 'production') { %>`是ejs的语法。node打包编译完成后，需要将它放到服务端，从服务端直接那边返回页面。

这段话的意思是，从服务端渲染的时候，读取third_type的变量信息，然后直接设置为全局window.__config.thirdType这个变量。 这个变量的意思就是具体需要用到哪个配置文件的意思。



**view使用**

先读取配置信息

```js
import images from '../assets/img/images.json';
// 中间省略
...
// vue的data对象
data() {
  return {
		images: images[window.__config.thirdType]
  }
}
```

再在用到的地方，使用data变量来替换。

```jsx
 <a href="#" class="header-logo">
  用到图片的地方
  <img :src="images.logo" class="header-logo-img">
 </a>
```



> 三、方案的优缺点

**优点**：

1. 最小化的解决了个性化配置的问题。只需要后台配合域名或者机构号，来设置好thirdType参数，再返回给前端即可。
2. 从页面渲染加载时，就可以确认thirdType，不会出现闪屏的问题；

**缺点**：

1. 配置不灵活，需要手动写配置文件，而且替换图片也需要开发人员进行打包升级，不能做到立即生效；



> 四、待改进点

1. 因为我们产品以及后台都没有规划好这块的功能设计，所以其实最大的改进就是将这些配置本身就做成功能。
2. 其次，import json文件，实际上会把json代码打包到整个代码里面去，导致文件臃肿。最好是从服务端加载。
3. 图片都是本地图片，最好也可以从远端读取图片，减少打包的大小；







# 框架沉淀

## Vue全家桶

###第一版本 

> 时间：2019.7.21日

- 加入了axios以及一些常用的拦截器。拦截器业务根据实际项目业务来写；

- 加入router和store。一般项目都会用到
- 加了组件的懒加载

其他组件根据后面需要再考虑加入。





## Next.js

> 一种服务端渲染的框架；功能比较简单，配置也很简单，不需要依赖别的服务。
>
> 内部应该整合了webpack和babel，可以支持热部署，以及es6



unzip

```javascript
function unzip(b64Data){
    var strData = atob(b64Data);
    // Convert binary string to character-number array
    var charData  = strData.split('').map(function(x){return x.charCodeAt(0);});
    // Turn number array into byte-array
    var binData   = new Uint8Array(charData);
    // // unzip
    var data    = pako.inflate(binData);
    // However, the Uint8Array has a limit of buffer size. It will crashes on big buffers, the rude max size is 246300 and sometimes it not correct in different browser.
    // Convert gunzipped byteArray back to ascii string:
  //	下面这个方法会报超过最大调用次数，造成堆溢出。
    // strData   = String.fromCharCode.apply(null, new Uint16Array(data));
    strData = new TextDecoder("utf-8").decode(data);
    return strData;
}
```

zip







## Webpack

>  webpack是一个模块打包工具

Webpack 配置文件：webpack.config.js



### loader

> loader的作用

webpack无法处理.js后缀之外的文件，所以需要loader来进行处理文件。



> loader的配置



> #### file-loader vs url-loader

url-loader可以把图片打包到js文件里去，以base64的格式来存放。

file-loader是把图片独立打包出来，形成静态资源。当然file-loader还可以处理字体otf、svg等后缀的静态资源。

```js
module: {
        rules: [{
            test: /\.(png|jpe?g)$/i,
            use: [{
                loader: 'url-loader',
                options: {
                    // 10kb;
                    limit: 10240,
                    name: '[name].[ext]?[contenthash]',
                }
            }]
        }, /*{
            test: /\.(png|jpe?g)$/i,
            use: [{
                loader: 'file-loader',
                options: {
                    name: '[name].[ext]?[contenthash]',
                    publicPath: '/some/path/',
                    outputPath: '/some/path/',
                    postTransformPublicPath: (p) => `__webpack_public_path__ + ${p}`,
                }
            }]
        }*/]
    }
```

url-loader有一个==limit==的options可以配置。当图片超过了limit的大小，就不会将图片转化为base64, 默认会使用file-loader进行处理。但是这里有一个容易进入的误区：我之前以为需要配置再配置一个file-loader，让url-loader去执行file-loader的配置。实际上不需要再单独配置一个file-loader，url-loader自带了file-loader各个配置。



> ### 加载样式

- style-loader
- css-loader
- 



> 基础配置

首先，假如项目里用到了最简单的css，需要配置成如下：

```

```



为什么需要这么多loader连起来用？



> 预处理配置



> 样式模块化

模块化的概念其实就是：各个页面组件里的样式作用域只会在当前模块里起作用，而不会影响到全局样式。这样写样式时就可以放心定义类名。

模块化配置首先要在webpack.config.js里配置好`modules: true`

```js
{
  test: /\.(css)$/i,
  use: [
  	'style-loader',
    {
      loader: 'css-loader',
      options: {
      modules: true,
    }
  ]
}
```

其次，引入样式时，需要将样式import为一个对象，然后去使用这个的属性。

```js
// import './index.css';
import style from './index.css';

const img1 = appendImg(imgPath1);
img1.classList.add(style.avatar);
```

可以理解为，如果是模块化，webpack会将样式处理为一个js对象，然后在页面是使用样式就是使用对象的某一个属性。



### devServer

> #### proxy代理配置

```
devServer: {
    proxy: {
      '/api': 'http://localhost:3000'
    }
  }
```

`/api/users`会被代理到`http://localhost:3000/api/users`

> ##### 如果想要重写路径

```
devServer: {
  proxy: {
    '/api': {
    target: 'http://localhost:3000',
  	pathRewrite: {'^/api' : ''}
  	}
	}
}
```

`/api/users`会被代理到`http://localhost:3000/users`

> 如果不是所有都代理，可以传一个function

- 返回null或者undefined会继续通过代理
- 返回false会直接404
- 返回一个路径，会当做`express server`来直接返回.



> ##### 踩坑：405错误

![image-20191227140841502](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-27-060842.png)



proxy配置的优先级默认是从上往下的，只要上面的proxy匹配上了请求规则，就不会继续向下找了。即使下面的匹配更完全。

<img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-27-230628.png" alt="image-20191228070627938" style="zoom:30%;" />

图1出现的问题就是因为我们把配置写成了123的顺序。导致/ajax/api的请求全部代理到了www。改成321的顺序即可。









# 单元测试小结





# JavaScript事件循环模型

事件循环里 

主线程处理代码，判断是否是同步任务，同步任务会进入执行堆栈，异步任务把回调函数进入执行队列中



执行堆栈的任务结束后，判断队列中是否有任务，如果有，就将异步任务加入到执行队列中进行处理。



异步任务也有task 和 Microtask





# Nginx配置

## 踩坑1：mac配置后403

> 产生背景

mac配置完nginx后，明明路径都是正确的，但是还是无法打开页面，日志报403错误；

> 问题现象

```verilog
2019/12/24 21:24:34 [error] 80457#0: *1 open() "/Users/keyang/Workspace/temp/build/manifest.json" failed (13: Permission denied), client: 127.0.0.1, server: www.asproex.com
```

> 问题原因

没有权限，但是没有权限的原因有很多：

可能是nginx启动用户不对；

也可能是用户无法访问目录，需要配置权限 777；

> 问题解决

我这里解决方案就是去设置了777的目录权限（包括根目录）；

比如我访问的目录是：`/Users/keyang/Workspace/temp/build`

那么需要`drwxrwxrwx   5 keyang  staff   160B 12 24 21:56 temp`这个目录就开始配置权限；





## 踩坑2：保留nginx目录

如果有多级路径的话，文件目录也要有多级；

比如我想把浏览器路径配置为：`http://xxx.domain.com/activity/ieo `

nginx配置需要是：

```nginx
location ^~ /activity/ieo {
  root /Users/keyang/Workspace/temp/build/;
  index index.html;
}

// 然后build这个目录里面还需要有子目录，最终的结构是：
/Users/keyang/Workspace/temp/build/activity/ieo
            
```









# 框架原理

## MVVM双向绑定

> https://mp.weixin.qq.com/s/MCuryUvco5_86HsMmVa21

### MVC模式

<img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9n5jvljkoj30ju09oab6.jpg" alt="image-20191206175541570" style="zoom:50%;" />

第`3`步model返回视图实际上是 controller通过dom操作修改view；

<img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9n4yewelpj30j608rmy2.jpg" alt="image-20191206173503281" style="zoom:50%;" />

**缺点**：model的频繁变化，需要同步通知，比如通过监听事件来修改view，附带大量的dom操作，

​			用户通过controller修改model，需要同步model的状态；



### MVVM模式

mvvm用vm替代了controller，而且也改变了数据传递的方向。 view不再直接关联model，而是通过viewmodel进行传递。

![image-20191206175704691](https://tva1.sinaimg.cn/large/006tNbRwly1g9n5lbj3auj30it04474q.jpg)

view变化时，viewmodel进行



### Angular脏检测

zone的实现方式



### Vue 数据劫持

原理

​	Object.defineProperty

​	Compile

​	Wathcer

​	Dep

怎么实现一个双向数据绑定

Vue3.0做了什么优化？—— Proxy

### React单项数据流



react怎么去简化setState和事件监听的代码



Webpack流程



## 实现一个简单的webpack

> https://juejin.im/post/5de099886fb9a071562facad#heading-5
>
> 本例自己实现了简单的webpack，对es6的代码进行编译和分析，将依赖文件打包在一起，生成可执行的代码。



关键代码讲解

```js
const generateCode = (entry) => {
	const graph = JSON.stringify(makeDependenciesGraph(entry));
	// 我们来构造exports和require函数，这两个函数在浏览器里面是不存在的
	return `
    (function(graph){
      // require方法第二次传入的是'./message.js', 需要转化为'./src/message.js', 否则无法找到
     function require(module) {
        const exports = {};
        function innerRequire(relativePath) {
          // 将代码里写的相对路径转化为绝对路径后，调用外部真正的require方法
          const absolutePath = graph[module].dependencies[relativePath];
          return require(absolutePath);
        }
        // 写闭包避免变量互相影响, 传入innerRequire作为require，这样内部调用的require方法便是innerRequire
       (function(exports, require, code) {
        eval(code)
       })(exports, innerRequire, graph[module].code)
       return exports;
     }
     require('${entry}')
    })(${graph})
  `;
}
```



生成的code为：

```js
(function(graph){
	// require方法第二次传入的是'./message.js', 需要转化为'./src/message.js', 否则无法找到
	function require(module) {
		const exports = {};
		function innerRequire(relativePath) {
			// 将代码里写的相对路径转化为绝对路径后，调用外部真正的require方法
			const absolutePath = graph[module].dependencies[relativePath];
			return require(absolutePath);
		}
		// 写闭包避免变量互相影响, 传入innerRequire作为require，这样内部调用的require方法便是innerRequire
		(function(exports, require, code) {
			eval(code)
		})(exports, innerRequire, graph[module].code)
		return exports;
	}
	require('./src/index.js')
})({"./src/index.js":{"dependencies":{"./message.js":"./src/message.js"},"code":"\"use strict\";\n\nvar _message = _interopRequireDefault(require(\"./message.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nconsole.log(_message[\"default\"]);"},"./src/message.js":{"dependencies":{},"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar message = \"Mock Webpack\";\nvar _default = message;\nexports[\"default\"] = _default;"}})

```

