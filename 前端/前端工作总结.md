# 解决方案

## 1.前端可配置化logo的设计方案

> 这个方案是在工作当中运用到的最小化、最简易版的设计方案

### 需求背景

给公司做了一个基于sass服务的运营——管理端界面。因为是给客户使用的，有一些客户希望能用自己的公司的logo、海报背景等等。相当于个性化定制。

所以需要把一些配置提炼出来，作为可配置化的功能。



### 解决方案

> 一、方案思路

首先定义一个配置文件，可以是.json的后缀，也可以是.js的后缀。配置的内容主要就是需要配置的各种logo、title等信息。

通过后台的相关接口，知道引入哪一个配置文件。

根据接口，引入这个配置文件，可以是通过ajax来请求这个json，又或者是动态import这个js文件，取决于你的文件格式。



> 二、关键代码

**配置文件格式**

```json
{
  "default": {
    "loginBg": "/static/img/default/login-bg.png",
    "footerLogo": "/static/img/default/footer-logo.png",
    "logo": "/static/img/default/logo.png",
    "welcome": "/static/img/default/welcome-bg.png",
    "favicon": "/static/img/default/favicon.ico"
  }
}

```

这里就简单举个例子，“default”就是配置的唯一id，不同的配置会分配一个id给他。

default下面的key就是配置项。



**设置为全局变量**

```html
 <% if (process.env.NODE_ENV === 'production') { %>
      window.__config = {
        #if ($third_type)
          thirdType: '<%= "$!third_type" %>',
        #else
          thirdType: 'default',
        #end
        #if ($title)
          title: '<%= "$!title" %>',
        #else
          title: '管理平台',
        #end
      }
   <% } %>
```

这里其实用到了模板语言，` <% if (process.env.NODE_ENV === 'production') { %>`是ejs的语法。node打包编译完成后，需要将它放到服务端，从服务端直接那边返回页面。

这段话的意思是，从服务端渲染的时候，读取third_type的变量信息，然后直接设置为全局window.__config.thirdType这个变量。 这个变量的意思就是具体需要用到哪个配置文件的意思。



**view使用**

先读取配置信息

```js
import images from '../assets/img/images.json';
// 中间省略
...
// vue的data对象
data() {
  return {
		images: images[window.__config.thirdType]
  }
}
```

再在用到的地方，使用data变量来替换。

```jsx
 <a href="#" class="header-logo">
  用到图片的地方
  <img :src="images.logo" class="header-logo-img">
 </a>
```



> 三、方案的优缺点

**优点**：

1. 最小化的解决了个性化配置的问题。只需要后台配合域名或者机构号，来设置好thirdType参数，再返回给前端即可。
2. 从页面渲染加载时，就可以确认thirdType，不会出现闪屏的问题；

**缺点**：

1. 配置不灵活，需要手动写配置文件，而且替换图片也需要开发人员进行打包升级，不能做到立即生效；



> 四、待改进点

1. 因为我们产品以及后台都没有规划好这块的功能设计，所以其实最大的改进就是将这些配置本身就做成功能。
2. 其次，import json文件，实际上会把json代码打包到整个代码里面去，导致文件臃肿。最好是从服务端加载。
3. 图片都是本地图片，最好也可以从远端读取图片，减少打包的大小；



> 五、源码地址





## 2.nodejs进行服务的转发代理

### 需求背景





## 3.实现一个大文件上传

### 需求背景

本来是在做一个运维工具，用来测试我们对外的user api接口。由于是nodejs写的，而node对FormData的支持不是很好，所以提交文件就很麻烦。

后面衍生出了两种问题：

1、怎么用nodejs去模拟浏览器的request去上传文件

2、怎么进行大文件上传



### 解决方案

> 问题分析

首先，在http请求里，如果是普通的form表单提交，会以`application/x-www-form-urlencoded`的形式传输. 但如果是传输文件的格式,需要设置header为是`multipart/form-data`. 

来看一个文件上传的http报文：

```http
POST /file/v1/upload HTTP/1.1
Host: localhost:8081
Content-Length: 100460
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW

----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="file"; filename="v2-f7139f8763b996ebfa28486e160f6378_r.jpg"
Content-Type: image/jpeg

(data)
----WebKitFormBoundary7MA4YWxkTrZu0gW--

```

上面4行是request的headers

中间有一行空行，空行下面是FormData

可以看出来：FormData是以`----WebKitFormBoundary${random_str}`开始，以`----WebKitFormBoundary${random_str}--`结尾。并且这个值和headers里面Content-Type的boundary一致。



所以第一个问题很好解决，只需要模拟这种请求的格式，应该就能发送一个文件到服务端。

> 实现代码：

```js
const http = require('http');
const fs = require('fs');

var boundary = '001373272605314343826714';

const filePath = '/Users/keyang/Desktop/v2-f7139f8763b996ebfa28486e160f6378_r.jpg';

const options = {
	'method': 'POST',
	'hostname': 'localhost',
	'port': 61470,
	'path': '/file/v1/upload',
	'headers': {
		'Content-Type': 'multipart/form-data; boundary=------------------------WebKitFormBoundary7MA4YWxkTrZu0gW'
	}
}


const req = http.request(options, function (res) {
	var chunks = [];

	res.on("data", function (chunk) {
		chunks.push(chunk);
	});
	res.on("end", function (chunk) {
		var body = Buffer.concat(chunks);
		console.log(body.toString());
	});
	res.on("error", function (error) {
		console.error(error);
	});
});

const postData = '------------------------' + boundary + '\r\n'
	+ 'Content-Disposition:form-data; name="file"; filename="v2-f7139f8763b996ebfa28486e160f6378_r.jpg"\r\n'
	+ 'Content-Type: image/jpeg\r\n\r\n'
const endData = '\r\n------------------------' + boundary + '--\r\n';


fs.stat(filePath, (err, stats) => {
	req.setHeader('Content-Type', 'multipart/form-data; boundary=------------------------' + boundary);
	req.setHeader('Content-Length', Buffer.byteLength(postData) + Buffer.byteLength(endData) + stats.size);
	req.write(postData);
	req.write(fs.readFileSync(filePath))
	req.end(endData);
})
```





第二部分上传大文件的思路：

1.客户端分片；使用Blob.prototype.slice方法。将大文件分成小的文件，确保每个文件不会超过1048576字节的大小。

2.服务端合并：先接受客户端传输的分片文件，按顺序保存。上传完成后，利用对分片传输的文件进行合并。



分片文件的发送大致如下：

```html
POST /test.html HTTP/1.1
Host: example.org
Content-Type: multipart/form-data;boundary="boundary"

--boundary
Content-Disposition: form-data; name="chunk"; filename="blob"
Content-Type: application/octet-stream

(binary)
--boundary
Content-Disposition: form-data; name="hash"

value1
--boundary
Content-Disposition: form-data; name="filename"

value2
--boundary--
```

利用hash值来标识文件顺序，利用chunk来传输文件



![image-20200113154533606](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-13-074533.png)



> 代码实现

```java
# interview-learn
//https://juejin.im/post/5dff8a26e51d4558105420ed?utm_source=gold_browser_extension#heading-13
```









## 4.封装组件

之前在给公司做项目的时候，基于vue + element封装了一些项目的插件。

组件封装好了，但是怎么把他提取出来给小伙伴们一起使用就成了一个难题。这边经过一番研究，终于找到了一个最优的打包配置，记录一下。

> 首先看一下webpack的配置

不同于app的打包，library的打包有两个概念：`externals` 、`暴露library`

[externals](./Webpack#externals)把一些依赖不打包到bundle里，而是作为外部依赖项。

[output](./Webpack#output)用来设置打包library被引用时的，变量的引用方式。

```js
// 将library打包出去
const webpack = require("webpack");
const {CleanWebpackPlugin} = require('clean-webpack-plugin');

const vueLoaderConfig = require('./vue-loader.conf');
const path = require('path');
const version = require("./../package.json").version;

const utils = require('./utils')

module.exports = {
  // mode: 'production',
  entry: path.join(__dirname, '..', "src/index.js"),
  output: {
    path: path.join(__dirname, '..', 'dist'),
    filename: "gs-comps.js",
    library: "GsComps",
    libraryTarget: "umd",
  },
  resolve: {
    extensions: ['.js', '.vue'],
    alias: {
      '@': path.resolve('src'),
    }
  },
  externals: {
    underscore: {
      commonjs: 'underscore',
      commonjs2: 'underscore',
      amd: 'underscore',
      root: '_'
    },
    vue: 'Vue',
    vuex: 'vuex',
    'element-ui': {
      commonjs: 'element-ui',
      commonjs2: 'element-ui',
    },
    'element-ui/src/transitions/collapse-transition': 'element-ui/lib/transitions/collapse-transition',
    'element-ui/src/mixins/emitter': 'element-ui/lib/mixins/emitter',
    'element-ui/src/locale': 'element-ui/lib/locale',

  },
  module: {
    rules: [
      ...utils.styleLoaders({sourceMap: true, extract: true}),
      {
        test: /\.vue$/,
        loader: 'vue-loader',
        options: vueLoaderConfig,
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: "babel-loader",
      }
    ]
  },
  plugins: [
    new CleanWebpackPlugin(),
    new webpack.DefinePlugin({
      "process.env": {
        NODE_ENV: '"production"'
      },
      VERSION: JSON.stringify(require("../package.json").version)
    }),
    new webpack.LoaderOptionsPlugin({
      minimize: true,
      debug: false
    }),
    new webpack.optimize.UglifyJsPlugin({
      compress: {
        warnings: false
      },
      sourceMap: true,
      comments: false,
      beautify: false
    }),
  ]
};

```



> 然后看一下封装library的方式

```js
// library index.js
import EasySelect from './components/EasySelect'
import EasyTable from './components/EasyTable'
import EasyInput from './components/EasyInput'
import VirtualList from './components/VirtualList'
import VirtualTree from './components/VirtualTree'

const components = [
  EasySelect,
  EasyTable,
  EasyInput,
  VirtualList,
  VirtualTree
]

const install = function (Vue) {
  components.forEach(component => {
    Vue.component(component.name, component)
  })
}

if (typeof window !== 'undefined' && window.Vue) {
  install(window.Vue)
}

export default {
  install,
 	EasySelect,
  EasyTable,
  EasyInput,
  VirtualList,
  VirtualTree
}
```

组件的indexjs

```js
// 引入组件
import EasyTable from './EasyTable'
// 写install方法
EasyTable.install = function (Vue) {
  Vue.component(EasyTable.name, EasyTable)
}
export default EasyTable
```



> 测试过后，发布library

```js
"main": "dist/gs-comps.js" // 设置package.json的main入口，用来发布
```

```shell
npm publish
```



## 5.前端Excel导出数据功能

有一些报表的数据，客户希望通过导出成为excel的方式去查看。而这些数据都已经通过后台接口返回回来了，那么单纯的通过前端就可以进行excel导出功能。

> 使用说明

```js
// 声明导出excel的header名称
const tHeader = [this.$t('table.initDate'), this.$t('table.coName'), this.$t('table.pdName'), this.$t('table.assetAccoName'), this.$t('table.exchgroupName'), this.$t('table.exchName'), this.$t('table.currencyPair'), this.$t('table.orderDir'), this.$t('table.strikeAVGPrice'), this.$t('table.strikeQty'), this.$t('table.strikeAmount'), this.$t('table.fee')];
// 处理数据
const filterVal = ['init_date', 'co_name', 'pd_name', 'asset_acco_name', 'exch_group_name', 'exch_name', 'stock_name', 'order_dir', 'strike_aver_price', 'bs_crncy_strike_qty', 'qt_crncy_strike_qty', 'strike_fee'];
const list = this.tableData;
const data = list.map(item => filterVal.map((key) => {
  if (key === 'strike_aver_price' || key === 'bs_crncy_strike_qty' || key === 'qt_crncy_strike_qty' || key === 'strike_fee') {
    return format('number', '$0', item[key]);
  }
  if (key === 'order_dir') {
    return this.translateDict(key, item[key]);
  }
  return item[key];
}));
const currentDate = new Date();
const excelName = this.$t('table.exchgroupStrike') + currentDate.format('yyyyMMdd');
const excelSheetName = this.$t('table.exchgroupStrike');
// 交给工具方法去导出数据
export_json_to_excel(tHeader, data, excelSheetName, excelName);
```





# 框架沉淀

## Vue全家桶

源码地址：https://github.com/6gunner/vue-basic-framework/tree/master/src

###第一版本 

> 时间：2019.7.21日

- 加入了axios以及一些常用的拦截器。拦截器业务根据实际项目业务来写；
- 加入router和store。一般项目都会用到
- 加了组件的懒加载; 需要引入babel的插件



其他组件根据后面需要再考虑加入。



## React

### 异常问题排查1

> #### 堆栈信息：

![image-20200102193014405](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-02-113014.png)



> #### 排查过程：



> #### 定位：

![image-20200102192921583](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-02-112922.png)



> #### 解决方案：

⚠️Only one input can be used within a FormControl.

因为FormControl里面只能有一个输入组件，所以进行了调整；

![image-20200102203141716](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-02-123141.png)



看源码，涉及到[Hooks](#React.Hook)



FormControl代码

![image-20200102210426794](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-02-130426.png)

Input代码

![image-20200102210545652](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-02-130546.png)

![image-20200102210616866](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-02-130617.png)

### Hook

> #### useState

`initialState` 参数是初始渲染期间使用的状态。 在随后的渲染中，它会被忽略了。 如果初始状态是高开销的计算结果，则可以改为提供函数，该函数仅在初始渲染时执行：

```
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
```



> useCallback

> useMemoize

返回一个缓存了结果的函数；





## Next.js

> 一种服务端渲染的框架；功能比较简单，配置也很简单，不需要依赖别的服务。
>
> 内部应该整合了webpack和babel，可以支持热部署，以及es6



unzip

```javascript
function unzip(b64Data){
    var strData = atob(b64Data);
    // Convert binary string to character-number array
    var charData  = strData.split('').map(function(x){return x.charCodeAt(0);});
    // Turn number array into byte-array
    var binData   = new Uint8Array(charData);
    // // unzip
    var data    = pako.inflate(binData);
    // However, the Uint8Array has a limit of buffer size. It will crashes on big buffers, the rude max size is 246300 and sometimes it not correct in different browser.
    // Convert gunzipped byteArray back to ascii string:
  //	下面这个方法会报超过最大调用次数，造成堆溢出。
    // strData   = String.fromCharCode.apply(null, new Uint16Array(data));
    strData = new TextDecoder("utf-8").decode(data);
    return strData;
}
```

zip



## [Webpack](./Webpack)



### [Dva](./Dva)



## Yarn

yarn的好处在于，他不仅可以和npm一样对package进行管理，而且可以保证在不同环境上，项目里所用到的依赖都是一致的。 

这依赖于yarn.lock这个文件，它应该被提交到git上进行版本控制。

除此之外，yarn还增加了一些缓存的功能，可以比npm更稳定，下载速度更快；

> ### 依赖版本



> ### 依赖类型

除了常见的devDependencies、dependencies之外，今天了解到了一些其他类型的依赖：

**`peerDependencies`**

这是“上级依赖”，一种特殊的依赖，在发布包的时候需要。有这种依赖意味着安装此包的用户也需要和包同样的依赖。 

**`optionalDependencies`**

可选依赖。即使安装失败，yarn也会认为整个过程是成功的；

**`bundledDependencies`**

"打包依赖"。打包的时候，会将这里的依赖项一起打包进来。

例如：

```
"name": "awesome-web-framework",
"version": "1.0.0",
"bundledDependencies": [
    'renderized', 'super-streams'
   ]
```

`npm pack`会将`renderized `和`super-streams`放入生成的包**awesome-web-framework-1.0.0.tgz**中，并且在`npm install awesome-web-framework-1.0.0.tgz`时，`renderized `和`super-streams`也会被一同安装。



## [WebWorker](./WebWorker)

## 单元测试



# 底层原理

## 浏览器进程

> 浏览器进程组成

现代浏览器都是多进程的，

每新增一个tab，就会创建一个进程；

每个进程又有多个线程进行协作；



<img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-10-135142.png" alt="16f7ee19a85b3c8f" style="zoom:50%;" />



参考文章：https://juejin.im/post/5e143104e51d45414a4715f7?utm_source=gold_browser_extension#heading-32



> 浏览器渲染流程

<img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-10-231904.png" alt="16f7ee2d9a5667b3" style="zoom:67%;" />

parser解析：html解析器和css解析器并行，生成dom树和style树；

dom树结合style树生成 Render树

layout：布局器负责根据Render树去计算元素位置以及大小；

paint：绘制器根据Render树绘制页面的像素信息；

display: 最后浏览器主进程将绘制的图层交给GPU进程去渲染，GPU进程将各个图层合并（composite），最后显示页面；

引申问题：[css为什么要放在js前面去加载？](./面试题总结#为什么要把css放在head里，而js放到body后去？)







## JavaScript事件循环模型

事件循环里 

主线程处理代码，判断是否是同步任务，同步任务会进入执行堆栈，异步任务把回调函数进入执行队列中



执行堆栈的任务结束后，判断队列中是否有任务，如果有，就将异步任务加入到执行队列中进行处理。



异步任务也有task 和 Microtask





# Nginx配置

## 踩坑1：mac配置后403

> brew安装目录：/usr/local/Cellar/nginx/1.15.10

> 产生背景

mac配置完nginx后，明明路径都是正确的，但是还是无法打开页面，日志报403错误；

> 问题现象

```verilog
2019/12/24 21:24:34 [error] 80457#0: *1 open() "/Users/keyang/Workspace/temp/build/manifest.json" failed (13: Permission denied), client: 127.0.0.1, server: www.asproex.com
```

> 问题原因

没有权限，但是没有权限的原因有很多：

可能是nginx启动用户不对；

也可能是用户无法访问目录，需要配置权限 777；

> 问题解决

我这里解决方案就是去设置了777的目录权限（包括根目录）；

比如我访问的目录是：`/Users/keyang/Workspace/temp/build`

那么需要`drwxrwxrwx   5 keyang  staff   160B 12 24 21:56 temp`这个目录就开始配置权限；

```bash
sudo chomd 777 `/Users/keyang/Workspace/temp/build`
```



> 另一种思路

还有一种解决方案是设置user为启动用户

先查看nginx的启动用户 `ps aux | grep nginx`

![image-20200214170852232](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-02-14-090852.png)

然后设置nginx的配置里user对象和master一致

```diff
- #user nobody;
+ user root owner;
```





## 踩坑2：保留nginx目录

如果有多级路径的话，文件目录也要有多级；

比如我想把浏览器路径配置为：`http://xxx.domain.com/activity/ieo `

nginx配置需要是：

```nginx
location ^~ /activity/ieo {
  root /Users/keyang/Workspace/temp/build/;
  index index.html;
}

// 然后build这个目录里面还需要有子目录，最终的结构是：
/Users/keyang/Workspace/temp/build/activity/ieo
            
```



## 踩坑3：goddy ssl证书从购买到配置

公司的客户的网站证书都是从goddy上买的，然后部署到国外服务器。

由于菜的抠脚，记录以下证书的创建的过程；主要还是参考以下链接：[域名网站 SSL Nginx证书配置](https://blog.csdn.net/weixin_38109191/article/details/98479353)

步骤在博主的博客里记录的很清楚，就不再复制黏贴了。主要是几个点：

1. nginx配置需要的私钥，并不是从goddy上下载的，而是一开始通过ssl命令生成的。也就是说，ssl证书需要先在本地创建一个私钥，然后再生成一个csr文件。最后通过csr文件来生成ssl证书。
2. 创建私钥的命令有两种：

```shell
openssl req -new -newkey rsa:2048 -nodes -keyout 您的域名.key -out 您的域名.csr
```

这种可以一次性搞定；

```shell
openssl genrsa -des3 -out <name of your certificate>.key 2048
openssl req -new -key <name of your certificate>.key -out <name of your certificate>.csr
```

这种就是两步，第一步创建一个key，第二步拿上面的key创建csr；

3. 生成crt证书

```cmd
cat f84e19a2f44c6386.crt gd_bundle-g2-g1.crt >> coolexample.crt
```



学习4： resolver的含义



![image-20191231153014650](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-31-073015.png)

![image-20191231153141975](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-31-073142.png)





# 框架原理

https://cl.n2sa.xyz/htm_data/2002/7/3809942.html

## MVVM双向绑定

> https://mp.weixin.qq.com/s/MCuryUvco5_86HsMmVa21

### MVC模式

<img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9n5jvljkoj30ju09oab6.jpg" alt="image-20191206175541570" style="zoom:50%;" />

第`3`步model返回视图实际上是 controller通过dom操作修改view；

<img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9n4yewelpj30j608rmy2.jpg" alt="image-20191206173503281" style="zoom:50%;" />

**缺点**：model的频繁变化，需要同步通知，比如通过监听事件来修改view，附带大量的dom操作，

​			用户通过controller修改model，需要同步model的状态；



### MVVM模式

mvvm用vm替代了controller，而且也改变了数据传递的方向。 view不再直接关联model，而是通过viewmodel进行传递。

![image-20191206175704691](https://tva1.sinaimg.cn/large/006tNbRwly1g9n5lbj3auj30it04474q.jpg)

view变化时，viewmodel进行



### Angular脏检测

zone的实现方式



### Vue 数据劫持

原理

​	Object.defineProperty

​	Compile

​	Wathcer

​	Dep

怎么实现一个双向数据绑定

Vue3.0做了什么优化？—— Proxy

### React单项数据流



react怎么去简化setState和事件监听的代码



Webpack流程



## 实现一个简单的webpack

> https://juejin.im/post/5de099886fb9a071562facad#heading-5
>
> 本例自己实现了简单的webpack，对es6的代码进行编译和分析，将依赖文件打包在一起，生成可执行的代码。



关键代码讲解

```js
const generateCode = (entry) => {
	const graph = JSON.stringify(makeDependenciesGraph(entry));
	// 我们来构造exports和require函数，这两个函数在浏览器里面是不存在的
	return `
    (function(graph){
      // require方法第二次传入的是'./message.js', 需要转化为'./src/message.js', 否则无法找到
     function require(module) {
        const exports = {};
        function innerRequire(relativePath) {
          // 将代码里写的相对路径转化为绝对路径后，调用外部真正的require方法
          const absolutePath = graph[module].dependencies[relativePath];
          return require(absolutePath);
        }
        // 写闭包避免变量互相影响, 传入innerRequire作为require，这样内部调用的require方法便是innerRequire
       (function(exports, require, code) {
        eval(code)
       })(exports, innerRequire, graph[module].code)
       return exports;
     }
     require('${entry}')
    })(${graph})
  `;
}
```



生成的code为：

```js
(function(graph){
	// require方法第二次传入的是'./message.js', 需要转化为'./src/message.js', 否则无法找到
	function require(module) {
		const exports = {};
		function innerRequire(relativePath) {
			// 将代码里写的相对路径转化为绝对路径后，调用外部真正的require方法
			const absolutePath = graph[module].dependencies[relativePath];
			return require(absolutePath);
		}
		// 写闭包避免变量互相影响, 传入innerRequire作为require，这样内部调用的require方法便是innerRequire
		(function(exports, require, code) {
			eval(code)
		})(exports, innerRequire, graph[module].code)
		return exports;
	}
	require('./src/index.js')
})({"./src/index.js":{"dependencies":{"./message.js":"./src/message.js"},"code":"\"use strict\";\n\nvar _message = _interopRequireDefault(require(\"./message.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nconsole.log(_message[\"default\"]);"},"./src/message.js":{"dependencies":{},"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar message = \"Mock Webpack\";\nvar _default = message;\nexports[\"default\"] = _default;"}})

```

