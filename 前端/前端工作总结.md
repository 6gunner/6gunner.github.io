# 对前后端分离的理解

这个前后端的体会比较深刻，让我好好想想。自身体会-提示开发效率-组件化设计-架构设计-

大概2010年的时候，那时候还是java开发工程师。那时候做开发都是一个系统的某一个模块的功能。会先设计数据库、设计接口、设计返回的数据结构。然后再设计jsp页面，将controller里面的data通过jsp的里内置的session或者request对象，渲染到页面里。所以那时候前端和后端大部分都是由一个人去完成，使用的也都是模板语言，会一些css和jquery操作。代码都耦合在一起。

那时候前后端开发其实效率很低，而且后端开发一般都不会写样式，都是东拼西凑，复制黏贴别人的样式代码。

记得那时候bootstrap、jquery-ui的代码用的很多。

后来前端的一些mvc框架组件出现了，比如backbone。

这个时候逐渐有了一些前后端分离的影子，后台通过@ApplicationData（具体忘了）的注解，返回json数据，前端就通过ajax异步请求，去加载数据，处理逻辑。那时候前端还不能叫工程话，但是有了模块化开发的概念。单页面应用、不用每次刷新页面。再加上用到了一些requirejs，有了cmd、amd的模块化开发规范。

部署也可以单独通过nginx进行配置，不用依赖后端。所以前后端就算是真正可以分开了。

这个时间段，nodejs的崛起，再加上组件化开发的概念逐渐形成。前端的开发者提供了很多通用的组件，提升了代码的复用性，很多人开始重复造轮子，发布组件到npm上。

再后来，前端框架崛起，更加让前后端分离成为了一个潮流，甚至说不前后端分离都不知道怎么写代码了。最开始angular，然后有了vue、react。最开始了解下angular的用法，但是没理解里面的概念，再加上变化特别快，就没入坑。真正用起来的是vue框架，那时候觉得vue的概念特别好理解，template + script + css。这就是一个模块、就可以是一个组件。每一个页面都是模块，通用的组件可以单独封装定义复用。

最后还有一个很关键的东西，webpack。webpack让组件化更加容易。在开发的时候，可以提供dev-server，可以结合mock来提供数据。打包的时候，能根据模块的依赖关系，为我们将需要的代码一起打包，通过loader进行编译，plugins进行打包过程中各种声明周期环节的代码处理等等。

使得前后端完全就是两个独立的东西。



前后端分离的好处

第一：可以讲后台、前端的开发任务完全独立开，各尽其职。符合程序设计里面的，专一原则。就是一个模块只处理自己的某一块功能，不耦合。

第二：刚才也说到，解耦。后台只需要提供接口数据即可，其他的时间就可以去提示系统的性能，比如并发处理能力、每s种吞吐量。提升负载能力等等。前端可以根据接口去自己实现各式各样的页面。比如web端、h5、app等。

第三：前后端可以独立发布。

第四：提升开发效率，尤其是一个系统刚刚设计的时候。

怎么实施？

设计 ：后台去设计系统的框架，比如数据库、中间件、缓存架构。考虑容量、性能可扩展性。

​			前端就去设计UI、根据设计页面的组件，设想需要的数据格式，需要哪些接口。和后端去定义好。

开发：前后端各自去按照接口定义去开发，前端可以按照mock数据去开发页面，实现无后台的路由跳转、交互。

​		后端也只需要提供规定的接口数据即可。

测试：

​	前端就测试页面实现UI、交互、传参、页面跳转呀等等。

​	后端就保证接口的正确性，测试一些异常情况是否能抛出错误，验证用户的权限这些。

部署：

​	前后端独立部署，只要不出现很大的接口变化，可以单独发布。







# 解决方案



## 前端可配置化logo的设计方案

> 这个方案是在工作当中运用到的最小化、最简易版的设计方案

### 需求背景

给公司做了一个基于sass服务的运营——管理端界面。因为是给客户使用的，有一些客户希望能用自己的公司的logo、海报背景等等。相当于个性化定制。

所以需要把一些配置提炼出来，作为可配置化的功能。



### 解决方案

> 一、方案思路

首先定义一个配置文件，可以是.json的后缀，也可以是.js的后缀。配置的内容主要就是需要配置的各种logo、title等信息。

通过后台的相关接口，知道引入哪一个配置文件。

根据接口，引入这个配置文件，可以是通过ajax来请求这个json，又或者是动态import这个js文件，取决于你的文件格式。



> 二、关键代码

**配置文件格式**

```json
{
  "default": {
    "loginBg": "/static/img/default/login-bg.png",
    "footerLogo": "/static/img/default/footer-logo.png",
    "logo": "/static/img/default/logo.png",
    "welcome": "/static/img/default/welcome-bg.png",
    "favicon": "/static/img/default/favicon.ico"
  }
}

```

这里就简单举个例子，“default”就是配置的唯一id，不同的配置会分配一个id给他。

default下面的key就是配置项。



**设置为全局变量**

```html
 <% if (process.env.NODE_ENV === 'production') { %>
      window.__config = {
        #if ($third_type)
          thirdType: '<%= "$!third_type" %>',
        #else
          thirdType: 'default',
        #end
        #if ($title)
          title: '<%= "$!title" %>',
        #else
          title: '管理平台',
        #end
      }
   <% } %>
```

这里其实用到了模板语言，` <% if (process.env.NODE_ENV === 'production') { %>`是ejs的语法。node打包编译完成后，需要将它放到服务端，从服务端直接那边返回页面。

这段话的意思是，从服务端渲染的时候，读取third_type的变量信息，然后直接设置为全局window.__config.thirdType这个变量。 这个变量的意思就是具体需要用到哪个配置文件的意思。



**view使用**

先读取配置信息

```js
import images from '../assets/img/images.json';
// 中间省略
...
// vue的data对象
data() {
  return {
		images: images[window.__config.thirdType]
  }
}
```

再在用到的地方，使用data变量来替换。

```jsx
 <a href="#" class="header-logo">
  用到图片的地方
  <img :src="images.logo" class="header-logo-img">
 </a>
```



> 三、方案的优缺点

**优点**：

1. 最小化的解决了个性化配置的问题。只需要后台配合域名或者机构号，来设置好thirdType参数，再返回给前端即可。
2. 从页面渲染加载时，就可以确认thirdType，不会出现闪屏的问题；

**缺点**：

1. 配置不灵活，需要手动写配置文件，而且替换图片也需要开发人员进行打包升级，不能做到立即生效；



> 四、待改进点

1. 因为我们产品以及后台都没有规划好这块的功能设计，所以其实最大的改进就是将这些配置本身就做成功能。
2. 其次，import json文件，实际上会把json代码打包到整个代码里面去，导致文件臃肿。最好是从服务端加载。
3. 图片都是本地图片，最好也可以从远端读取图片，减少打包的大小；



> 五、源码地址





## 2.nodejs进行服务的转发代理

### 需求背景





## 3.实现一个大文件上传

### 需求背景

本来是在做一个运维工具，用来测试我们对外的user api接口。由于是nodejs写的，而node对FormData的支持不是很好，所以提交文件就很麻烦。

后面衍生出了两种问题：

1、怎么用nodejs去模拟浏览器的request去上传文件

2、怎么进行大文件上传



### 解决方案

> 问题分析

首先，在http请求里，如果是普通的form表单提交，会以`application/x-www-form-urlencoded`的形式传输. 但如果是传输文件的格式,需要设置header为是`multipart/form-data`. 

来看一个文件上传的http报文：

```http
POST /file/v1/upload HTTP/1.1
Host: localhost:8081
Content-Length: 100460
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW

----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="file"; filename="v2-f7139f8763b996ebfa28486e160f6378_r.jpg"
Content-Type: image/jpeg

(data)
----WebKitFormBoundary7MA4YWxkTrZu0gW--

```

上面4行是request的headers

中间有一行空行，空行下面是FormData

可以看出来：FormData是以`----WebKitFormBoundary${random_str}`开始，以`----WebKitFormBoundary${random_str}--`结尾。并且这个值和headers里面Content-Type的boundary一致。



所以第一个问题很好解决，只需要模拟这种请求的格式，应该就能发送一个文件到服务端。

> 实现代码：

```js
const http = require('http');
const fs = require('fs');

var boundary = '001373272605314343826714';

const filePath = '/Users/keyang/Desktop/v2-f7139f8763b996ebfa28486e160f6378_r.jpg';

const options = {
	'method': 'POST',
	'hostname': 'localhost',
	'port': 61470,
	'path': '/file/v1/upload',
	'headers': {
		'Content-Type': 'multipart/form-data; boundary=------------------------WebKitFormBoundary7MA4YWxkTrZu0gW'
	}
}


const req = http.request(options, function (res) {
	var chunks = [];

	res.on("data", function (chunk) {
		chunks.push(chunk);
	});
	res.on("end", function (chunk) {
		var body = Buffer.concat(chunks);
		console.log(body.toString());
	});
	res.on("error", function (error) {
		console.error(error);
	});
});

const postData = '------------------------' + boundary + '\r\n'
	+ 'Content-Disposition:form-data; name="file"; filename="v2-f7139f8763b996ebfa28486e160f6378_r.jpg"\r\n'
	+ 'Content-Type: image/jpeg\r\n\r\n'
const endData = '\r\n------------------------' + boundary + '--\r\n';


fs.stat(filePath, (err, stats) => {
	req.setHeader('Content-Type', 'multipart/form-data; boundary=------------------------' + boundary);
	req.setHeader('Content-Length', Buffer.byteLength(postData) + Buffer.byteLength(endData) + stats.size);
	req.write(postData);
	req.write(fs.readFileSync(filePath))
	req.end(endData);
})
```





第二部分上传大文件的思路：

1.客户端分片；使用Blob.prototype.slice方法。将大文件分成小的文件，确保每个文件不会超过1048576字节的大小。

2.服务端合并：先接受客户端传输的分片文件，按顺序保存。上传完成后，利用对分片传输的文件进行合并。



分片文件的发送大致如下：

```html
POST /test.html HTTP/1.1
Host: example.org
Content-Type: multipart/form-data;boundary="boundary"

--boundary
Content-Disposition: form-data; name="chunk"; filename="blob"
Content-Type: application/octet-stream

(binary)
--boundary
Content-Disposition: form-data; name="hash"

value1
--boundary
Content-Disposition: form-data; name="filename"

value2
--boundary--
```

利用hash值来标识文件顺序，利用chunk来传输文件



![image-20200113154533606](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-13-074533.png)



> 代码实现

```java
# interview-learn
//https://juejin.im/post/5dff8a26e51d4558105420ed?utm_source=gold_browser_extension#heading-13
```









## 4.封装组件

之前在给公司做项目的时候，基于vue + element封装了一些项目的插件。

组件封装好了，但是怎么把他提取出来给小伙伴们一起使用就成了一个难题。这边经过一番研究，终于找到了一个最优的打包配置，记录一下。

> 首先看一下webpack的配置

不同于app的打包，library的打包有两个概念：`externals` 、`暴露library`

[externals](./Webpack#externals)把一些依赖不打包到bundle里，而是作为外部依赖项。

[output](./Webpack#output)用来设置打包library被引用时的，变量的引用方式。

```js
// 将library打包出去
const webpack = require("webpack");
const {CleanWebpackPlugin} = require('clean-webpack-plugin');

const vueLoaderConfig = require('./vue-loader.conf');
const path = require('path');
const version = require("./../package.json").version;

const utils = require('./utils')

module.exports = {
  // mode: 'production',
  entry: path.join(__dirname, '..', "src/index.js"),
  output: {
    path: path.join(__dirname, '..', 'dist'),
    filename: "gs-comps.js",
    library: "GsComps",
    libraryTarget: "umd",
  },
  resolve: {
    extensions: ['.js', '.vue'],
    alias: {
      '@': path.resolve('src'),
    }
  },
  externals: {
    underscore: {
      commonjs: 'underscore',
      commonjs2: 'underscore',
      amd: 'underscore',
      root: '_'
    },
    vue: 'Vue',
    vuex: 'vuex',
    'element-ui': {
      commonjs: 'element-ui',
      commonjs2: 'element-ui',
    },
    'element-ui/src/transitions/collapse-transition': 'element-ui/lib/transitions/collapse-transition',
    'element-ui/src/mixins/emitter': 'element-ui/lib/mixins/emitter',
    'element-ui/src/locale': 'element-ui/lib/locale',

  },
  module: {
    rules: [
      ...utils.styleLoaders({sourceMap: true, extract: true}),
      {
        test: /\.vue$/,
        loader: 'vue-loader',
        options: vueLoaderConfig,
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: "babel-loader",
      }
    ]
  },
  plugins: [
    new CleanWebpackPlugin(),
    new webpack.DefinePlugin({
      "process.env": {
        NODE_ENV: '"production"'
      },
      VERSION: JSON.stringify(require("../package.json").version)
    }),
    new webpack.LoaderOptionsPlugin({
      minimize: true,
      debug: false
    }),
    new webpack.optimize.UglifyJsPlugin({
      compress: {
        warnings: false
      },
      sourceMap: true,
      comments: false,
      beautify: false
    }),
  ]
};

```



> 然后看一下封装library的方式

```js
// library index.js
import EasySelect from './components/EasySelect'
import EasyTable from './components/EasyTable'
import EasyInput from './components/EasyInput'
import VirtualList from './components/VirtualList'
import VirtualTree from './components/VirtualTree'

const components = [
  EasySelect,
  EasyTable,
  EasyInput,
  VirtualList,
  VirtualTree
]

const install = function (Vue) {
  components.forEach(component => {
    Vue.component(component.name, component)
  })
}

if (typeof window !== 'undefined' && window.Vue) {
  install(window.Vue)
}

export default {
  install,
 	EasySelect,
  EasyTable,
  EasyInput,
  VirtualList,
  VirtualTree
}
```

组件的indexjs

```js
// 引入组件
import EasyTable from './EasyTable'
// 写install方法
EasyTable.install = function (Vue) {
  Vue.component(EasyTable.name, EasyTable)
}
export default EasyTable
```



> 测试过后，发布library

```js
"main": "dist/gs-comps.js" // 设置package.json的main入口，用来发布
```

```shell
npm publish
```



## 5.前端Excel导出数据功能

有一些报表的数据，客户希望通过导出成为excel的方式去查看。而这些数据都已经通过后台接口返回回来了，那么单纯的通过前端就可以进行excel导出功能。

> 使用说明

```js
// 声明导出excel的header名称
const tHeader = [this.$t('table.initDate'), this.$t('table.coName'), this.$t('table.pdName'), this.$t('table.assetAccoName'), this.$t('table.exchgroupName'), this.$t('table.exchName'), this.$t('table.currencyPair'), this.$t('table.orderDir'), this.$t('table.strikeAVGPrice'), this.$t('table.strikeQty'), this.$t('table.strikeAmount'), this.$t('table.fee')];
// 处理数据
const filterVal = ['init_date', 'co_name', 'pd_name', 'asset_acco_name', 'exch_group_name', 'exch_name', 'stock_name', 'order_dir', 'strike_aver_price', 'bs_crncy_strike_qty', 'qt_crncy_strike_qty', 'strike_fee'];
const list = this.tableData;
const data = list.map(item => filterVal.map((key) => {
  if (key === 'strike_aver_price' || key === 'bs_crncy_strike_qty' || key === 'qt_crncy_strike_qty' || key === 'strike_fee') {
    return format('number', '$0', item[key]);
  }
  if (key === 'order_dir') {
    return this.translateDict(key, item[key]);
  }
  return item[key];
}));
const currentDate = new Date();
const excelName = this.$t('table.exchgroupStrike') + currentDate.format('yyyyMMdd');
const excelSheetName = this.$t('table.exchgroupStrike');
// 交给工具方法去导出数据
export_json_to_excel(tHeader, data, excelSheetName, excelName);
```





# 框架沉淀

## Vue全家桶

源码地址：https://github.com/6gunner/vue-basic-framework/tree/master/src

###第一版本 

> 时间：2019.7.21日

- 加入了axios以及一些常用的拦截器。拦截器业务根据实际项目业务来写；
- 加入router和store。一般项目都会用到
- 加了组件的懒加载; 需要引入babel的插件



其他组件根据后面需要再考虑加入。



## React

### 异常问题排查1

> #### 堆栈信息：

![image-20200102193014405](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-02-113014.png)



> #### 排查过程：



> #### 定位：

![image-20200102192921583](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-02-112922.png)



> #### 解决方案：

⚠️Only one input can be used within a FormControl.

因为FormControl里面只能有一个输入组件，所以进行了调整；

![image-20200102203141716](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-02-123141.png)



看源码，涉及到[Hooks](#React.Hook)



FormControl代码

![image-20200102210426794](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-02-130426.png)

Input代码

![image-20200102210545652](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-02-130546.png)

![image-20200102210616866](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-02-130617.png)

### Hook

> #### useState

`initialState` 参数是初始渲染期间使用的状态。 在随后的渲染中，它会被忽略了。 如果初始状态是高开销的计算结果，则可以改为提供函数，该函数仅在初始渲染时执行：

```
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
```



> useCallback

> useMemoize

返回一个缓存了结果的函数；





## Next.js

> 一种服务端渲染的框架；功能比较简单，配置也很简单，不需要依赖别的服务。
>
> 内部应该整合了webpack和babel，可以支持热部署，以及es6



unzip

```javascript
function unzip(b64Data){
    var strData = atob(b64Data);
    // Convert binary string to character-number array
    var charData  = strData.split('').map(function(x){return x.charCodeAt(0);});
    // Turn number array into byte-array
    var binData   = new Uint8Array(charData);
    // // unzip
    var data    = pako.inflate(binData);
    // However, the Uint8Array has a limit of buffer size. It will crashes on big buffers, the rude max size is 246300 and sometimes it not correct in different browser.
    // Convert gunzipped byteArray back to ascii string:
  //	下面这个方法会报超过最大调用次数，造成堆溢出。
    // strData   = String.fromCharCode.apply(null, new Uint16Array(data));
    strData = new TextDecoder("utf-8").decode(data);
    return strData;
}
```

zip



## [Webpack](./Webpack)



### [Dva](./Dva)



## Yarn

yarn的好处在于，他不仅可以和npm一样对package进行管理，而且可以保证在不同环境上，项目里所用到的依赖都是一致的。 

这依赖于yarn.lock这个文件，它应该被提交到git上进行版本控制。

除此之外，yarn还增加了一些缓存的功能，可以比npm更稳定，下载速度更快；

> ### 依赖版本



> ### 依赖类型

除了常见的devDependencies、dependencies之外，今天了解到了一些其他类型的依赖：

**`peerDependencies`**

这是“上级依赖”，一种特殊的依赖，在发布包的时候需要。有这种依赖意味着安装此包的用户也需要和包同样的依赖。 

**`optionalDependencies`**

可选依赖。即使安装失败，yarn也会认为整个过程是成功的；

**`bundledDependencies`**

"打包依赖"。打包的时候，会将这里的依赖项一起打包进来。

例如：

```
"name": "awesome-web-framework",
"version": "1.0.0",
"bundledDependencies": [
    'renderized', 'super-streams'
   ]
```

`npm pack`会将`renderized `和`super-streams`放入生成的包**awesome-web-framework-1.0.0.tgz**中，并且在`npm install awesome-web-framework-1.0.0.tgz`时，`renderized `和`super-streams`也会被一同安装。



## [WebWorker](./WebWorker)

## 单元测试











# 框架原理

https://cl.n2sa.xyz/htm_data/2002/7/3809942.html

## MVVM双向绑定

> https://mp.weixin.qq.com/s/MCuryUvco5_86HsMmVa21

### MVC模式

<img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9n5jvljkoj30ju09oab6.jpg" alt="image-20191206175541570" style="zoom:50%;" />

第`3`步model返回视图实际上是 controller通过dom操作修改view；

<img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9n4yewelpj30j608rmy2.jpg" alt="image-20191206173503281" style="zoom:50%;" />

**缺点**：model的频繁变化，需要同步通知，比如通过监听事件来修改view，附带大量的dom操作，

​			用户通过controller修改model，需要同步model的状态；



### MVVM模式

mvvm用vm替代了controller，而且也改变了数据传递的方向。 view不再直接关联model，而是通过viewmodel进行传递。

![image-20191206175704691](https://tva1.sinaimg.cn/large/006tNbRwly1g9n5lbj3auj30it04474q.jpg)

view变化时，viewmodel进行



### Angular脏检测

zone的实现方式



### Vue 数据劫持

原理

​	Object.defineProperty

​	Compile

​	Wathcer

​	Dep

怎么实现一个双向数据绑定

Vue3.0做了什么优化？—— Proxy

### React单项数据流



react怎么去简化setState和事件监听的代码



Webpack流程



## 实现一个简单的webpack

> https://juejin.im/post/5de099886fb9a071562facad#heading-5
>
> 本例自己实现了简单的webpack，对es6的代码进行编译和分析，将依赖文件打包在一起，生成可执行的代码。



关键代码讲解

```js
const generateCode = (entry) => {
	const graph = JSON.stringify(makeDependenciesGraph(entry));
	// 我们来构造exports和require函数，这两个函数在浏览器里面是不存在的
	return `
    (function(graph){
      // require方法第二次传入的是'./message.js', 需要转化为'./src/message.js', 否则无法找到
     function require(module) {
        const exports = {};
        function innerRequire(relativePath) {
          // 将代码里写的相对路径转化为绝对路径后，调用外部真正的require方法
          const absolutePath = graph[module].dependencies[relativePath];
          return require(absolutePath);
        }
        // 写闭包避免变量互相影响, 传入innerRequire作为require，这样内部调用的require方法便是innerRequire
       (function(exports, require, code) {
        eval(code)
       })(exports, innerRequire, graph[module].code)
       return exports;
     }
     require('${entry}')
    })(${graph})
  `;
}
```



生成的code为：

```js
(function(graph){
	// require方法第二次传入的是'./message.js', 需要转化为'./src/message.js', 否则无法找到
	function require(module) {
		const exports = {};
		function innerRequire(relativePath) {
			// 将代码里写的相对路径转化为绝对路径后，调用外部真正的require方法
			const absolutePath = graph[module].dependencies[relativePath];
			return require(absolutePath);
		}
		// 写闭包避免变量互相影响, 传入innerRequire作为require，这样内部调用的require方法便是innerRequire
		(function(exports, require, code) {
			eval(code)
		})(exports, innerRequire, graph[module].code)
		return exports;
	}
	require('./src/index.js')
})({"./src/index.js":{"dependencies":{"./message.js":"./src/message.js"},"code":"\"use strict\";\n\nvar _message = _interopRequireDefault(require(\"./message.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nconsole.log(_message[\"default\"]);"},"./src/message.js":{"dependencies":{},"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar message = \"Mock Webpack\";\nvar _default = message;\nexports[\"default\"] = _default;"}})

```

