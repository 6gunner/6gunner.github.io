# 解决方案

## 1.前端可配置化logo的设计方案

> 这个方案是在工作当中运用到的最小化、最简易版的设计方案

### 需求背景

给公司做了一个基于sass服务的运营——管理端界面。因为是给客户使用的，有一些客户希望能用自己的公司的logo、海报背景等等。相当于个性化定制。

所以需要把一些配置提炼出来，作为可配置化的功能。



### 解决方案

> 一、方案思路

首先定义一个配置文件，可以是.json的后缀，也可以是.js的后缀。配置的内容主要就是需要配置的各种logo、title等信息。

通过后台的相关接口，知道引入哪一个配置文件。

根据接口，引入这个配置文件，可以是通过ajax来请求这个json，又或者是动态import这个js文件，取决于你的文件格式。



> 二、关键代码

**配置文件格式**

```json
{
  "default": {
    "loginBg": "/static/img/default/login-bg.png",
    "footerLogo": "/static/img/default/footer-logo.png",
    "logo": "/static/img/default/logo.png",
    "welcome": "/static/img/default/welcome-bg.png",
    "favicon": "/static/img/default/favicon.ico"
  }
}

```

这里就简单举个例子，“default”就是配置的唯一id，不同的配置会分配一个id给他。

default下面的key就是配置项。



**设置为全局变量**

```html
 <% if (process.env.NODE_ENV === 'production') { %>
      window.__config = {
        #if ($third_type)
          thirdType: '<%= "$!third_type" %>',
        #else
          thirdType: 'default',
        #end
        #if ($title)
          title: '<%= "$!title" %>',
        #else
          title: '管理平台',
        #end
      }
   <% } %>
```

这里其实用到了模板语言，` <% if (process.env.NODE_ENV === 'production') { %>`是ejs的语法。node打包编译完成后，需要将它放到服务端，从服务端直接那边返回页面。

这段话的意思是，从服务端渲染的时候，读取third_type的变量信息，然后直接设置为全局window.__config.thirdType这个变量。 这个变量的意思就是具体需要用到哪个配置文件的意思。



**view使用**

先读取配置信息

```js
import images from '../assets/img/images.json';
// 中间省略
...
// vue的data对象
data() {
  return {
		images: images[window.__config.thirdType]
  }
}
```

再在用到的地方，使用data变量来替换。

```jsx
 <a href="#" class="header-logo">
  用到图片的地方
  <img :src="images.logo" class="header-logo-img">
 </a>
```



> 三、方案的优缺点

**优点**：

1. 最小化的解决了个性化配置的问题。只需要后台配合域名或者机构号，来设置好thirdType参数，再返回给前端即可。
2. 从页面渲染加载时，就可以确认thirdType，不会出现闪屏的问题；

**缺点**：

1. 配置不灵活，需要手动写配置文件，而且替换图片也需要开发人员进行打包升级，不能做到立即生效；



> 四、待改进点

1. 因为我们产品以及后台都没有规划好这块的功能设计，所以其实最大的改进就是将这些配置本身就做成功能。
2. 其次，import json文件，实际上会把json代码打包到整个代码里面去，导致文件臃肿。最好是从服务端加载。
3. 图片都是本地图片，最好也可以从远端读取图片，减少打包的大小；







# 框架沉淀

## Vue全家桶

###第一版本 

> 时间：2019.7.21日

- 加入了axios以及一些常用的拦截器。拦截器业务根据实际项目业务来写；

- 加入router和store。一般项目都会用到
- 加了组件的懒加载

其他组件根据后面需要再考虑加入。





## Next.js

> 一种服务端渲染的框架；功能比较简单，配置也很简单，不需要依赖别的服务。
>
> 内部应该整合了webpack和babel，可以支持热部署，以及es6



unzip

```javascript
function unzip(b64Data){
    var strData = atob(b64Data);
    // Convert binary string to character-number array
    var charData  = strData.split('').map(function(x){return x.charCodeAt(0);});
    // Turn number array into byte-array
    var binData   = new Uint8Array(charData);
    // // unzip
    var data    = pako.inflate(binData);
    // However, the Uint8Array has a limit of buffer size. It will crashes on big buffers, the rude max size is 246300 and sometimes it not correct in different browser.
    // Convert gunzipped byteArray back to ascii string:
  //	下面这个方法会报超过最大调用次数，造成堆溢出。
    // strData   = String.fromCharCode.apply(null, new Uint16Array(data));
    strData = new TextDecoder("utf-8").decode(data);
    return strData;
}
```

zip







## Webpack

>  webpack是一个模块打包工具

Webpack 配置文件：webpack.config.js



### loader

> #### loader的作用

webpack无法处理.js后缀之外的文件，所以需要loader来进行处理文件。



> #### file-loader vs url-loader

url-loader可以把图片打包到js文件里去，以base64的格式来存放。

file-loader是把图片独立打包出来，形成静态资源。当然file-loader还可以处理字体otf、svg等后缀的静态资源。

```js
module: {
        rules: [{
            test: /\.(png|jpe?g)$/i,
            use: [{
                loader: 'url-loader',
                options: {
                    // 10kb;
                    limit: 10240,
                    name: '[name].[ext]?[contenthash]',
                }
            }]
        }, /*{
            test: /\.(png|jpe?g)$/i,
            use: [{
                loader: 'file-loader',
                options: {
                    name: '[name].[ext]?[contenthash]',
                    publicPath: '/some/path/',
                    outputPath: '/some/path/',
                    postTransformPublicPath: (p) => `__webpack_public_path__ + ${p}`,
                }
            }]
        }*/]
    }
```

url-loader有一个==limit==的options可以配置。当图片超过了limit的大小，就不会将图片转化为base64, 默认会使用file-loader进行处理。但是这里有一个容易进入的误区：我之前以为需要配置再配置一个file-loader，让url-loader去执行file-loader的配置。实际上不需要再单独配置一个file-loader，url-loader自带了file-loader各个配置。



> #### 加载样式

- style-loader
- css-loader

  

> ##### 基础配置

首先，假如项目里用到了最简单的css，需要配置成如下：

```js
{
  test: /\.(css)$/i,
  use: [
  	'style-loader',
    {
      loader: 'css-loader',
      options: {
      	modules: true,
    	}
  }]
}
```



> ##### 小疑问：为什么需要这么多loader连起来用？

webpack一般建议`style-loader`和`css-loader`结合使用。我的理解是：`css-loader`可以对`.css后缀`的文件进行解析处理，然后交给`style-loader`编译成对应的style样式文件。

之前看到过一种配置方案：

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.link\.css$/i,
        use: [
          { loader: 'style-loader', options: { injectType: 'linkTag' } },
          { loader: 'file-loader' },
        ],
      },
    ],
  },
};
```

这种配置方案，css文件就不会被处理，而是直接生成了style标签，动态插入到了dom里；



> ##### css-loader#importLoaders

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: [
          'style-loader',
          {
            loader: 'css-loader',
            options: {
              importLoaders: 2,
              // 0 => no loaders (default);
              // 1 => postcss-loader;
              // 2 => postcss-loader, sass-loader
            },
          },
          'postcss-loader',
          'sass-loader',
        ],
      },
    ],
  },
};
```

importLoaders这个属性其实挺关键，这里备注一下。 主要是针对样式文件里@import的样式的处理；



> ##### 样式模块化

模块化的概念其实就是：各个页面组件里的样式作用域只会在当前模块里起作用，而不会影响到全局样式。这样写样式时就可以放心定义类名。

模块化配置首先要在webpack.config.js里配置好`modules: true`

```js
{
  test: /\.(css)$/i,
  use: [
  	'style-loader',
    {
      loader: 'css-loader',
      options: {
      modules: true,
    }
  ]
}
```

其次，引入样式时，需要将样式import为一个对象，然后去使用这个的属性。

```js
// import './index.css';
import style from './index.css';

const img1 = appendImg(imgPath1);
img1.classList.add(style.avatar);
```

可以理解为，如果是模块化，webpack会将样式处理为一个js对象，然后在页面是使用样式就是使用对象的某一个属性。



> ##### 预处理配置

`postcss-loader`



### plugins

plugins可以帮助webpack，在打包的不同生命周期中，做不同的处理；



### devltool

> 参考博客 https://juejin.im/post/58293502a0bb9f005767ba2f



![image-20191230202323229](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-30-122323.png)



> #### 最佳实践

开发环境：cheap-module-eval-source-map

线上环境：cheap-module-source-map 





> #### 几个mode配置的比较

**source-map**

```js
// import style from './index.css';

const img1 = Object(_appendImg__WEBPACK_IMPORTED_MODULE_2__["default"])(_images_avatar_jpeg__WEBPACK_IMPORTED_MODULE_0__["default"]);
// img1.classList.add(style.avatar);
const img2 = Object(_appendImg__WEBPACK_IMPORTED_MODULE_2__["default"])(_images_test_png__WEBPACK_IMPORTED_MODULE_1__["default"]);

consele.log(img2);


/***/ })

/******/ });
//# sourceMappingURL=main.js.map
```

打包代码的同时生成一个sourcemap文件，并在打包文件的末尾添加`//# souceURL`，注释会告诉JS引擎原始文件位置。

```
{
  "version": 3,
  "sources": [
    "webpack:///webpack/bootstrap",
    "webpack:///./src/index.css",
    "webpack:///./node_modules/style-loader/dist/runtime/injectStylesIntoLinkTag.js",
    "webpack:///./src/appendImg.js",
    "webpack:///./src/images/avatar.jpeg",
    "webpack:///./src/images/test.png",
    "webpack:///./src/index.css?b1aa",
    "webpack:///./src/index.js"
  ],
  "names": [],
  "mappings": ";xxxx",
  "file": "main.js",
  "sourcesContent": [xxxxxxx],
  "sourceRoot": ""
}
```



**hidden-source-map**

```js
// import style from './index.css';
const img1 = Object(_appendImg__WEBPACK_IMPORTED_MODULE_2__["default"])(_images_avatar_jpeg__WEBPACK_IMPORTED_MODULE_0__["default"]);
// img1.classList.add(style.avatar);
const img2 = Object(_appendImg__WEBPACK_IMPORTED_MODULE_2__["default"])(_images_test_png__WEBPACK_IMPORTED_MODULE_1__["default"]);
consele.log(img2);
/***/ })
/******/ });
```

去除了末尾的`//# souceURL`



**inline-source-map**

<img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-30-233220.png" alt="image-20191231073219616" style="zoom:40%;" />



**eval**

```
webpackJsonp([1],[
  function(module,exports,__webpack_require__){
    eval(
      ...
      //# sourceURL=webpack:///./src/js/index.js?'
    )
  },
  function(module,exports,__webpack_require__){
    eval(
      ...
      //# sourceURL=webpack:///./src/static/css/app.less?./~/.npminstall/css-loader/0.23.1/css-loader!./~/.npminstall/postcss-loader/1.1.1/postcss-loader!./~/.npminstall/less-loader/2.2.3/less-loader'
    )
  },
  function(module,exports,__webpack_require__){
    eval(
      ...
      //# sourceURL=webpack:///./src/tmpl/appTemplate.tpl?"
    )
  },
...])
```



**eval-source-map**

```
webpackJsonp([1],[
  function(module,exports,__webpack_require__){
    eval(
      ...
      //# sourceMappingURL=data:application/json;charset=utf-8;base64,...
    )
  },
  function(module,exports,__webpack_require__){
    eval(
      ...
      //# sourceMappingURL=data:application/json;charset=utf-8;base64,...
    )
  },  
  function(module,exports,__webpack_require__){
    eval(
      ...
      //# sourceMappingURL=data:application/json;charset=utf-8;base64,...
    )
  },
  ...
]);
```

eval-source-map和eval的区别在于，source-map将注释里面的内容换成了dataurl.



**cheap-source-map**

**cheap-module-source-map**

网上说module会带上loader的源码，但是我比较过两个的结果，并没有什么不同。可能是我代码本身没什么需要loader转化的。 后期再比较这个。



**总结**

source-map：打包错误提示信息最全；

inline-source-map：是将源码合并到打包文件中去，以DataUrl的形式写到打包文件里；

cheap-source-map 的意思是生成一个没有列信息的sourceMap文件，只会告诉哪一行出错，而不会告诉是哪一列出错。而且不包含loader的sourcemap

module：的意思是，会打包那些被loader加载的模块源码，不加module只会处理业务逻辑代码；

eval：打包后模块会通过eval的方式来执行，速度最快；







#### //todo SourceMap原理



### devServer

> #### proxy代理配置

```
devServer: {
    proxy: {
      '/api': 'http://localhost:3000'
    }
  }
```

`/api/users`会被代理到`http://localhost:3000/api/users`

> ##### 如果想要重写路径

```
devServer: {
  proxy: {
    '/api': {
    target: 'http://localhost:3000',
  	pathRewrite: {'^/api' : ''}
  	}
	}
}
```

`/api/users`会被代理到`http://localhost:3000/users`

> 如果不是所有都代理，可以传一个function

- 返回null或者undefined会继续通过代理
- 返回false会直接404
- 返回一个路径，会当做`express server`来直接返回.



> ##### 踩坑：405错误

![image-20191227140841502](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-27-060842.png)



proxy配置的优先级默认是从上往下的，只要上面的proxy匹配上了请求规则，就不会继续向下找了。即使下面的匹配更完全。

<img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2019-12-27-230628.png" alt="image-20191228070627938" style="zoom:30%;" />

图1出现的问题就是因为我们把配置写成了123的顺序。导致/ajax/api的请求全部代理到了www。改成321的顺序即可。





## Yarn

yarn的好处在于，他不仅可以和npm一样对package进行管理，而且可以保证在不同环境上，项目里所用到的依赖都是一致的。 

这依赖于yarn.lock这个文件，它应该被提交到git上进行版本控制。

除此之外，yarn还增加了一些缓存的功能，可以比npm更稳定，下载速度更快；



> ### 依赖类型

除了常见的devDependencies、dependencies之外，今天了解到了一些其他类型的依赖：

**`peerDependencies`**

这是“上级依赖”，一种特殊的依赖，在发布包的时候需要。有这种依赖意味着安装此包的用户也需要和包同样的依赖。 

**`optionalDependencies`**

可选依赖。即使安装失败，yarn也会认为整个过程是成功的；

**`bundledDependencies`**

"打包依赖"。打包的时候，会将这里的依赖项一起打包进来。

例如：

```
"name": "awesome-web-framework",
"version": "1.0.0",
"bundledDependencies": [
    'renderized', 'super-streams'
   ]
```

`npm pack`会将`renderized `和`super-streams`放入生成的包**awesome-web-framework-1.0.0.tgz**中，并且在`npm install awesome-web-framework-1.0.0.tgz`时，`renderized `和`super-streams`也会被一同安装。



## 单元测试





# JavaScript事件循环模型

事件循环里 

主线程处理代码，判断是否是同步任务，同步任务会进入执行堆栈，异步任务把回调函数进入执行队列中



执行堆栈的任务结束后，判断队列中是否有任务，如果有，就将异步任务加入到执行队列中进行处理。



异步任务也有task 和 Microtask





# Nginx配置

## 踩坑1：mac配置后403

> brew安装目录：/usr/local/Cellar/nginx/1.15.10

> 产生背景

mac配置完nginx后，明明路径都是正确的，但是还是无法打开页面，日志报403错误；

> 问题现象

```verilog
2019/12/24 21:24:34 [error] 80457#0: *1 open() "/Users/keyang/Workspace/temp/build/manifest.json" failed (13: Permission denied), client: 127.0.0.1, server: www.asproex.com
```

> 问题原因

没有权限，但是没有权限的原因有很多：

可能是nginx启动用户不对；

也可能是用户无法访问目录，需要配置权限 777；

> 问题解决

我这里解决方案就是去设置了777的目录权限（包括根目录）；

比如我访问的目录是：`/Users/keyang/Workspace/temp/build`

那么需要`drwxrwxrwx   5 keyang  staff   160B 12 24 21:56 temp`这个目录就开始配置权限；





## 踩坑2：保留nginx目录

如果有多级路径的话，文件目录也要有多级；

比如我想把浏览器路径配置为：`http://xxx.domain.com/activity/ieo `

nginx配置需要是：

```nginx
location ^~ /activity/ieo {
  root /Users/keyang/Workspace/temp/build/;
  index index.html;
}

// 然后build这个目录里面还需要有子目录，最终的结构是：
/Users/keyang/Workspace/temp/build/activity/ieo
            
```



## 踩坑3：goddy ssl证书从购买到配置

公司的客户的网站证书都是从goddy上买的，然后部署到国外服务器。

由于菜的抠脚，记录以下证书的创建的过程；主要还是参考以下链接：[域名网站 SSL Nginx证书配置](https://blog.csdn.net/weixin_38109191/article/details/98479353)

步骤在博主的博客里记录的很清楚，就不再复制黏贴了。主要是几个点：

1. nginx配置需要的私钥，并不是从goddy上下载的，而是一开始通过ssl命令生成的。也就是说，ssl证书需要先在本地创建一个私钥，然后再生成一个csr文件。最后通过csr文件来生成ssl证书。
2. 创建私钥的命令有两种：

```shell
openssl req -new -newkey rsa:2048 -nodes -keyout 您的域名.key -out 您的域名.csr
```

这种可以一次性搞定；

```shell
openssl genrsa -des3 -out <name of your certificate>.key 2048
openssl req -new -key <name of your certificate>.key -out <name of your certificate>.csr
```

这种就是两步，第一步创建一个key，第二步拿上面的key创建csr；





# 框架原理

## MVVM双向绑定

> https://mp.weixin.qq.com/s/MCuryUvco5_86HsMmVa21

### MVC模式

<img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9n5jvljkoj30ju09oab6.jpg" alt="image-20191206175541570" style="zoom:50%;" />

第`3`步model返回视图实际上是 controller通过dom操作修改view；

<img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9n4yewelpj30j608rmy2.jpg" alt="image-20191206173503281" style="zoom:50%;" />

**缺点**：model的频繁变化，需要同步通知，比如通过监听事件来修改view，附带大量的dom操作，

​			用户通过controller修改model，需要同步model的状态；



### MVVM模式

mvvm用vm替代了controller，而且也改变了数据传递的方向。 view不再直接关联model，而是通过viewmodel进行传递。

![image-20191206175704691](https://tva1.sinaimg.cn/large/006tNbRwly1g9n5lbj3auj30it04474q.jpg)

view变化时，viewmodel进行



### Angular脏检测

zone的实现方式



### Vue 数据劫持

原理

​	Object.defineProperty

​	Compile

​	Wathcer

​	Dep

怎么实现一个双向数据绑定

Vue3.0做了什么优化？—— Proxy

### React单项数据流



react怎么去简化setState和事件监听的代码



Webpack流程



## 实现一个简单的webpack

> https://juejin.im/post/5de099886fb9a071562facad#heading-5
>
> 本例自己实现了简单的webpack，对es6的代码进行编译和分析，将依赖文件打包在一起，生成可执行的代码。



关键代码讲解

```js
const generateCode = (entry) => {
	const graph = JSON.stringify(makeDependenciesGraph(entry));
	// 我们来构造exports和require函数，这两个函数在浏览器里面是不存在的
	return `
    (function(graph){
      // require方法第二次传入的是'./message.js', 需要转化为'./src/message.js', 否则无法找到
     function require(module) {
        const exports = {};
        function innerRequire(relativePath) {
          // 将代码里写的相对路径转化为绝对路径后，调用外部真正的require方法
          const absolutePath = graph[module].dependencies[relativePath];
          return require(absolutePath);
        }
        // 写闭包避免变量互相影响, 传入innerRequire作为require，这样内部调用的require方法便是innerRequire
       (function(exports, require, code) {
        eval(code)
       })(exports, innerRequire, graph[module].code)
       return exports;
     }
     require('${entry}')
    })(${graph})
  `;
}
```



生成的code为：

```js
(function(graph){
	// require方法第二次传入的是'./message.js', 需要转化为'./src/message.js', 否则无法找到
	function require(module) {
		const exports = {};
		function innerRequire(relativePath) {
			// 将代码里写的相对路径转化为绝对路径后，调用外部真正的require方法
			const absolutePath = graph[module].dependencies[relativePath];
			return require(absolutePath);
		}
		// 写闭包避免变量互相影响, 传入innerRequire作为require，这样内部调用的require方法便是innerRequire
		(function(exports, require, code) {
			eval(code)
		})(exports, innerRequire, graph[module].code)
		return exports;
	}
	require('./src/index.js')
})({"./src/index.js":{"dependencies":{"./message.js":"./src/message.js"},"code":"\"use strict\";\n\nvar _message = _interopRequireDefault(require(\"./message.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nconsole.log(_message[\"default\"]);"},"./src/message.js":{"dependencies":{},"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar message = \"Mock Webpack\";\nvar _default = message;\nexports[\"default\"] = _default;"}})

```

