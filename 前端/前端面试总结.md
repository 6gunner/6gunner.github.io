# 面试大纲

<img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-05-133139.png" alt="img" style="zoom:50%;" />





> 写在前面

准备去面试，每天可用的时间大多数集中在晚上。（20:00 - 22:00）

制定计划，切记不能三天打鱼两天晒网。

**忌零散阅读，宜系统复习**

在复习某个部分时可能会引出其它知识点，如果也不是很清楚的话也需要系统的再复习一下。

前端知识体系比较广并且发展迅速，一定要铭记：**基础才是最重要的**。



## JavaScript 基础

基础很重要，能问的东西可多可少。

- 执行上下文/作用域链/闭包
- 原型/继承
- Promise函数
- 深浅拷贝
- 事件机制/Event Loop
- 函数式编程
- service worker/web worker
- ...



## CSS基础

- position
- 行内元素/块状元素
- flex
- 重绘回流
- Sass/Less
- 居中/常见布局
- 层叠上下文
- ...



## 框架

关注 Vue 和 React 的共性和特性，侧重 Vue（我工作中是主 Vue），过程中看了一些源码，加深理解。

- MVVM
- 生命周期
- 数据绑定
- 状态管理
- 组件通信
- computed/watch 原理
- Virtual DOM
- diff
- React Hook
- React Hoc/Vue mixin
- Vue 和 React 有什么不同
- ...



## 工程化

- webpack
- babel
- 模板引擎
- 前端发布
- ……



## 性能优化

必备技能，必须了解。

- 打包优化
- 网络优化
- 代码优化
- ……



## 网络/浏览器

对于前端开发来说，网络和浏览器也属于必须了解的知识点。

- HTTP
- DNS
- TCP/UDP
- HTTPS
- CDN
- ……

经典问题：从输入 URL 到页面展示，发生了什么。



## 计算机基础

- 设计模式
- 数据结构
- 基础算法
- 安全
- ……



## 项目/业务

简历上写的项目，仔细认真的过一遍。还有就是关于业务的一些深层次的东西，得好好思考一下。



# 知识库

## [基础知识](./前端知识总结-基础)



# CSS

**1.如何理解CSS的盒子模型？**

每个HTML元素都是长方形盒子。 （1）盒子模型有两种：IE盒子模型、标准W3C盒子模型；IE的content部分包含了border和pading。 （2）标准W3C盒模型包含：内容(content)、填充(padding)、边界(margin)、边框(border)。

**2.link和@import的区别？**

**3.CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS 3新增伪类有哪些？**

**4.如何让元素垂直居中**

**5.::before 和 :after中双冒号和单冒号 有什么区别？**

单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 伪元素由双冒号和伪元素名称组成。双冒号是在css3规范中引入的，用于区分伪类和伪元素。但是伪类兼容现存样式，浏览器需要同时支持旧的伪类，比如:first-line、:first-letter、:before、:after等。 对于CSS2之前已有的伪元素，比如:before，单冒号和双冒号的写法::before作用是一样的。 提醒，如果你的网站只需要兼容webkit、firefox、opera等浏览器，建议对于伪元素采用双冒号的写法，如果不得不兼容IE浏览器，还是用CSS2的单冒号写法比较安全。

**6.用纯 CSS 创建一个三角形的原理是什么？**

把上、左、右三条边隐藏掉（颜色设为 transparent） #demo { width:0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent; }

**7.CSS隐藏元素的几种方法（至少说出三种）**

- Opacity:元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互;
- Visibility:与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏;
- Display:display 设为 none 任何对该元素直接打用户交互操作都不可能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在;



# 性能优化

> ### 1.为什么要把css放在head里，而js放到body后去？

这题目主要就是看你了不了解浏览器的渲染流程以及浏览器线程间的关系。

首先，浏览器的包含了多个进程，其中渲染进程里又包含了多个线程，和这道题相关的就是==js线程==和==渲染线程==。由于这两个线程是互斥的，而js线程拥有改变dom结构以及属性的能力，所以浏览器会先执行渲染线程，将dom树和cssom树渲染完后，生成RenderObject 树，再执行js线程；

所以，css的渲染是会阻塞js的执行的，那么为了加快页面响应速度，先不去下载js文件，反正也是后面才加载执行，而是等css文件都渲染完全后，再去加载js文件。



> ###  2.大文件断点续传

利用js实现大文件的分片上传以及断点续传

> 参考文章

https://juejin.im/post/5dff8a26e51d4558105420ed?utm_source=gold_browser_extension#heading-18

> 源码地址

https://gitee.com/dendi.ke/interview-learn

> 核心步骤：

- 1.切片，将一个大文件按照合理大小进行切分，分片上传。
- 2.利用web-worker子线程来计算md5值。
- 3.前端分片上传，并且根据md5值，检测是否已经上传过。
- 4.利用axios做取消处理，恢复上传时先读取服务器已上传的文件。

> 关键代码：

- 将文件切片

```js
const perChunkSize = 1048576; // 每个是1M 1024 * 1024
const chunkLength = Math.ceil(file.size / perChunkSize);
const chunks = [];
const chunkSize = Math.ceil(file.size / chunkLength);
let cur = 0;
while (cur < file.size) {
chunks.push({
file: file.slice(cur, cur + chunkSize),
filename: file.name,
});
cur += chunkSize;
}
return chunks;
```

- 利用webworker + SparkMd5计算md5的值
```js
const spark = new SparkMD5.ArrayBuffer();
const fileReader = new FileReader();
// 当前chunk数量
let currentChunk = 0;
fileReader.onload = function (e) {
    spark.append(e.target.result);                   // Append array buffer
    currentChunk++;
    // chunks表示总大小
    if (currentChunk < chunks) {
        loadNext();
    } else {
        console.log('finished loading');
        console.info('computed hash', spark.end());  // Compute hash
    }
};

function loadNext() {
  let start = currentChunk * chunkSize;
  let end = ((start + chunkSize) >= file.size) ? file.size : start + chunkSize;

  fileReader.readAsArrayBuffer(blobSlice.call(file, start, end));
}

```


- 通过axios来进行取消操作；

  ```js
  async _uploadChunks(uploadedList = []) {
    console.log(uploadedList);
    this.paused = false;
    const CancelToken = axios.CancelToken;
    const source = CancelToken.source();
    this.source = source;
    const promises = this.data
    .filter(({hash}) => !uploadedList.includes(hash))
    .map((item) => {
      const formData = new FormData();
      formData.append('chunk', item.chunk);
      formData.append('hash', item.hash);
      formData.append("filename", item.filename);
      return {formData, index: item.index}
    }).map(({formData, index}) => {
      console.log(index);
      return axios({
        url: 'file/v1/uploadChunks',
        method: 'post',
        baseURL: '/api',
        data: formData,
        onUploadProgress: this.createUploadHandler(this.data[index]),
        cancelToken: source.token
      });
    });
    
  pause() {
    if (this.source) {
      this.source.cancel();
      this.paused = true;
    }
  }
  ```


#### 总结

主要学到了两大知识点：1.文件切片、2.web worker的信息传递。

服务端的文件处理是本人自行处理的，主要是根据md5的值来判断文件是否已经上传过。实际应用中应该有同事进行配合，不用考虑太多。


