# JS基础

## JS执行上下文

js执行上下文分3类：

全局上下文

函数上下文

eval



## JS执行栈

也就是浏览器里面的调用栈，栈数据结构，“后进先出“，用来存储代码运行时创建的执行上下文。

js调用函数时，会先将函数的`执行上下文`压入到栈里面；js引擎会执行位于栈顶的函数。函数执行结束后，会将上下文从栈里弹出。



## 变量提升

因为JS引擎在初次执行脚本时，会先去创建一个全局执行上下文。在这个过程里，会先去找到所有的var声明的变量，以及命名函数。然后去执行脚本。

这个过程产生了，引起了变量提前定义，从而造成了变量提升；

用const和let可以避免变量提升；



## 作用域链

首先说一下什么是作用域？

执行上下文其实就是作用域。函数在创建时，js引擎会把为函数创建一个执行上下文（内部作用域）。内部作用域包含：arguments,  this对象, 命名函数，函数内局部变量。

上面说的，js引擎会先创建一个全局上下文，也就是全局作用域。然后每执行一个函数，又会单独创建一个执行上下文。

这样内部作用域和外部作用域链接起来形成：`全局上下文`-> `执行上下文1` -> `执行上下文2`-> ... -> `执行上下文n`。形成了一个链式调用结构。

js引擎在做变量解析的时候，会从当前执行上下文一直向上查找，直到找到全局上下文。如果还没有找到该变量，就会认为变量未定义。

> 专业回答

JavaScript的作用域指的是变量的作用范围，内部作用域由函数的形参，实参，局部变量，函数构成，内部作用域和外部的作用域一层层的链接起来形成作用域链，当在在函数内部要访问一个变量的时候，首先查找自己的内部作用域有没有这个变量，如果没有就到这个对象的原型对象中去查找，还是没有的话，就到该作用域所在的作用域中找，直到到window所在的作用域，每个函数在声明的时候就默认有一个外部作用域的存在了。



## 闭包

要理解闭包，就得理解函数作用域。

所有的函数都有自己独立的函数作用域。闭包也是一个函数，而它「记住了周围发生了什么」。简单可以理解为：

一个函数体里定义了另一个函数。

一般运用到闭包的地方，一种用途是保留内存，让变量能够被外部函数读取；另一种是用来保护一些私有方法或属性。

保留内存的例子

```js
function makeAdder(x) {
	return function(y) {
		return x + y;
	}
}
var add2 = makeAdder(2);
var add5 = makerAdder(5);

add2(5); // 7
add5(5); // 10
```

这个例子就可以明显看出来，我们保留了第一个参数x的的内存，让他能够在后面你的函数一直使用。

保留内存的原理是是因为作用域链的依赖，导致内存不会被回收。

比如👆例子，makerAdder函数执行完之后，返回的函数依赖了makerAdder的参数，而它的返回函数又被别的对象add2、add5引用，这样垃圾回收期就不会把函数的占用的资源收回。



定义私有方法的例子

```js
function User() {
  var name = "anybody";
  function getName() {
    return name;
  }
  this.getName = getName;
}
var user = new User();
console.log(user.name )// 错误代码
console.log(user.getName()); // 私有化name属性，只能通过getName()进行访问
```

闭包导致的问题

由于闭包能够是变量的内存一直被占用，不被回收。所有会导致浏览器有内存泄露的风险。



## 原型/继承

要讲好原型，首先得说清楚`原型对象`、`构造函数`、`instance实例`的关系。

<img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-07-014355.png" alt="1.png" style="zoom:70%;" />

每一个对象都有一个`__proto__`属性，先称它为隐式`原型对象`。

每一个函数都有一个`prototype`属性，指向一个对象，称这个对象为`原型对象`。

构造函数是一个函数，所以构造函数有一个`prototype`指向一个对象，那么叫这个对象为构造函数的原型对象。

构造函数的原型对象有一个单独的`constructor`属性，他会指回到`构造函数`。

通过构造函数的创建的实例对象，它的`__proto__`属性，也会指向了这个构造函数的原型对象。

就是说

```js
对象实例.__proto__ === 函数.prototype
```



`__proto__`和`prototype`概念区分

`__proto__`其实指的是对象的[[prototype]]属性，而prototype是函数独有的属性。

那函数也是对象，它的`__proto__`指向什么呢？答案是Function.prototype。



经典问题：

> new关键字做了什么事情？

```
function _new() {
	var target = {}; // 创建实例对象
	const [constructor, ...args] = [...arguments];
	target.__proto__ = constructor.prototype; // 建立关系
	var result = constructor.apply(target, args); // 调用构造函数，将构造函数的属性赋值到target上
	if (result != null && (typeof result == 'object' || typeof result == 'function')) {
		return result;
	}
	return target;
}
```

> instanceOf 方法的内部原理

obj instanceOf Constructor

就是判断对象的原型链上是否出现了 构造函数这个原型。

<img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-14-081305.png" alt="img" style="zoom: 67%;" />

> 原型方法和属性方法的区别

构造函数的原型对象上的方法或者属性，每一个实例都会去共享。

但是构造函数内部的方法，每一个实例都会单独拥有一个。

```js
function C() {
  this.name = "keyang";
  this.sayHello = function() {
    return 'Hello' + name;
  }
}
C.prototype.sayHi = function () {
  return 'Hi' + name;
}

var c1 = new C();
var c2 = new C();

console.log(c1.sayHello == c2.sayHello); // false
console.log(c1.sayHi == c2.sayHi); //true
```



**继承**

java里继承的方式有2种，一种是通过实现接口，一种是通过extends来继承对象。

js的继承方式只有1种，通过原型来继承。

原型继承的原理是原型链。

因为构造函数的原型他本身也是一个对象，所以它也有自己的原型对象。它指向的是super构造函数的原型。一层层向上追溯，最终形成原型链。





**原型继承：**

思路：不需要定义一个严格意义上的构造函数，而是直接借助原型基于已有对象来创建新对象

```js
function extendsObject(o){
	function F(){};
  F.prototype = o;
  return new F();
}
```

ECMAScript5新增Object.create()方法来规范化了原型式继承:

```Object.create(*proto*[, *propertiesObject*])```;



**最常见的继承方式：组合继承**

将原型继承和构造函数继承组合在一起。

```js
var Foo=function(){
	// each Foo instance has a unique id
	this.id =Math.random();
}
Foo.prototype.doFoo = function(){ console.log("Foo!");}
var Bar = function(){
	this.something =5;
}
Bar.prototype = new Foo();

// 上面例子里，Bar 的实例都会有一个相同的id属性。因此,我们必须在每个实例上，调用父级构造函数。
var Bar= function(){
	Foo.call(this);// set unique `id` on `this`
	this.something =5;
}
// 区别在于，Object.create的对象，是没有id属性的
Bar.prototype = Object.create(Foo.prototype);
```



## Promise函数

promise函数主要是用来处理异步函数的。

早起的异步函数，都是通过callback进行回调。但是带来一个问题，代码难以阅读。

promise提供了一个promise().then().catch()的语法，再也不用 回调里面再回调了。



promise定义了3种状态，pendding、fullfiled、rejected。

promise构造函数接收一个Exeuctor函数，有两个参数为resolve、reject。

resolve将pendding状态变成fullfiled状态，并将异步函数返回的结果，通过参数传递出去。

reject将pendding状态变成rejected状态，可以将失败的原因通过参数传递出去。

>  [45道Promise面试题](https://juejin.im/post/5e58c618e51d4526ed66b5cf?utm_source=gold_browser_extension)



## 深浅拷贝

首先了解一下数据类型：

基本数据类型：boolean，string，null，undefined，number

引用数据类型：object，（Array，Date，Function，RegExp)

基础数据类型放在栈内存中

引用数据类型存放在堆内存中，引用这些数据的变量放在栈内存中。

**所以堆内存存放new出来的object对象**

**而栈内存存放一些基本的变量，以及对象的引用变量。**



**浅拷贝(shallow copy) vs 深拷贝(deep copy)**

对于基本类型来说，深浅拷贝都一致。

对于引用对象来说，==浅拷贝==只copy引用对象的指针，而==深拷贝==会将引用对象在堆内存的地址也复制一份。



**常见的浅拷贝操作**

```js
// 赋值操作
var arr = [1, 2, 3, '4'];
var arr2 = arr;




```



**常见深拷贝操作**

```
var arr = ['a', 'b', 'c'];
var arrCopy = arr.slice(0);
arrCopy[0] = 'test'
console.log(arr); // ["a", "b", "c"]
console.log(arrCopy); // ["test", "b", "c"]

```

这里有一个容易进入的误区。虽然Array.slice函数调用返回的数组内存地址和自身不相同。但是，如果数组里存放的是对象是引用类型的对象时，那么返回的数组里面每一个item的内存地址仍然是同一个。



**深拷贝的实现方式**

> 最简单的方式

```
function deepClone(obj) {
	return JSON.parse(JSON.stringify(obj));
}
```

最简单的方式有缺陷，他只能适用于扁平化的，且没有Function、Regex的数据结构。

```js
const obj1 = {
  key1: {
    name1: 'name1',
    value1: 'value1'
  },
  key2: [{
    name2: 'name2',
    value2:'value2'
  }],
  key3: function() {
    return 1;
  },
  key4: new RegExp(/regex/g),
}
const obj2 = deepCloe1(obj1);
console.log(obj2); // key3、key4的属性都无法正常copy
```



> 复杂方式

复杂的实现逻辑就是依赖于递归

```js
function deepClone2(obj) {
  let target;
  if (obj.constructor == Object) {
    target = {};
  } else if (obj.constructor == Array) {
    target = [];
  } else {
    target = obj;
  }
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      const value = obj[key];
      if (obj.constructor == Object || obj.constructor == Array) {
        target[key] = deepClone2(value);
      } else {
        target[key] = value;
      }
    }
  }
  return target;
}

let obj3 = deepClone2(obj1);
obj1.key1.name1 = 'dasfsaa';
console.log(obj1);
console.log(obj3);

```



## 事件循环机制/Event Loop

### 1.答题思路

1.1先说一下事件循环的基础知识点，哪些是宏任务，哪些是微任务。

1.2再说一下事件循环的一个流程，边说边画图。

1.3说一下async/await，promise，setTimeout，setInterval执行顺序，以及原理。

1.4可以再介绍一下nodejs的循环机制。

### 2.浏览器中的事件循环

js代码执行过程中，除了通过`调用栈`来控制函数执行顺序外，还通过`循环机制`来进行控制。每一个线程只有唯一的事件循环，但是会有多个任务队列。

任务队列里的任务分为：宏任务、微任务。同样也区分宏任务队列和微任务队列。

> 宏任务

- script(整体代码)
- setTimeout
- setInterval
- setImmediate
- I/O

> 微任务

- Promise
- Async/Await

> 事件循环流程

主线程从上往下执行代码。遇到函数时，会判断函数是否为同步任务。如果是同步任务会进入执行堆栈，遇到异步任务，会根据任务类型，将回调函数放入不同的任务队列中。

当执行堆栈的调用结束时，会去判断`微队列`中是否有任务。如果有，就会将`微任务队列`里的异步任务加入到执行队列中进行处理。

==如果微任务执行过程中产生了微任务，会继续放到当前微队列里。==

直到微队列里任务都执行完成，才会去执行下一个宏任务。

![img](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-07-090006.png)

### 3.async/await的原理以及执行顺序

> async是*generator函数的语法糖，那generator是什么？

generator函数是一个状态机，执行genetator函数会返回一个遍历对象，可以通过next()方法区遍历generator内部的每个状态。

```js
function* generator1() {
  yield 'hello';
  yield 'world';
  return 'ending';
}
```

```js
var hw = generator1();
hw.next()// { value: 'hello', done: false }
hw.next()// { value: 'world', done: false }
hw.next()// { value: 'ending', done: true }
hw.next()// { value: undefined, done: true }
```



> generator函数暂停、恢复原理。

协程：协程比线程更轻量级，允许执行被挂起与被恢复。线程之间会抢夺资源，但是协程，它本质上还是在一个线程上进行执行，他们之间是相互合作的，不会产生竞争。可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。

假设流程：

1. 协程`A`开始执行
2. 协程`A`执行到某个阶段，进入暂停，执行权转移到协程`B`
3. 协程`B`执行完成或暂停，将执行权交还`A`
4. 协程`A`恢复执行

A、B的执行有点像多线程，但协程的特点在于是一个线程执行，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。

第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。



> 执行器的概念

generator函数的自动执行依赖于`执行器`。执行器的要求是：能够执行异步函数，当异步函数返回的时候，能自动交回执行权。可以有两种实现方式：

1.回调函数。

2.Promise对象

```
function run(gen) {
  var g = gen();
  function next() {
    var result = g.next();
    if (result.done) {
      return result.value;
    }
    return new Promise(((resolve, reject) => {
      resolve();
    })).then(() => {
      next();
    })
  }
  next();
}
```

> async函数干了什么？

假设async 后面接了一个函数，那这个函数的返回值，会被封装为一个Promise对象并返回。

```js
async function f1() {
  return '1';
}

function f2() {
  return 2;
}

console.log(f1());
console.log(Promise.resolve('1'));
console.log(new Promise(resolve => {
  resolve('1');
}));
console.log(f2());
```

打印结果

```js
Promise {<resolved>: "1"}
Promise {<resolved>: "1"}
Promise {<resolved>: "1"}
2
```

从打印结果可以看出来，async的函数，返回的是一个立即执行的Promise函数。



> await 等待的执行顺序

await执行分两种情况，一种是await后面函数执行的结果返回的是promise对象，一种返回的是普通对象。

无论是哪种情况，程序遇到await语句时，都会先执行函数方法，然后跳出async函数，去执行async函数外的代码。等外部代码执行完（当前调用栈清空后），再跳回到async函数内部。这时，await 后面的代码返回：

- 如果返回的是promise对象

  会等到这个Promise对象变为fullfiled状态，将promise的代码作为await表达式的执行结果。

  await 语句的下面一行，会在promise之后，被加入微任务队列。

  也就是说，这个过程有2个微任务产生。

- 返回普通对象

  如果是普通的对象，会直接返回一个立即执行的Promise函数，await 语句的下一行代码，会直接被注册为微任务。

执行顺序：await后面的接的函数执行之后后，会跳出async函数。执行其他代码（模式就类似于协程A,B的切换）。当其他代码执行完毕后，再回到async函数去执行剩下的代码。然后await下面的一行代码会被注册到微任务队列里。

结合例子来看：

```js
console.log('script start') // 1.执行代码，输出script start。

async function async1() { 
  await async2();          // 3.调用async2(), 输出async2 end。跳出async1函数
  console.log('async1 end') // 8.当前微任务队列执行完毕。执行权回到async1. 执行await后面的语句,实际上会产生一个promise返回. 输出async1 end

  
}
async function async2() {
  console.log('async2 end'); 
}
async1() // 2.执行async1(),

setTimeout(function() { // 4.跳出async1函数，执行setTimeout，产生一个宏任务
  console.log('setTimeout') // 9 .输出setTimeout
}, 0)

new Promise(resolve => { // 5.执行Promise，输出Promise
  console.log('Promise')
  resolve()
})
  .then(function() { // 7.当前宏任务执行完毕)，开始执行当前宏任务产生的微任务队列，输出promise1，
    console.log('promise1') 
  })
  .then(function() { // 7.1该微任务遇到then，产生一个新的微任务. 执行产生的微任务，输出promise2,
    console.log('promise2')
  })

console.log('script end') // 6.继续执行代码，输出script end
```

<img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-03-141113.png" alt="image-20200303221113367" style="zoom:50%;" />



## 函数式编程

> https://juejin.im/post/5d70e25de51d453c11684cc4#heading-26

函数式编程有几个重点

**1.函数作为一等公民，可以将函数做为另一个函数的参数，传入的函数先执行。**

**2.尽量使用纯函数（函数不依赖外部变量，也不修改变量，没有副作用），相同输入得到相同输出**

存函数的好处：

- 可以缓存

- 可移植性／自文档化

- 可测试性

  这里我联想到了实际开发过程中，如果在代码里引用了一个外部变量，那么函数就变得不透明，不利于单元测试。

- 合理性

**3.柯里化**

将多参函数，转化为多个单参函数去执行调用。

当传递一个参数去调用函数后，就返回一个新函数去处理剩余的参数。

```js
// 原始
function add(x, y) {
	return x + y; 
}

// 柯里化
var add = function(x) {
  return function(y) {
    return x + y;
  };
};

var increment = add(1);
var addTen = add(10);

increment(2); // 3
addTen(2); // 12
```

柯里化的好处：

可以传给函数一些参数，就能得到一个新的函数。

https://ramda.cn/





## WebWorker

js实现多线程操作的一种方案。

将一些复杂耗时的任务放在webworker中，通过message消息传递和主线程进行交互。从而避免主线程阻塞，提升web响应速度。



**使用限制**

js必须是同源的文件，而且必须是从网络进行加载

可以发送ajax请求，但是不能进行DOM的操作

使用完应该关闭webworker



**常用一些功能**

注册webWorker

主线程向webworker发送消息

worker通过监听事件，来处理消息。

webworker向主线程发送消息

主线程监听事件，处理消息

webworker加载脚本, 通过importScripts();



参考[WebWorker](./WebWorker)



## ServiceWorker

serviceWorker最主要的作用是用来做离线web应用的。它是ApplicationCache的替代方案。

他可以对应用的资源进行细粒度的缓存，还可以去监听web应用的各种事件（请求fetch事件、message事件等）。

SW和WebWorker有比较多的相似点：

- 同样是利用了浏览器的多线程，不会阻塞web应用中的主线程。

- 只能加载同源的js代码，而且限制更多，只能是https的或者localhost环境。
- 都是基于事件驱动，通过事件与主线程进行消息传递。
- 都无法对DOM进行操作。而且ServiceWorker是有一个单独的作用域的概念，或者成为scope



使用说明

serviceWorker声明周期如下：

![service worker生命周期](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-08-021853.png)

客户端发起注册register

注册完成后，被浏览器解析parsed，但是还未安装

installiing后触发==installed事件==，但是有可能存在历史版本的webworker，所以处于waiting状态

激活后触发==actiived事件==

参考[ServiceWorker](./ServiceWorker)





**2.javascript的事件流模式**

事件捕捉，目标阶段，事件冒泡

原始事件模型，捕获型事件模型，冒泡事件模型，

原始事件模型就是ele.onclick=function(){}这种类型的事件模型

冒泡事件模型是指事件从事件的发生地（目标元素），一直向上传递，直到document，

捕获型则恰好相反，事件是从document向下传递，直到事件的发生地（目标元素）

**3.冒泡与捕获：它们的定义，它们的区别，如何阻止冒泡？**

冒泡：事件从最下往上传递

捕获：事件从上往下传递，直到被目标捕获到。

阻止事件冒泡：e.stopPropagation() window.event.cancelBubble=true



**6.如何判断一个对象是方法？**

typeof object === 'function'

object.toString()

**7.**页面加载和渲染的过程

IE下载的顺序是从上到下，渲染的顺序也是从上到下，下载和渲染是同时进行，

如果有嵌入式的文件，会启用单独的链接进行下载。

css下载完成之后，会对所有的元素进行重新解析一遍。

js代码加载的时候，会停止网页的渲染和其他的下载。



**10.jquery的live和bind区别**

live和bind的功能相同，都是用来绑定事件。

bind方法只能给当前存在的元素绑定事件，对于事后采用JS等方式新生成的元素无效

live则基于事件委托机制，将事件绑定到dom根节点，所以创建新的元素后，依然能触发事件。

已经被on代替了。

**11.$('document').ready方法的实现机制**

监听DOMContentLoaded事件，当dom节点加载完全后，触发该事件。

onload方法是要等页面所有的元素都加载完成。。



**13. 浏览器的垃圾回收机制**

垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，内存泄露和浏览器实现的垃圾回收机制息息相关， 而浏览器实现标识无用变量的策略主要有下两个方法：

**14. 模块化的理解**

前端模块话就是把复杂的文件分成一个个独立的模块，比如js文件，分成独立的模块之后有利于代码的重用和维护，但是这样又会引来模块与模块之间的依赖问题，所以就有了CommonJS、AMD、CMD规范

**15.同源策略**

同源策略是浏览器有一个很重要的概念。所谓同源是指，域名，协议，端口相同。不同源的客户端脚本(javascript、ActionScript)在没明确授权的情况下，不能读写对方的资源。简单的来说，浏览器允许包含在页面A的脚本访问第二个页面B的数据资源，这一切是建立在A和B页面是同源的基础上。

**16.改变函数内部this指针的指向函数**

call和apply，假设要改变fn函数内部的this的指向，指向obj，那么可以fn.call(obj);或者fn.apply(obj);那么问题来了，call和apply的区别是什么，其是call和apply的区别在于参数，他们两个的第一个参数都是一样的，表示调用该函数的对象，apply的第二个参数是数组，是[arg1,arg2,arg3]这种形式，而call是arg1,arg2,arg3这样的形式。还有一个bind函数，

var bar=fn.bind(obj);那么fn中的this就指向obj对象了，bind函数返回新的函数，这个函数内的this指针指向obj对象。





