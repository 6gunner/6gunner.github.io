## 前端工作总结

## 大纲

## [框架整理沉淀](./前端工作总结-框架沉淀)



## [架构理解](./前端工作总结-架构理解)



## [解决方案](./前端工作总结-解决方案)



## 技术学习

### [React学习](./React学习)



### [Canvas学习](../Canvas学习)

### Next.js学习

> 一种服务端渲染的框架；功能比较简单，配置也很简单，不需要依赖别的服务。
>
> 内部应该整合了webpack和babel，可以支持热部署，以及es6



unzip

```javascript
function unzip(b64Data){
    var strData = atob(b64Data);
    // Convert binary string to character-number array
    var charData  = strData.split('').map(function(x){return x.charCodeAt(0);});
    // Turn number array into byte-array
    var binData   = new Uint8Array(charData);
    // // unzip
    var data    = pako.inflate(binData);
    // However, the Uint8Array has a limit of buffer size. It will crashes on big buffers, the rude max size is 246300 and sometimes it not correct in different browser.
    // Convert gunzipped byteArray back to ascii string:
  //	下面这个方法会报超过最大调用次数，造成堆溢出。
    // strData   = String.fromCharCode.apply(null, new Uint16Array(data));
    strData = new TextDecoder("utf-8").decode(data);
    return strData;
}
```

zip



### [Webpack学习](./Webpack)



### [Dva学习](./Dva)



### Yarn学习

yarn的好处在于，他不仅可以和npm一样对package进行管理，而且可以保证在不同环境上，项目里所用到的依赖都是一致的。 

这依赖于yarn.lock这个文件，它应该被提交到git上进行版本控制。

除此之外，yarn还增加了一些缓存的功能，可以比npm更稳定，下载速度更快；

> #### 依赖版本



> #### 依赖类型

除了常见的devDependencies、dependencies之外，今天了解到了一些其他类型的依赖：

**`peerDependencies`**

这是“上级依赖”，一种特殊的依赖，在发布包的时候需要。有这种依赖意味着安装此包的用户也需要和包同样的依赖。 

**`optionalDependencies`**

可选依赖。即使安装失败，yarn也会认为整个过程是成功的；

**`bundledDependencies`**

"打包依赖"。打包的时候，会将这里的依赖项一起打包进来。

例如：

```
"name": "awesome-web-framework",
"version": "1.0.0",
"bundledDependencies": [
    'renderized', 'super-streams'
   ]
```

`npm pack`会将`renderized `和`super-streams`放入生成的包**awesome-web-framework-1.0.0.tgz**中，并且在`npm install awesome-web-framework-1.0.0.tgz`时，`renderized `和`super-streams`也会被一同安装。



### [WebWorker学习](./WebWorker)



### [单元测试](../单元测试.md)



### Mock数据

在项目开发里，一般前后端一起开发，前端没有接口可以调用。想要写调用接口，就得用mock的方式来实现。

#### 通过webpack配置

结合`webpack-api-mocker` 和 `webpack-dev-server`

首先在webpackDevServer.before参数里增加配置：

```js
const apiMocker = require("webpack-api-mocker");

before(app) {
  // 读取mock/index.js文件
  apiMocker(app, path.resolve('../mock/index.js'), {
    changeHost: true,
	}),
}
```

mock/index.js

模拟了两个接口`assets/data.json`、`assets/depth.json`

```js
const fs = require('fs');

mnodule.exports = {
	'GET /assets/data.json': (req, res) => {
		return res.json(JSON.parse(fs.readFileSync('./src/assets/data.json', 'utf8')));
	},

	'GET /assets/depth.json': (req, res) => {
		return res.json(JSON.parse(fs.readFileSync('./src/assets/depth.json', 'utf8')));
	}
}
```



一般我们喜欢把mock的文件按业务去划分，如果有多个mock文件，最好写一个通用的js文件，避免重复写配置：

```js
const fs = require('fs');
const path = require('path')
const mockPath = path.join(__dirname + '/mock');

// 存放文件路径
const mockFiles = [];
fs.readdirSync(mockPath).forEach(file => {
	mockFiles.push(path.resolve('./mock/'+file));
})
console.log(mockFiles);
module.exports=mockFiles;
```



#### 在vue-cli里配置mock的服务

其实在webpack里配置mockjs也很简单，只是把配置的地方换成了vue.config.js里。

![image-20200415203031805](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-04-15-123032.png)



mock.js

```js
const fs = require('fs');
const path = require('path')
const mockPath = path.join(__dirname + '/mock');

const mockFiles = [];
fs.readdirSync(mockPath).forEach(file => {
	mockFiles.push(path.resolve('./mock/'+file));
})
console.log(mockFiles);
module.exports=mockFiles;

```



vue.config.js

```js
devServer: {
    open: true,
    before(app) {
      // apiMocker(app, path.resolve('./mock/user.js'), {
      //   changeHost: true,
      // })
      apiMocker(app, mockFiles, {
        changeHost: true,
      })
    }
}
```







