# 框架沉淀

## Vue全家桶封装

源码地址：https://github.com/6gunner/vue-basic-framework/tree/master/src

###v1版本 

> 时间：2019.7.21日

- 加入了axios以及一些常用的拦截器。拦截器业务根据实际项目业务来写；
- 加入router和store。一般项目都会用到
- 加了组件的懒加载; 需要引入babel的插件

其他组件根据后面需要再考虑加入。





## 二次开发组件

之前在给公司做项目的时候，基于vue + element封装了一些项目的插件。

组件封装好了，但是怎么把他提取出来给小伙伴们一起使用就成了一个难题。这边经过一番研究，终于找到了一个最优的打包配置，记录一下。

> 首先看一下webpack的配置

不同于app的打包，library的打包有两个概念：`externals` 、`暴露library`

[externals](./Webpack#externals)把一些依赖不打包到bundle里，而是作为外部依赖项。

[output](./Webpack#output)用来设置打包library被引用时的，变量的引用方式。

```js
// 将library打包出去
const webpack = require("webpack");
const {CleanWebpackPlugin} = require('clean-webpack-plugin');

const vueLoaderConfig = require('./vue-loader.conf');
const path = require('path');
const version = require("./../package.json").version;

const utils = require('./utils')

module.exports = {
  // mode: 'production',
  entry: path.join(__dirname, '..', "src/index.js"),
  output: {
    path: path.join(__dirname, '..', 'dist'),
    filename: "gs-comps.js",
    library: "GsComps",
    libraryTarget: "umd",
  },
  resolve: {
    extensions: ['.js', '.vue'],
    alias: {
      '@': path.resolve('src'),
    }
  },
  externals: {
    underscore: {
      commonjs: 'underscore',
      commonjs2: 'underscore',
      amd: 'underscore',
      root: '_'
    },
    vue: 'Vue',
    vuex: 'vuex',
    'element-ui': {
      commonjs: 'element-ui',
      commonjs2: 'element-ui',
    },
    'element-ui/src/transitions/collapse-transition': 'element-ui/lib/transitions/collapse-transition',
    'element-ui/src/mixins/emitter': 'element-ui/lib/mixins/emitter',
    'element-ui/src/locale': 'element-ui/lib/locale',

  },
  module: {
    rules: [
      ...utils.styleLoaders({sourceMap: true, extract: true}),
      {
        test: /\.vue$/,
        loader: 'vue-loader',
        options: vueLoaderConfig,
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: "babel-loader",
      }
    ]
  },
  plugins: [
    new CleanWebpackPlugin(),
    new webpack.DefinePlugin({
      "process.env": {
        NODE_ENV: '"production"'
      },
      VERSION: JSON.stringify(require("../package.json").version)
    }),
    new webpack.LoaderOptionsPlugin({
      minimize: true,
      debug: false
    }),
    new webpack.optimize.UglifyJsPlugin({
      compress: {
        warnings: false
      },
      sourceMap: true,
      comments: false,
      beautify: false
    }),
  ]
};

```



> 然后看一下封装library的方式

```js
// library index.js
import EasySelect from './components/EasySelect'
import EasyTable from './components/EasyTable'
import EasyInput from './components/EasyInput'
import VirtualList from './components/VirtualList'
import VirtualTree from './components/VirtualTree'

const components = [
  EasySelect,
  EasyTable,
  EasyInput,
  VirtualList,
  VirtualTree
]

const install = function (Vue) {
  components.forEach(component => {
    Vue.component(component.name, component)
  })
}

if (typeof window !== 'undefined' && window.Vue) {
  install(window.Vue)
}

export default {
  install,
 	EasySelect,
  EasyTable,
  EasyInput,
  VirtualList,
  VirtualTree
}
```

组件的indexjs

```js
// 引入组件
import EasyTable from './EasyTable'
// 写install方法
EasyTable.install = function (Vue) {
  Vue.component(EasyTable.name, EasyTable)
}
export default EasyTable
```



> 测试过后，发布library

```js
"main": "dist/gs-comps.js" // 设置package.json的main入口，用来发布
```

```shell
npm publish
```



## WS连接封装

> 背景

因为做的是交易相关的业务，所以前端里会用到一些ws的连接来处理实时数据的推送。

比如行情价格变动、实时成交的变动等等。



> 方案设计

因为项目里用到了vuex，遵循flux的思想，ws推送过来的数据也应该认为是数据系统自身状态，所以需要维护到state里。那就需要把ws和vuex结合。

但是vue-vuex提供的actions和mutations不太适合做ws的请求处理。因为ws应该是全局的，而项目里用vuex时，是把state按照业务划分了不同namespace。不可能每一个业务我要重新去写一遍ws连接、订阅的操作，代码会重复冗余，而且耦合性很强。

经过思考，我把ws封装成一个单独的plugin，然后在项目全局使用这个plugin。

通过这个plugin，将vuex的store对象和ws对象结合在一起。ws的订阅操作通过vm.$socket对象，在各自的业务组件里进行操作。



> 源码分析

```js
import WS from './ws';

export default {
  install(Vue, url, options = {}) {
    Vue.prototype.$socket = new WS({
      ...options,
      url,
    });
  }
}
```

首先，plugins会在`Vue.prototype`上添加一个$sockets对象，用来存放ws实例。



```js
const defaultOptions = {
  reconnect: true,
  reconnectDelay: 1000,
  reconnectTry: 5
}
const WS_EVENTS = ['onmessage', 'onclose', 'onerror', 'onopen']

function mergeOptions (options) {
  return {
    ...defaultOptions,
    ...options,
  }
}

function isDefine (obj) {
  return obj && obj != undefined && obj != null
}

let reconnectTry = 0
let reconnectTimeout = null

// 缓存的订阅
const subscriptions = {}

class WS {
  constructor (props) {
    this.$opts = mergeOptions(props)
    this.$store = props.store
    this._init()
  }

  _init () {
    if (!this.connected) {
      if (isDefine(this._ws)) {
        const { readyState } = this._ws
        if (readyState == 0) {
          console.warn('ws正在连接')
        }
      } else {
        this.initConnection()
      }
    } else {
      console.warn('ws已经连接，请不要重复建立连接')
    }
  }

  initConnection () {
    const options = this.$opts
    const ws = new WebSocket(options.url)
    this._ws = ws
    this.initEvent()
  }

  initEvent () {
    const { _ws } = this
    WS_EVENTS.forEach(eventKey => {
      _ws[eventKey] = (e) => {
        this.handleEventMessage(e, eventKey)
      }
    })
  }

  // 处理消息
  handleEventMessage (e, eventKey) {
    const options = this.$opts
    const store = this.$store
    if (store) {
      passToStore(`SOCKET_${eventKey}`, e, store)
    }
    switch (eventKey) {
      case 'onopen':
        this.connected = true
        reconnectTry = 0
        Object.keys(subscriptions).forEach(key => {
          this.sendObj(subscriptions[key])
        })
        break
      case 'onclose', 'onerror':
        this.connected = false
        this._ws = null
        console.warn('断开连接，错误码: = ' + e.code)
        if (options.reconnect && e.code !== 1000) {
          // 断开重连
          this.tryReconnect()
        }
        break
    }
  }

  tryReconnect () {
    const options = this.$opts
    if (options.reconnectTry > reconnectTry) {
      reconnectTry += 1
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout)
        reconnectTimeout = setTimeout(() => {
          this.initConnection()
        }, options.reconnectDelay)
      } else {
        reconnectTimeout = setTimeout(() => {
          this.initConnection()
        }, 0)
      }
    } else {
      console.error('重连失败，请检查ws服务端')
      clearTimeout(reconnectTimeout)
      reconnectTimeout = null
    }
  }

  sendObj (obj) {
    // 0 正在连接
    // 1 已经连接
    // 2 正在关闭
    // 3 已经关闭
    const send = this._ws.send;
    if (this._ws.readyState !== 1) {
      // 缓存所有请求,可以重连再发送
      if (isDefine(obj.api) && isDefine(obj.topic)) {
        const key = `${obj.api}-${obj.topic}`
        subscriptions[key] = obj
      }
    } else {
      send(JSON.stringify(obj))
    }
  }
}

// 传递给store函数
function passToStore (eventName, payload, store) {
  if (!eventName.startsWith('SOCKET_')) {
    return
  }
  for (const namespaced in store._mutations) {
    const mutation = namespaced.split('/').pop()
    if (mutation === eventName.toUpperCase()) {
      store.commit(namespaced, payload)
    }
  }

  for (const namespaced in store._actions) {
    const action = namespaced.split('/').pop()
    if (action.startsWith('socket_')) {
      const camelcased = `socket_${payload.toLowerCase()}`
        .replace('SOCKET_', '')
        .replace(/[\W\s_]+(\w)/g, (match, p1) => p1.toUpperCase())
      if (action === camelcased) {
        store.dispatch(namespaced, payload)
      }
    }
  }
}

export default WS

```

WS是我经过封装过的websocket对象。集成了断开重连、消息重发、以及事件转发的功能。

**断开重连**很简单，就不说了。

**消息重发**就是将send方法又包装一层，用一个全局对象去缓存发送的消息。这里的唯一key我是根据我们的业务，定成了``${obj.api}-${obj.topic}``，也可以从外面传进来。

然后当ws断开重连时，把这些缓存的消息，重新再发送一遍。

**事件消息转发**是这个插件的核心，就是用来把ws的消息，转发到vuex的store上。各个store可以通过mutations去接受消息。

```js
import Vuex from 'vuex';
import Vue from 'vue'

Vue.use(Vuex);

const ws = {
  state: {
    detail: {},
  },
  mutations: {
    SOCKET_ONMESSAGE(state, {
      data
    }) {
      console.log('接收到消息');
      // 可以去做任何state的更新操作了
      const jsonObj = JSON.parse(data);
      const respApi = jsonObj.api;
      const respData = jsonObj.data;
      if (respApi == 'quote.detail' && respData) {
        state.detail = respData[0];
      }
    }
  }
}
const store = new Vuex.Store({
  ...ws,
})

export default store;

```



组件里使用

```vue
<template>
    <div>
        {{detail.close}}
    </div>
</template>
<script>

  import _ from 'underscore'
  import { mapState } from 'vuex'

  export default {
    data () {
      return {}
    },
    computed: {
      // 读取消息
      ...mapState({
        detail: state => state.detail,
      }),
    },
    created () {
      // 订阅
      this.$socket.sendObj({
        type: 0,
        id: _.uniqueId(),
        api: 'quote.detail',
        topic: 'cmb19.btcusdt'
      })
    }
  }
</script>

```



## ajax请求封装

> 背景

每个项目都离不开ajax请求，牵扯到后端请求，就需要附带一些参数处理、错误判断、超时机制。



这里放个处理超时机制的请求代码，核心逻辑是：在请求的同时，触发一个定时任务。两者是竞争的关系，如果定时任务先回来，就任务请求失败，不再等待请求的返回。

```

let timeout = 15000; // 默认15秒超时
let abort: any = null;
let timer: any = null;
  const abortPromise = new Promise((resolve, reject) => {
    abort = () => {
      return reject(`请求超时: ${url}`);
    };
  });
  const promise: any = Promise.race([
    abortPromise,
    fetch(`${url}`, options){}
)]
  Object.defineProperty(promise, "timeout", {
    set: ts => {
      if ((ts = +ts)) { // 将ts强转为number
        timeout = ts;
        timer = setTimeout(() => {
          abort("请求超时");
        }, timeout);
      }
    },
    get: () => {
      return timeout;
    }
  });
  promise.timeout = options.timeout || timeout;


```





## 通用UI组件设计

搭建项目的时候，经常发现一些样式时可以复用的，所以这里总结一下我们项目中用到的通用UI

### 整体布局篇



### 页面布局篇

#### 详情页面

简介：详情页面一般组成分为2部分，上面部分是label-value形式的描述信息。下面内容不固定，可以是table表格，也可能是一些tab页面。

示例：![image-20190829110153309](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-18-031428.png)

