# 解决方案

## 1.前端可配置化logo的设计方案

> 这个方案是在工作当中运用到的最小化、最简易版的设计方案

### 需求背景

给公司做了一个基于sass服务的运营——管理端界面。因为是给客户使用的，有一些客户希望能用自己的公司的logo、海报背景等等。相当于个性化定制。

所以需要把一些配置提炼出来，作为可配置化的功能。



### 解决方案

> 一、方案思路

首先定义一个配置文件，可以是.json的后缀，也可以是.js的后缀。配置的内容主要就是需要配置的各种logo、title等信息。

通过后台的相关接口，知道引入哪一个配置文件。

根据接口，引入这个配置文件，可以是通过ajax来请求这个json，又或者是动态import这个js文件，取决于你的文件格式。



> 二、关键代码

**配置文件格式**

```json
{
  "default": {
    "loginBg": "/static/img/default/login-bg.png",
    "footerLogo": "/static/img/default/footer-logo.png",
    "logo": "/static/img/default/logo.png",
    "welcome": "/static/img/default/welcome-bg.png",
    "favicon": "/static/img/default/favicon.ico"
  }
}

```

这里就简单举个例子，“default”就是配置的唯一id，不同的配置会分配一个id给他。

default下面的key就是配置项。



**设置为全局变量**

```html
 <% if (process.env.NODE_ENV === 'production') { %>
      window.__config = {
        #if ($third_type)
          thirdType: '<%= "$!third_type" %>',
        #else
          thirdType: 'default',
        #end
        #if ($title)
          title: '<%= "$!title" %>',
        #else
          title: '管理平台',
        #end
      }
   <% } %>
```

这里其实用到了模板语言，` <% if (process.env.NODE_ENV === 'production') { %>`是ejs的语法。node打包编译完成后，需要将它放到服务端，从服务端直接那边返回页面。

这段话的意思是，从服务端渲染的时候，读取third_type的变量信息，然后直接设置为全局window.__config.thirdType这个变量。 这个变量的意思就是具体需要用到哪个配置文件的意思。



**view使用**

先读取配置信息

```js
import images from '../assets/img/images.json';
// 中间省略
...
// vue的data对象
data() {
  return {
		images: images[window.__config.thirdType]
  }
}
```

再在用到的地方，使用data变量来替换。

```jsx
 <a href="#" class="header-logo">
  用到图片的地方
  <img :src="images.logo" class="header-logo-img">
 </a>
```



> 三、方案的优缺点

**优点**：

1. 最小化的解决了个性化配置的问题。只需要后台配合域名或者机构号，来设置好thirdType参数，再返回给前端即可。
2. 从页面渲染加载时，就可以确认thirdType，不会出现闪屏的问题；

**缺点**：

1. 配置不灵活，需要手动写配置文件，而且替换图片也需要开发人员进行打包升级，不能做到立即生效；



> 四、待改进点

1. 因为我们产品以及后台都没有规划好这块的功能设计，所以其实最大的改进就是将这些配置本身就做成功能。
2. 其次，import json文件，实际上会把json代码打包到整个代码里面去，导致文件臃肿。最好是从服务端加载。
3. 图片都是本地图片，最好也可以从远端读取图片，减少打包的大小；



> 五、源码地址





## 2.nodejs进行服务的转发代理

### 需求背景





## 3.实现一个大文件上传

### 需求背景

本来是在做一个运维工具，用来测试我们对外的user api接口。由于是nodejs写的，而node对FormData的支持不是很好，所以提交文件就很麻烦。

后面衍生出了两种问题：

1、怎么用nodejs去模拟浏览器的request去上传文件

2、怎么进行大文件上传



### 解决方案

> 问题分析

首先，在http请求里，如果是普通的form表单提交，会以`application/x-www-form-urlencoded`的形式传输. 但如果是传输文件的格式,需要设置header为是`multipart/form-data`. 

来看一个文件上传的http报文：

```http
POST /file/v1/upload HTTP/1.1
Host: localhost:8081
Content-Length: 100460
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW

----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="file"; filename="v2-f7139f8763b996ebfa28486e160f6378_r.jpg"
Content-Type: image/jpeg

(data)
----WebKitFormBoundary7MA4YWxkTrZu0gW--

```

上面4行是request的headers

中间有一行空行，空行下面是FormData

可以看出来：FormData是以`----WebKitFormBoundary${random_str}`开始，以`----WebKitFormBoundary${random_str}--`结尾。并且这个值和headers里面Content-Type的boundary一致。



所以第一个问题很好解决，只需要模拟这种请求的格式，应该就能发送一个文件到服务端。

> 实现代码：

```js
const http = require('http');
const fs = require('fs');

var boundary = '001373272605314343826714';

const filePath = '/Users/keyang/Desktop/v2-f7139f8763b996ebfa28486e160f6378_r.jpg';

const options = {
	'method': 'POST',
	'hostname': 'localhost',
	'port': 61470,
	'path': '/file/v1/upload',
	'headers': {
		'Content-Type': 'multipart/form-data; boundary=------------------------WebKitFormBoundary7MA4YWxkTrZu0gW'
	}
}


const req = http.request(options, function (res) {
	var chunks = [];

	res.on("data", function (chunk) {
		chunks.push(chunk);
	});
	res.on("end", function (chunk) {
		var body = Buffer.concat(chunks);
		console.log(body.toString());
	});
	res.on("error", function (error) {
		console.error(error);
	});
});

const postData = '------------------------' + boundary + '\r\n'
	+ 'Content-Disposition:form-data; name="file"; filename="v2-f7139f8763b996ebfa28486e160f6378_r.jpg"\r\n'
	+ 'Content-Type: image/jpeg\r\n\r\n'
const endData = '\r\n------------------------' + boundary + '--\r\n';


fs.stat(filePath, (err, stats) => {
	req.setHeader('Content-Type', 'multipart/form-data; boundary=------------------------' + boundary);
	req.setHeader('Content-Length', Buffer.byteLength(postData) + Buffer.byteLength(endData) + stats.size);
	req.write(postData);
	req.write(fs.readFileSync(filePath))
	req.end(endData);
})
```





第二部分上传大文件的思路：

1.客户端分片；使用Blob.prototype.slice方法。将大文件分成小的文件，确保每个文件不会超过1048576字节的大小。

2.服务端合并：先接受客户端传输的分片文件，按顺序保存。上传完成后，利用对分片传输的文件进行合并。



分片文件的发送大致如下：

```html
POST /test.html HTTP/1.1
Host: example.org
Content-Type: multipart/form-data;boundary="boundary"

--boundary
Content-Disposition: form-data; name="chunk"; filename="blob"
Content-Type: application/octet-stream

(binary)
--boundary
Content-Disposition: form-data; name="hash"

value1
--boundary
Content-Disposition: form-data; name="filename"

value2
--boundary--
```

利用hash值来标识文件顺序，利用chunk来传输文件



![image-20200113154533606](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-18-030935.png)



> 代码实现

```java
# interview-learn
//https://juejin.im/post/5dff8a26e51d4558105420ed?utm_source=gold_browser_extension#heading-13
```



## 4.前端Excel导出数据功能

有一些报表的数据，客户希望通过导出成为excel的方式去查看。而这些数据都已经通过后台接口返回回来了，那么单纯的通过前端就可以进行excel导出功能。

> 使用说明

```js
// 声明导出excel的header名称
const tHeader = [this.$t('table.initDate'), this.$t('table.coName'), this.$t('table.pdName'), this.$t('table.assetAccoName'), this.$t('table.exchgroupName'), this.$t('table.exchName'), this.$t('table.currencyPair'), this.$t('table.orderDir'), this.$t('table.strikeAVGPrice'), this.$t('table.strikeQty'), this.$t('table.strikeAmount'), this.$t('table.fee')];
// 处理数据
const filterVal = ['init_date', 'co_name', 'pd_name', 'asset_acco_name', 'exch_group_name', 'exch_name', 'stock_name', 'order_dir', 'strike_aver_price', 'bs_crncy_strike_qty', 'qt_crncy_strike_qty', 'strike_fee'];
const list = this.tableData;
const data = list.map(item => filterVal.map((key) => {
  if (key === 'strike_aver_price' || key === 'bs_crncy_strike_qty' || key === 'qt_crncy_strike_qty' || key === 'strike_fee') {
    return format('number', '$0', item[key]);
  }
  if (key === 'order_dir') {
    return this.translateDict(key, item[key]);
  }
  return item[key];
}));
const currentDate = new Date();
const excelName = this.$t('table.exchgroupStrike') + currentDate.format('yyyyMMdd');
const excelSheetName = this.$t('table.exchgroupStrike');
// 交给工具方法去导出数据
export_json_to_excel(tHeader, data, excelSheetName, excelName);
```



## 5.前端实现大文件下载

### 需求背景

火币项目里，有一个导出数据的需求。数据量特别大，按照传统做法，会很卡顿。后台如果是把所有数据查询回来在一次性返回，压力也很大。

### 解决方案

和后台商定，采用文件流的传输模式。后台直接以stream的形式传输数据，前端采用stream模式下载。

来分析一下这个response headers: 

![image-20200318115358676](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-18-035546.png)



第一点：`application/octet-stream`

`content-type`是`application/otcet-stream`，查看MDN的文档可以知道:

这是应用程序文件的默认值。意思是 *未知的应用程序文件 ，*浏览器一般不会自动执行或询问执行。浏览器会像对待 设置了HTTP头[`Content-Disposition`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition) 值为 `attachment` 的文件一样来对待这类文件。



第二点：`content-disposition`

`attachment`（意味着消息体应该被下载到本地；大多数浏览器会呈现一个“保存为”的对话框，将`filename`的值预填为下载后的文件名，假如它存在的话）。



前端核心代码，主要是处理的逻辑：

```js
// 核心代码
axios.post(url, {
	data: params,
	responseType: 'arraybuffer',
}).then(resp => {
	const contentDisposition = decodeURI(resp.headers['content-disposition']);
	const fileName = contentDisposition.split('=')[1];
	// 创建一个虚拟click标签，触发下载。
	const $link = document.createElement('a');
	const url = window.URL.createObjectURL(new Blob([resp.data], {
		type: 'application/openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8'//文件类型,这里是csv
	}))
  $link.href = url;
	$link.target = '_blank';
	$link.download = fileName;
	document.body.appendChild($link);
	$link.click();
  document.body.removeChild($link);
  URL.revokeObjectURL(url);
})
```



