<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>编译工具 | Coda的博客</title>
    <meta name="generator" content="VuePress 1.5.1">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="闲着无聊？那就读书吧">
    <link rel="preload" href="/assets/css/0.styles.8b98dac0.css" as="style"><link rel="preload" href="/assets/js/app.32e12eb3.js" as="script"><link rel="preload" href="/assets/js/2.6edd83cd.js" as="script"><link rel="preload" href="/assets/js/21.0bc2a0f4.js" as="script"><link rel="prefetch" href="/assets/js/10.5d860292.js"><link rel="prefetch" href="/assets/js/11.6cdb759c.js"><link rel="prefetch" href="/assets/js/12.bde1e69c.js"><link rel="prefetch" href="/assets/js/13.216bacd3.js"><link rel="prefetch" href="/assets/js/14.2a3abe69.js"><link rel="prefetch" href="/assets/js/15.3d9c6b68.js"><link rel="prefetch" href="/assets/js/16.18276b87.js"><link rel="prefetch" href="/assets/js/17.14218967.js"><link rel="prefetch" href="/assets/js/18.998f2171.js"><link rel="prefetch" href="/assets/js/19.2012aed8.js"><link rel="prefetch" href="/assets/js/20.6509a17b.js"><link rel="prefetch" href="/assets/js/22.3111bd92.js"><link rel="prefetch" href="/assets/js/23.1bd76e73.js"><link rel="prefetch" href="/assets/js/24.b3607768.js"><link rel="prefetch" href="/assets/js/25.1452f3e8.js"><link rel="prefetch" href="/assets/js/26.0f8d5532.js"><link rel="prefetch" href="/assets/js/27.aaacbeb6.js"><link rel="prefetch" href="/assets/js/28.031d6cc2.js"><link rel="prefetch" href="/assets/js/29.f80d4218.js"><link rel="prefetch" href="/assets/js/3.528f2ac2.js"><link rel="prefetch" href="/assets/js/30.e73c5725.js"><link rel="prefetch" href="/assets/js/31.2c4fc103.js"><link rel="prefetch" href="/assets/js/32.5d9d70ee.js"><link rel="prefetch" href="/assets/js/33.3edc8ef9.js"><link rel="prefetch" href="/assets/js/34.d737b9d0.js"><link rel="prefetch" href="/assets/js/35.b1002ebc.js"><link rel="prefetch" href="/assets/js/36.f2521692.js"><link rel="prefetch" href="/assets/js/37.b6426d8e.js"><link rel="prefetch" href="/assets/js/38.d0a0ee87.js"><link rel="prefetch" href="/assets/js/39.f3679dc8.js"><link rel="prefetch" href="/assets/js/4.c4955446.js"><link rel="prefetch" href="/assets/js/40.357862d4.js"><link rel="prefetch" href="/assets/js/41.6fed3f80.js"><link rel="prefetch" href="/assets/js/42.80b27fdb.js"><link rel="prefetch" href="/assets/js/43.4370c74d.js"><link rel="prefetch" href="/assets/js/44.9715bcb9.js"><link rel="prefetch" href="/assets/js/45.68d22b79.js"><link rel="prefetch" href="/assets/js/46.9e4a3272.js"><link rel="prefetch" href="/assets/js/47.ad2a26dc.js"><link rel="prefetch" href="/assets/js/48.c50dd57f.js"><link rel="prefetch" href="/assets/js/49.d6d02e2b.js"><link rel="prefetch" href="/assets/js/5.790d3fc0.js"><link rel="prefetch" href="/assets/js/50.5471688c.js"><link rel="prefetch" href="/assets/js/51.2c0592ce.js"><link rel="prefetch" href="/assets/js/52.43dd2ad6.js"><link rel="prefetch" href="/assets/js/53.74915775.js"><link rel="prefetch" href="/assets/js/54.fb04a694.js"><link rel="prefetch" href="/assets/js/55.ad1ef4c8.js"><link rel="prefetch" href="/assets/js/56.9bde5166.js"><link rel="prefetch" href="/assets/js/57.ee0be054.js"><link rel="prefetch" href="/assets/js/58.8e80c160.js"><link rel="prefetch" href="/assets/js/59.de109384.js"><link rel="prefetch" href="/assets/js/6.720e350f.js"><link rel="prefetch" href="/assets/js/60.dc802ce2.js"><link rel="prefetch" href="/assets/js/61.1ce3d67f.js"><link rel="prefetch" href="/assets/js/62.9270017e.js"><link rel="prefetch" href="/assets/js/63.1496fed4.js"><link rel="prefetch" href="/assets/js/64.3ab620da.js"><link rel="prefetch" href="/assets/js/65.a0e7b609.js"><link rel="prefetch" href="/assets/js/66.0347d098.js"><link rel="prefetch" href="/assets/js/67.4407627b.js"><link rel="prefetch" href="/assets/js/68.48663ef7.js"><link rel="prefetch" href="/assets/js/69.518a0c93.js"><link rel="prefetch" href="/assets/js/7.9f6e7a1c.js"><link rel="prefetch" href="/assets/js/70.c04443a7.js"><link rel="prefetch" href="/assets/js/71.e6762531.js"><link rel="prefetch" href="/assets/js/72.a9e7fb91.js"><link rel="prefetch" href="/assets/js/73.3f904ce3.js"><link rel="prefetch" href="/assets/js/74.f694a8d1.js"><link rel="prefetch" href="/assets/js/75.ad47c556.js"><link rel="prefetch" href="/assets/js/76.77ad8060.js"><link rel="prefetch" href="/assets/js/77.2739103a.js"><link rel="prefetch" href="/assets/js/78.5c7ecb4e.js"><link rel="prefetch" href="/assets/js/79.a9b54f8a.js"><link rel="prefetch" href="/assets/js/8.77018880.js"><link rel="prefetch" href="/assets/js/9.0861933c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8b98dac0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Coda的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/服务端/" class="nav-link">
  服务端
</a></div><div class="nav-item"><a href="/前端/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/android/" class="nav-link">
  android
</a></div><div class="nav-item"><a href="/DevOps/" class="nav-link">
  devOps
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/服务端/" class="nav-link">
  服务端
</a></div><div class="nav-item"><a href="/前端/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/android/" class="nav-link">
  android
</a></div><div class="nav-item"><a href="/DevOps/" class="nav-link">
  devOps
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>编译工具</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#编译工具" class="sidebar-link">编译工具</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#快捷方式" class="sidebar-link">快捷方式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#pod镜像设置" class="sidebar-link">POD镜像设置</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#开发证书" class="sidebar-link">开发证书</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#证书类型" class="sidebar-link">证书类型</a></li></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#发布到fir" class="sidebar-link">发布到fir</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#上架到appstore" class="sidebar-link">上架到APPStore</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#基本语法" class="sidebar-link">基本语法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#文件扩展" class="sidebar-link">文件扩展</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#调用方法" class="sidebar-link">调用方法</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#存储器" class="sidebar-link">存储器</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#创建对象" class="sidebar-link">创建对象</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#定义class-interface" class="sidebar-link">定义Class Interface</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#property属性" class="sidebar-link">property属性</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#调用nil对象方法" class="sidebar-link">调用nil对象方法</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#categories" class="sidebar-link">Categories</a></li></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#构建应用界面" class="sidebar-link">构建应用界面</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#视图的生命周期" class="sidebar-link">视图的生命周期</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#helloworld页面" class="sidebar-link">HelloWorld页面</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#frame和bounds的区别" class="sidebar-link">frame和bounds的区别</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#绑定事件" class="sidebar-link">绑定事件</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#控件" class="sidebar-link">控件</a></li></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#mvvm-vs-mvc" class="sidebar-link">MVVM vs MVC</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#mjrefresh" class="sidebar-link">MJRefresh</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#基本用法" class="sidebar-link">基本用法</a></li></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/IOS%E5%BC%80%E5%8F%91.html#masonry" class="sidebar-link">Masonry</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="编译工具"><a href="#编译工具" class="header-anchor">#</a> 编译工具</h2> <h2 id="快捷方式"><a href="#快捷方式" class="header-anchor">#</a> 快捷方式</h2> <div class="language-markdown extra-class"><pre class="language-markdown"><code>command + A 代码全选；
control + I 代码排版；
</code></pre></div><h2 id="pod镜像设置"><a href="#pod镜像设置" class="header-anchor">#</a> POD镜像设置</h2> <p>新版的 CocoaPods 不允许用pod repo add直接添加master库了，需要进入目录操作：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code>cd <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>cocoapods<span class="token operator">/</span>repos 
pod repo remove master
git clone https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>tuna<span class="token punctuation">.</span>tsinghua<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>cn<span class="token operator">/</span>git<span class="token operator">/</span><span class="token constant">CocoaPods</span><span class="token operator">/</span><span class="token constant">Specs</span><span class="token punctuation">.</span>git master
</code></pre></div><p>最后进入自己的工程，在自己工程的podFile第一行加上：</p> <div class="language- extra-class"><pre class="language-text"><code>source 'https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git'
</code></pre></div><blockquote><p>重置为官方上游</p></blockquote> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> ~/.cocoapods/repos
pod repo remove master
<span class="token function">git</span> clone https://github.com/CocoaPods/Specs master

<span class="token comment"># 最后进入自己的工程，在自己工程的podFile第一行加上</span>
sources <span class="token string">'https://github.com/CocoaPods/Specs'</span>
</code></pre></div><h1 id="发布app"><a href="#发布app" class="header-anchor">#</a> 发布APP</h1> <h2 id="开发证书"><a href="#开发证书" class="header-anchor">#</a> 开发证书</h2> <h3 id="证书类型"><a href="#证书类型" class="header-anchor">#</a> 证书类型</h3> <blockquote><p>开发证书</p></blockquote> <p>用于在设备上运行 app 以及使用 app 功能。</p> <p>开发证书属于个人,在开发者帐户中，电脑名称会追加到开发证书名称后面 (例如，<code>Gita Kumar (Work Mac)</code>，其中 <code>Work Mac</code> 是电脑名称)，便于识别证书。</p> <blockquote><p>分发证书</p></blockquote> <p>用于分发 app 以进行测试和上传到 <a href="https://help.apple.com/developer-account/#/dev6e1771f2c" target="_blank" rel="noopener noreferrer">App Store Connect<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。一个机构账户能创建2个。</p> <p>分发证书属于团队，每个团队只能拥有一种类型的分发证书 (<a href="https://help.apple.com/developer-account/#/dev84de6b2b4" target="_blank" rel="noopener noreferrer">Developer ID<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 证书除外)。只有<a href="https://help.apple.com/developer-account/#/devb9535fd68" target="_blank" rel="noopener noreferrer">帐户持有人<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>或<a href="https://help.apple.com/developer-account/#/deva73372ae0" target="_blank" rel="noopener noreferrer">管理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>角色可以创建分发证书。</p> <blockquote><p>创建一个证书</p></blockquote> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-02-22-094008.png" alt="image-20200222174007618"></p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-02-22-095621.png" alt="image-20200222175621391"></p> <h2 id="发布到fir"><a href="#发布到fir" class="header-anchor">#</a> 发布到fir</h2> <blockquote><p>参考文章：https://fir.im/support/articles/app_publish/how-to-build-adhoc-ipa</p></blockquote> <p>1.添加证书</p> <img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-02-22-100002.png" alt="image-20200222180001298" style="zoom:50%;"> <p>2.选择iOS Distribution</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-02-22-101216.png" alt="image-20200222181215956"></p> <p>3.上传本地秘钥</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-02-22-101229.png" alt="image-20200222181229494"></p> <p>4.下载证书 &amp; 配置profile</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-02-22-101417.png" alt="image-20200222181417366"></p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-02-22-101545.png" alt="image-20200222181545272"></p> <p>5.选择bundler appid</p> <p>这里面我选择的<code>XC Wildcard(R8WQ7RD5NR.*)</code> 忘了截图了</p> <p>6.选择证书 生成profile</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-02-22-101656.png" alt="image-20200222181656512"></p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-02-22-101754.png" alt="image-20200222181754122"></p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-02-22-101809.png" alt="image-20200222181808852"></p> <p>7.下载profile 然后配置到xcode里</p> <p>8.配置<code>code sign identity</code></p> <h2 id="上架到appstore"><a href="#上架到appstore" class="header-anchor">#</a> 上架到APPStore</h2> <blockquote><p>之前的笔记：https://note.youdao.com/ynoteshare1/index.html?id=41b0ebcb8c73d7b5b7c45fac65a6193e&amp;type=note</p></blockquote> <h1 id="从零开始"><a href="#从零开始" class="header-anchor">#</a> 从零开始</h1> <h2 id="基本语法"><a href="#基本语法" class="header-anchor">#</a> 基本语法</h2> <p>https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/DefiningClasses/DefiningClasses.html</p> <p>http://cocoadevcentral.com/d/learn_objectivec/</p> <h3 id="文件扩展"><a href="#文件扩展" class="header-anchor">#</a> 文件扩展</h3> <img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-02-21-142523.jpg" alt="image-20190618220154265" style="zoom:33%;"> <h3 id="调用方法"><a href="#调用方法" class="header-anchor">#</a> 调用方法</h3> <div class="language-objective-c extra-class"><pre class="language-text"><code>// 普通调用方法
[object method];
// 带输入的方法
[object methodWithInput:input]

// 接收方法返回的对象
output = [object methodWithOutput];
output = [object methodWithInputAndOutput:input]
  
// 多参数方法
// 方法定义 writeToFile:atomically方法里接收2个参数：path和useAuxiliaryFile
-(BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile;
// 调用方法
BOOL result = [myData writeToFile:@&quot;/tmp/log.txt&quot; atomically:NO];
</code></pre></div><p>对于上面的多参数方法，实际上方法名叫：<code>writeToFile:atomically:</code></p> <h3 id="存储器"><a href="#存储器" class="header-anchor">#</a> 存储器</h3> <blockquote><p>1.x版本</p></blockquote> <p>oc里所有实例的属性都默认私有。1.x版本里修改或者读取变量需要通过setter和getter方法(读取不用特意去加get前缀，比如上面代码里的<code>[photo caption]</code></p> <div class="language-objective-c extra-class"><pre class="language-text"><code>[photo setCaption:@&quot;Day at the Beach&quot;];
caption = [photo caption];
</code></pre></div><blockquote><p>2.x版本</p></blockquote> <p>直接使用<code>.</code>语法</p> <div class="language-objc extra-class"><pre class="language-text"><code>photo.caption = @&quot;Day at the Beach&quot;;
output = photo.caption;
</code></pre></div><h3 id="创建对象"><a href="#创建对象" class="header-anchor">#</a> 创建对象</h3> <blockquote><p>自动释放内存</p></blockquote> <div class="language-objc extra-class"><pre class="language-text"><code>NSString* string1 = [NSString string];
</code></pre></div><blockquote><p>手动释放内存</p></blockquote> <div class="language-objc extra-class"><pre class="language-text"><code>NSString* string2 = [[NSString alloc] init];
[string2 release];
</code></pre></div><blockquote><p>初始化方法</p></blockquote> <div class="language-objc extra-class"><pre class="language-text"><code>-(id)init{
	if (self = [super init]) {
		  [self setCaption:@&quot;Default Caption&quot;];
      [self setPhotographer:@&quot;Default Photographer&quot;];
	}
}
</code></pre></div><blockquote><p>对象回收</p></blockquote> <div class="language-objc extra-class"><pre class="language-text"><code>-(void) dealloc{
  	[caption release];
    [photographer release];
  	// 调用父类的回收方法
    [super dealloc];
}
</code></pre></div><h3 id="定义class-interface"><a href="#定义class-interface" class="header-anchor">#</a> 定义Class Interface</h3> <p>oc里创建类需要分2步，第一步使用@interface来定义头文件(<code>.h</code>后缀)；第二步实现这个头文件。</p> <div class="language-objc extra-class"><pre class="language-text"><code>#import &lt;Foundation/Foundation.h&gt;

@interface XYZPerson : NSObject

	@property NSString* firstName;
	@property NSString* lastName;
	@property NSDate* birthDate;

	- (void)sayHello;

@end
</code></pre></div><div class="language-objc extra-class"><pre class="language-text"><code>#import &quot;XYZPerson.h&quot;

@implementation XYZPerson
  
  - (void)sayHello {
      NSString* hello = [NSString stringWithFormat:@&quot;Hello, %@ %@!&quot;,self.firstName, 			self.lastName];
      NSLog (@&quot;%@&quot;, hello);
  }
@end
</code></pre></div><h3 id="property属性"><a href="#property属性" class="header-anchor">#</a> property属性</h3> <p>oc里面的存储器可以用@property指令来代替。</p> <img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-02-24-233952.png" alt="img" style="zoom:50%;"> <p>attributes有三种类型：</p> <h4 id="_1-atomicity-原子性"><a href="#_1-atomicity-原子性" class="header-anchor">#</a> 1.Atomicity(原子性)</h4> <p>比较简单的一句话理解就是：是否给setter和getter加锁(是否保证setter或者getter的每次访问是完整性的)。</p> <p>原子性，有atomic和nonatomic两个值可选。默认值是atomic(也就是不写的话，默认是atomic)。</p> <ul><li><strong>atomic</strong>(默认值)</li></ul> <p>使用atomic，在一定程度上可以保证线程安全，「atomic的作用只是给getter和setter加了个锁」。也就是说，有线程在访问setter，其他线程只能等待完成后才能访问。</p> <p>它能保证：即使多个线程「同时」访问这个变量，atomic会让你得到一个有意义的值(valid value)。但是不能保证你获得的是哪个值（有可能是被其他线程修改过的值，也有可能是没有修改过的值）。</p> <ul><li><strong>nonatomic</strong></li></ul> <p>而用nonatomic，则不保证你获得的是有效值，如果像上面所述，读、写两个线程同时访问变量，有可能会给出一个无意义的垃圾值。</p> <p>这样对比，atomic并不能完全保证程序层面的线程安全，又有额外的性能耗费(要对getter和setter进行加锁操作);</p> <p>所以，你会见到，几乎所有情况，我们都用nonatomic。</p> <h4 id="_2-access-存取特性"><a href="#_2-access-存取特性" class="header-anchor">#</a> 2.Access(存取特性)</h4> <p>存取特性有<strong>readwrite</strong>(默认值)和<strong>readonly</strong>。</p> <p>这个从名字看就很容易理解，定义了这个属性是「只读」，还是「读写」皆可。</p> <p>如果是<strong>readwrite</strong>，就是告诉编译器，同时生成getter和setter。如果是<strong>readonly</strong>，只生成getter。</p> <h4 id="_3-storage-内存管理特性-管理对象的生命周期的"><a href="#_3-storage-内存管理特性-管理对象的生命周期的" class="header-anchor">#</a> 3.Storage(内存管理特性)(管理对象的生命周期的)</h4> <ul><li><strong>strong</strong> (默认值)</li></ul> <p>ARC新增的特性。</p> <p>表明你需要引用(持有)这个对象(reference to the object)，负责保持这个对象的生命周期。</p> <p><strong>注意，基本数据类型(非对象类型,如int, float, BOOL)，默认值并不是strong，strong只能用于对象类型。</strong></p> <ul><li><strong>weak</strong></li></ul> <p>ARC新增的特性。</p> <p>也会给你一个引用(reference/pointer)，指向对象。但是不会主张所有权(claim ownership)。也不会增加retain count。</p> <p>如果对象A被销毁，所有指向对象A的弱引用(weak reference)(用weak修饰的属性)，都会自动设置为nil。</p> <p>在delegate patterns中常用weak解决strong reference cycles(以前叫retain cycles)问题。</p> <ul><li><strong>copy</strong></li></ul> <p>为了说明<strong>copy</strong>，我们先举个栗子：</p> <p>我在某个类(class1)中声明两个字符串属性，一个用copy，一个不用：</p> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code><span class="token keyword">@property</span> <span class="token punctuation">(</span>copy<span class="token punctuation">,</span> nonatomic<span class="token punctuation">)</span> NSString <span class="token operator">*</span>nameCopy<span class="token punctuation">;</span>

<span class="token comment">// 或者可以省略strong, 编译器默认取用strong</span>
<span class="token keyword">@property</span> <span class="token punctuation">(</span>strong<span class="token punctuation">,</span> nonatomic<span class="token punctuation">)</span> NSString <span class="token operator">*</span>nameNonCopy<span class="token punctuation">;</span>
</code></pre></div><p>在另一个类中，用一个NSMutableString对这两个属性赋值并打印，再修改这个NSMutableString，再打印，看看会发生什么：</p> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code>Class1 <span class="token operator">*</span>testClass1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Class1 alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>

NSMutableString <span class="token operator">*</span>nameString <span class="token operator">=</span> <span class="token punctuation">[</span>NSMutableString stringWithFormat<span class="token punctuation">:</span><span class="token string">@&quot;Antony&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 用赋值NSMutableString给NSString赋值</span>
testClass1<span class="token punctuation">.</span>nameCopy <span class="token operator">=</span> nameString<span class="token punctuation">;</span>
testClass1<span class="token punctuation">.</span>nameNonCopy <span class="token operator">=</span> nameString<span class="token punctuation">;</span>
   
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;修改nameString前, nameCopy: %@; nameNonCopy: %@&quot;</span><span class="token punctuation">,</span> testClass1<span class="token punctuation">.</span>nameCopy<span class="token punctuation">,</span> testClass1<span class="token punctuation">.</span>nameNonCopy<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">[</span>nameString appendString<span class="token punctuation">:</span><span class="token string">@&quot;.Wong&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;修改nameString后, nameCopy: %@; nameNonCopy: %@&quot;</span><span class="token punctuation">,</span> testClass1<span class="token punctuation">.</span>nameCopy<span class="token punctuation">,</span> testClass1<span class="token punctuation">.</span>nameNonCopy<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>打印结果是：</p> <div class="language-css extra-class"><pre class="language-css"><code>修改nameString前<span class="token punctuation">,</span> <span class="token property">nameCopy</span><span class="token punctuation">:</span> Antony<span class="token punctuation">;</span> <span class="token property">nameNonCopy</span><span class="token punctuation">:</span> Antony
修改nameString后<span class="token punctuation">,</span> <span class="token property">nameCopy</span><span class="token punctuation">:</span> Antony<span class="token punctuation">;</span> <span class="token property">nameNonCopy</span><span class="token punctuation">:</span> Antony.Wong
</code></pre></div><p>我只是修改了<code>nameString</code>，为什么<code>testClass1.nameNonCopy</code>的值没改，它也跟着变了？</p> <p>因为<code>strong</code>特性，对指向对象的指针进行引用计数加1，这时候，<code>nameString</code>和<code>testClass1.nameNonCopy</code>指向的其实是同一个对象(同一块内存)。<code>nameString</code>修改了值，自然影响到<code>testClass1.nameNonCopy</code>。</p> <p>而<code>copy</code>这个特性，会在赋值前，复制一个对象，<code>testClass1.nameCopy</code>指向了一个新对象，这时候<code>nameString</code>怎么修改，也不关它啥事了。应用<code>copy</code>特性，系统应该是在setter中进行了如下操作：</p> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>setNameCopy<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>nameCopy <span class="token punctuation">{</span>
    _nameCopy <span class="token operator">=</span> <span class="token punctuation">[</span>nameCopy copy<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>大家了解<code>copy</code>的作用了吧，是为了防止属性被意外修改的。那什么时候要用到<code>copy</code>呢？</p> <p>所有有mutable(可变)版本的属性类型，如NSString, NSArray, NSDictionary等等——他们都有可变的版本类型:NSMutableString, NSMutableArray, NSMutableDictionary。这些类型在属性赋值时，右边的值有可能是它们的可变版本。这样就会出现属性值被意外改变的可能。所以它们都应该用<code>copy</code>。</p> <ul><li><strong>assign</strong></li></ul> <p>是非ARC时代的特性，</p> <p>它的作用和<strong>weak</strong>类似，唯一区别是：如果对象A被销毁，所有指向这个对象A的<strong>assign</strong>属性并不会自动设置为nil。这时候这些属性就变成野指针，再访问这些属性，程序就会crash。</p> <p>因此，在ARC下，<strong>assign</strong>就变成用于修饰基本数据类型(Primitive Type)，也就是非对象/非指针数据类型，如：int、BOOL、float等。</p> <p><strong>注意，在非ARC时代，还没有strong的时候。assign是默认值。ARC下，默认值变成strong了。这个要注意一下，否则会引起困扰。</strong></p> <ul><li><strong>retain</strong></li></ul> <p><strong>retain</strong>是以前非ARC时代的特性，在ARC下并不常用。</p> <p>它是<strong>strong</strong>的同义词，两者功能一致。不知道为什么还保留着。</p> <div class="language-objc extra-class"><pre class="language-text"><code>@interface Photo: NSObject 
@property (retain) NSString* caption;
@property (retain) NSString* photographer;
@end 
</code></pre></div><p>括号里面的retain表示，setter方法应该保存输入值。</p> <div class="language-objc extra-class"><pre class="language-text"><code>#import &quot;Photo.h&quot;  
@implementation Photo

@synthesize caption;
@synthesize photographer;
// 需要手动释放内存
- (void) dealloc
{
    [caption release];
    [photographer release];
    [super dealloc];
}
@end
</code></pre></div><h3 id="调用nil对象方法"><a href="#调用nil对象方法" class="header-anchor">#</a> 调用nil对象方法</h3> <p>oc里面nil表示空对象，但是调用nil对象的方法不会报错或者异常。</p> <div class="language-objc extra-class"><pre class="language-text"><code>- (void) dealloc
{
    self.caption = nil;
    self.photographer = nil;
    [super dealloc];
}
</code></pre></div><h3 id="categories"><a href="#categories" class="header-anchor">#</a> Categories</h3> <p>categories是一个最有用的特色功能，他可以不用重新定义一个子类，就能重写一个类的方法（一般是增加方法）；</p> <div class="language-objc extra-class"><pre class="language-text"><code>#import &lt;Cocoa/Cocoa.h&gt;
            
@interface NSString (Utilities)
- (BOOL) isURL;
@end
</code></pre></div><div class="language-objc extra-class"><pre class="language-text"><code>#import &quot;NSString-Utilities.h&quot;
            
@implementation NSString (Utilities)

- (BOOL) isURL
{
    if ( [self hasPrefix:@&quot;http://&quot;] )
        return YES;
    else
        return NO;
}

@end
</code></pre></div><div class="language-objc extra-class"><pre class="language-text"><code>NSString* string1 = @&quot;http://pixar.com/&quot;;
NSString* string2 = @&quot;Pixar&quot;;

if ( [string1 isURL] )
    NSLog (@&quot;string1 is a URL&quot;);

if ( [string2 isURL] )
    NSLog (@&quot;string2 is a URL&quot;);
</code></pre></div><h2 id="构建应用界面"><a href="#构建应用界面" class="header-anchor">#</a> 构建应用界面</h2> <h3 id="视图的生命周期"><a href="#视图的生命周期" class="header-anchor">#</a> 视图的生命周期</h3> <h3 id="helloworld页面"><a href="#helloworld页面" class="header-anchor">#</a> HelloWorld页面</h3> <blockquote><p>通过xib创建</p></blockquote> <p>AppDelegate.m代码</p> <div class="language-objc extra-class"><pre class="language-text"><code> // 调用UIWindow的initWithFrame方法
    // 参数是一个CGRect对象 通过[UIScreen mainScreen]对象的bounds方法获取获取
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    self.window.rootViewController = [[RootViewController alloc] initWithNibName:@&quot;RootViewController&quot; bundle:nil];
    [self.window makeKeyAndVisible];
    
</code></pre></div><blockquote><p>通过代码构建</p></blockquote> <p>1.创建一个视图页面<code>CocoaTouchClass</code></p> <img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-02-23-021512.png" alt="image-20200223101512042" style="zoom:50%;"> <p>2.在AppDelegate.m里引用controller</p> <div class="language-objc extra-class"><pre class="language-text"><code>#import &quot;HelloWorldViewController.h&quot;

@interface AppDelegate ()

@end

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    self.window.rootViewController = [[HelloWorldViewController alloc] init];
    self.window.backgroundColor = [UIColor whiteColor];
    [self.window makeKeyAndVisible];
    return YES;
}
</code></pre></div><h3 id="frame和bounds的区别"><a href="#frame和bounds的区别" class="header-anchor">#</a> frame和bounds的区别</h3> <p>frame指的是相对于view的parent视图</p> <p>bounds指的是相对于自身的视图；</p> <p>所以bounds的位置是（0，0）</p> <div class="language-objc extra-class"><pre class="language-text"><code>- (void)viewDidLoad {
    [super viewDidLoad];
    CGRect rootScreen = [[UIScreen mainScreen] bounds];
    UIView* viewA = [[UIView alloc] init];
    viewA.backgroundColor = [UIColor grayColor];
    viewA.frame = CGRectMake(0, 0, rootScreen.size.width, 500);
    [self.view addSubview:viewA];
    
    UIView* viewB = [[UIView alloc] init];
    viewB.backgroundColor = [UIColor whiteColor];
    viewB.frame = CGRectMake(50, 100, 100, 200);
    [viewA addSubview:viewB];
    
    NSLog(@&quot;frame_x: %.2f, frame_y: %.2f&quot;, viewB.frame.origin.x, viewB.frame.origin.y);
    
    NSLog(@&quot;frame_w: %.2f, frame_h: %.2f&quot;, viewB.frame.size.width, viewB.frame.size.height);
    
    NSLog(@&quot;bounds_x: %.2f, bounds_y: %.2f&quot;, viewB.bounds.origin.x, viewB.bounds.origin.y);
    
    NSLog(@&quot;bounds_w: %.2f, bounds_h: %.2f&quot;, viewB.bounds.size.width, viewB.bounds.size.height);

}
</code></pre></div><div class="language-shell extra-class"><pre class="language-shell"><code><span class="token number">2020</span>-02-23 <span class="token number">11</span>:01:40.144806+0800 my-app<span class="token punctuation">[</span><span class="token number">66443</span>:5710889<span class="token punctuation">]</span> frame_x: <span class="token number">50.00</span>, frame_y: <span class="token number">100.00</span>
<span class="token number">2020</span>-02-23 <span class="token number">11</span>:01:40.144934+0800 my-app<span class="token punctuation">[</span><span class="token number">66443</span>:5710889<span class="token punctuation">]</span> frame_w: <span class="token number">100.00</span>, frame_h: <span class="token number">200.00</span>
<span class="token number">2020</span>-02-23 <span class="token number">11</span>:01:40.145047+0800 my-app<span class="token punctuation">[</span><span class="token number">66443</span>:5710889<span class="token punctuation">]</span> bounds_x: <span class="token number">0.00</span>, bounds_y: <span class="token number">0.00</span>
<span class="token number">2020</span>-02-23 <span class="token number">11</span>:01:40.145134+0800 my-app<span class="token punctuation">[</span><span class="token number">66443</span>:5710889<span class="token punctuation">]</span> bounds_w: <span class="token number">100.00</span>, bounds_h: <span class="token number">200.00</span>
</code></pre></div><h3 id="绑定事件"><a href="#绑定事件" class="header-anchor">#</a> 绑定事件</h3> <h3 id="控件"><a href="#控件" class="header-anchor">#</a> 控件</h3> <h4 id="uiswitch控件"><a href="#uiswitch控件" class="header-anchor">#</a> UISwitch控件</h4> <p>分段控制器</p> <h4 id="uinavigationcontroller"><a href="#uinavigationcontroller" class="header-anchor">#</a> UINavigationController</h4> <h1 id="框架"><a href="#框架" class="header-anchor">#</a> 框架</h1> <h2 id="mvvm-vs-mvc"><a href="#mvvm-vs-mvc" class="header-anchor">#</a> MVVM vs MVC</h2> <p>一个典型的 iOS 是如何构建的，并从那里了解 MVVM：</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-02-25-082522.png" alt="Typical Model-View-Controller setup"></p> <p>我们看到的是一个典型的 MVC 设置。Model 呈现数据，View 呈现用户界面，而 View Controller 调节它两者之间的交互。Cool！</p> <p>稍微考虑一下，虽然 View 和 View Controller 是技术上不同的组件，但它们几乎总是手牵手在一起，成对的。你什么时候看到一个 View 能够与不同 View Controller 配对？或者反过来？所以，为什么不正规化它们的连接呢？</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-02-25-082551.png" alt="Intermediate"></p> <p>这更准确地描述了你可能已经编写的 MVC 代码。但它并没有做太多事情来解决 iOS 应用中日益增长重量级视图控制器的问题。在典型的 MVC 应用里，<em>许多</em>逻辑被放在 View Controller 里。它们中的一些确实属于 View Controller，但更多的是所谓的“表示逻辑（presentation logic）”。</p> <ul><li>表示层逻辑：那些可以将Model转化为View需要呈现的样子的逻辑。例如将一个 <code>NSDate</code> 转换为一个格式化过的 <code>NSString</code>。</li></ul> <p>我们的图解里缺少某些东西，那些使我们可以把所有表示逻辑放进去的东西。我们打算将其称为 “View Model” —— 它位于 View/Controller 与 Model 之间：</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-02-25-082509.png" alt="Model-View-ViewModel"></p> <p>看起好多了！这个图解准确地描述了什么是 MVVM：一个 MVC 的增强版，我们正式连接了视图和控制器，并将表示逻辑从 Controller 移出放到一个新的对象里，即 View Model。MVVM 听起来很复杂，但它本质上就是一个精心优化的 MVC 架构，而 MVC 你早已熟悉。</p> <p>如我们之前所见，MVVM 基本上就是 MVC 的改进版，所以很容易就能看到它如何被整合到现有使用典型 MVC 架构的应用中。让我们看一个简单的 <code>Person</code> Model 以及相应的 View Controller：</p> <div class="language-objc extra-class"><pre class="language-text"><code>@interface Person : NSObject

- (instancetype)initwithSalutation:(NSString *)salutation firstName:(NSString *)firstName lastName:(NSString *)lastName birthdate:(NSDate *)birthdate;

@property (nonatomic, readonly) NSString *salutation;
@property (nonatomic, readonly) NSString *firstName;
@property (nonatomic, readonly) NSString *lastName;
@property (nonatomic, readonly) NSDate *birthdate;

@end
</code></pre></div><p>Cool！现在我们假设我们有一个 <code>PersonViewController</code> ，在 <code>viewDidLoad</code> 里，只需要基于它的 <code>model</code> 属性设置一些 Label 即可。</p> <div class="language-objc extra-class"><pre class="language-text"><code>- (void)viewDidLoad {
    [super viewDidLoad];

    if (self.model.salutation.length &gt; 0) {
        self.nameLabel.text = [NSString stringWithFormat:@&quot;%@ %@ %@&quot;, self.model.salutation, self.model.firstName, self.model.lastName];
    } else {
        self.nameLabel.text = [NSString stringWithFormat:@&quot;%@ %@&quot;, self.model.firstName, self.model.lastName];
    }

    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateFormat:@&quot;EEEE MMMM d, yyyy&quot;];
    self.birthdateLabel.text = [dateFormatter stringFromDate:model.birthdate];
}
</code></pre></div><p>这全都直截了当，标准的 MVC。现在来看看我们如何用一个 View Model 来增强它。</p> <div class="language-objc extra-class"><pre class="language-text"><code>@interface PersonViewModel : NSObject

- (instancetype)initWithPerson:(Person *)person;

@property (nonatomic, readonly) Person *person;

@property (nonatomic, readonly) NSString *nameText;
@property (nonatomic, readonly) NSString *birthdateText;

@end
</code></pre></div><p>我们的 View Model 的实现大概如下：</p> <div class="language-objc extra-class"><pre class="language-text"><code>@implementation PersonViewModel

- (instancetype)initWithPerson:(Person *)person {
    self = [super init];
    if (!self) return nil;

    _person = person;
    if (person.salutation.length &gt; 0) {
        _nameText = [NSString stringWithFormat:@&quot;%@ %@ %@&quot;, self.person.salutation, self.person.firstName, self.person.lastName];
    } else {
        _nameText = [NSString stringWithFormat:@&quot;%@ %@&quot;, self.person.firstName, self.person.lastName];
    }

    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateFormat:@&quot;EEEE MMMM d, yyyy&quot;];
    _birthdateText = [dateFormatter stringFromDate:person.birthdate];

    return self;
}

@end
</code></pre></div><p>Cool！我们已经将 <code>viewDidLoad</code> 中的表示逻辑放入我们的 View Model 里了。此时，我们新的 <code>viewDidLoad</code> 就会非常轻量：</p> <div class="language-objc extra-class"><pre class="language-text"><code>- (void)viewDidLoad {
    [super viewDidLoad];

    self.nameLabel.text = self.viewModel.nameText;
    self.birthdateLabel.text = self.viewModel.birthdateText;
}
</code></pre></div><p>所以，如你所见，并没有对我们的 MVC 架构做太多改变。还是同样的代码，只不过移动了位置。</p> <h2 id="mjrefresh"><a href="#mjrefresh" class="header-anchor">#</a> MJRefresh</h2> <blockquote><p>https://github.com/CoderMJLee/MJRefresh</p></blockquote> <p>ios下拉刷新组件</p> <h3 id="基本用法"><a href="#基本用法" class="header-anchor">#</a> 基本用法</h3> <p>1.pull-to-refresh.</p> <h2 id="masonry"><a href="#masonry" class="header-anchor">#</a> Masonry</h2> <p>布局框架</p> <h1 id="常见问题"><a href="#常见问题" class="header-anchor">#</a> 常见问题</h1> <p>![image-20200310194846430](/Users/keyang/Library/Application Support/typora-user-images/image-20200310194846430.png)</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-10-114836.png" alt="image-20200310194836422"></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.32e12eb3.js" defer></script><script src="/assets/js/2.6edd83cd.js" defer></script><script src="/assets/js/21.0bc2a0f4.js" defer></script>
  </body>
</html>
