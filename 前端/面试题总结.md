# 基础知识

**1.JavaScript的数据类型都有什么？**

基本数据类型：boolean，string，null，undefined，number

引用数据类型：object，（Array，Date，Function，RegExp)

**2.javascript的事件流模式**

事件捕捉，目标阶段，事件冒泡

原始事件模型，捕获型事件模型，冒泡事件模型，

原始事件模型就是ele.onclick=function(){}这种类型的事件模型

冒泡事件模型是指事件从事件的发生地（目标元素），一直向上传递，直到document，

捕获型则恰好相反，事件是从document向下传递，直到事件的发生地（目标元素）

**3.冒泡与捕获：它们的定义，它们的区别，如何阻止冒泡？**

冒泡：事件从最下往上传递

捕获：事件从上往下传递，直到被目标捕获到。

阻止事件冒泡：e.stopPropagation() window.event.cancelBubble=true

**5.程序题**

| 123  | varfoo="11"+2-"1";console.log(foo); //111console.log(typeof foo); //number |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

**6.如何判断一个对象是方法？**

typeof object === 'function'

object.toString()

**7.**页面加载和渲染的过程

IE下载的顺序是从上到下，渲染的顺序也是从上到下，下载和渲染是同时进行，

如果有嵌入式的文件，会启用单独的链接进行下载。

css下载完成之后，会对所有的元素进行重新解析一遍。

js代码加载的时候，会停止网页的渲染和其他的下载。

**8.JavaScript的作用域和作用域链**

JavaScript的作用域指的是变量的作用范围，内部作用域由函数的形参，实参，局部变量，函数构成，内部作用域和外部的作用域一层层的链接起来形成作用域链，当在在函数内部要访问一个变量的时候，首先查找自己的内部作用域有没有这个变量，如果没有就到这个对象的原型对象中去查找，还是没有的话，就到该作用域所在的作用域中找，直到到window所在的作用域，每个函数在声明的时候就默认有一个外部作用域的存在了。

**9.****了解什么是闭包、如何使用闭包、闭包的原理、闭包的真正原理**

所有的函数都是闭包;

一般我们都是用闭包，维持一个变量的存在；或者保护一些私有方法或属性

原理：垃圾回收机制，A函数执行完之后，返回的B函数依赖了A资源，而它的返回B又被别的对象引用，这样就不会把函数的占用的资源收回。

真正原理：作用域，执行环境，作用域链，活动对象。

就是说当A被定义的时候,会将它的父函数（window）的作用域链放在[[scope]]属性里面，当函数被执行时，会创建一个活动对象，活动对象里面包含函数的参数、变量的声明还有函数的声明。然后活动对象和[[scope]]属性加起来，推入作用域链里面。

然后a函数执行完毕后，a返回了b的引用给c，b的作用域包含了对a作用域链，b又被c引用，所以a在返回后不会被回收。

**10.jquery的live和bind区别**

live和bind的功能相同，都是用来绑定事件。

bind方法只能给当前存在的元素绑定事件，对于事后采用JS等方式新生成的元素无效

live则基于事件委托机制，将事件绑定到dom根节点，所以创建新的元素后，依然能触发事件。

已经被on代替了。

**11.$('document').ready方法的实现机制**

监听DOMContentLoaded事件，当dom节点加载完全后，触发该事件。

onload方法是要等页面所有的元素都加载完成。。

**12.内存泄漏**

内存泄漏指的是浏览器不能正常的回收内存的现象

**13. 浏览器的垃圾回收机制**

垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，内存泄露和浏览器实现的垃圾回收机制息息相关， 而浏览器实现标识无用变量的策略主要有下两个方法：

**14. 模块化的理解**

前端模块话就是把复杂的文件分成一个个独立的模块，比如js文件，分成独立的模块之后有利于代码的重用和维护，但是这样又会引来模块与模块之间的依赖问题，所以就有了CommonJS、AMD、CMD规范

**15.同源策略**

同源策略是浏览器有一个很重要的概念。所谓同源是指，域名，协议，端口相同。不同源的客户端脚本(javascript、ActionScript)在没明确授权的情况下，不能读写对方的资源。简单的来说，浏览器允许包含在页面A的脚本访问第二个页面B的数据资源，这一切是建立在A和B页面是同源的基础上。

**16.改变函数内部this指针的指向函数**

call和apply，假设要改变fn函数内部的this的指向，指向obj，那么可以fn.call(obj);或者fn.apply(obj);那么问题来了，call和apply的区别是什么，其是call和apply的区别在于参数，他们两个的第一个参数都是一样的，表示调用该函数的对象，apply的第二个参数是数组，是[arg1,arg2,arg3]这种形式，而call是arg1,arg2,arg3这样的形式。还有一个bind函数，

var bar=fn.bind(obj);那么fn中的this就指向obj对象了，bind函数返回新的函数，这个函数内的this指针指向obj对象。



# DOM

**1. 行内元素与块级元素有什么不同？**

- 块级元素：div,p,h1,form,ul,li;
- 行内元素 : span>,a,label,input,img,strong,em;

**2. DOM文档加载的步骤为**

1. 解析HTML结构。
2. 加载外部脚本和样式表文件。
3. 解析并执行脚本代码。
4. DOM树构建完成。//DOMContentLoaded
5. 加载图片等外部文件。
6. 页面加载完毕。//load

**3.****什么是语义化的HTML?**

直观的认识标签 对于搜索引擎的抓取有好处，用正确的标签做正确的事情！

html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；

在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。

**4.****html5有哪些新特性、移除了那些元素？**

HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。

- 绘画 canvas
- 用于媒介回放的 video 和 audio 元素
- 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
- sessionStorage 的数据在浏览器关闭后自动删除
- 语意化更好的内容元素，比如 article、footer、header、nav、section
- 表单控件，calendar、date、time、email、url、search
- 新的技术webworker, websockt, Geolocation

移除的元素

- 纯表现的元素：basefont，big，center，font, s，strike，tt，u；
- 对可用性产生负面影响的元素：frame，frameset，noframes；

支持HTML5新标签：

- IE8/IE7/IE6支持通过document.createElement方法产生的标签，
- 可以利用这一特性让这些浏览器支持HTML5新标签，
- 浏览器支持新标签后，还需要添加标签默认的样式：

**5.请描述一下 cookies，sessionStorage 和 localStorage 的区别？**

- cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage不会
- sessionStorage和localStorage的存储空间更大；
- sessionStorage和localStorage有更多丰富易用的接口；
- sessionStorage和localStorage各自独立的存储空间；



# CSS

**1.如何理解CSS的盒子模型？**

每个HTML元素都是长方形盒子。 （1）盒子模型有两种：IE盒子模型、标准W3C盒子模型；IE的content部分包含了border和pading。 （2）标准W3C盒模型包含：内容(content)、填充(padding)、边界(margin)、边框(border)。

**2.link和@import的区别？**

**3.CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS 3新增伪类有哪些？**

**4.如何让元素垂直居中**

**5.::before 和 :after中双冒号和单冒号 有什么区别？**

单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 伪元素由双冒号和伪元素名称组成。双冒号是在css3规范中引入的，用于区分伪类和伪元素。但是伪类兼容现存样式，浏览器需要同时支持旧的伪类，比如:first-line、:first-letter、:before、:after等。 对于CSS2之前已有的伪元素，比如:before，单冒号和双冒号的写法::before作用是一样的。 提醒，如果你的网站只需要兼容webkit、firefox、opera等浏览器，建议对于伪元素采用双冒号的写法，如果不得不兼容IE浏览器，还是用CSS2的单冒号写法比较安全。

**6.用纯 CSS 创建一个三角形的原理是什么？**

把上、左、右三条边隐藏掉（颜色设为 transparent） #demo { width:0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent; }

**7.CSS隐藏元素的几种方法（至少说出三种）**

- Opacity:元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互;
- Visibility:与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏;
- Display:display 设为 none 任何对该元素直接打用户交互操作都不可能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在;



# 性能优化

> ### 1.为什么要把css放在head里，而js放到body后去？

这题目主要就是看你了不了解浏览器的渲染流程以及浏览器线程间的关系。

首先，浏览器的包含了多个进程，其中渲染进程里又包含了多个线程，和这道题相关的就是==js线程==和==渲染线程==。由于这两个线程是互斥的，而js线程拥有改变dom结构以及属性的能力，所以浏览器会先执行渲染线程，将dom树和cssom树渲染完后，生成RenderObject 树，再执行js线程；

所以，css的渲染是会阻塞js的执行的，那么为了加快页面响应速度，先不去下载js文件，反正也是后面才加载执行，而是等css文件都渲染完全后，再去加载js文件。



> ###  2.大文件断点续传

利用js实现大文件的分片上传以及断点续传

> 参考文章

https://juejin.im/post/5dff8a26e51d4558105420ed?utm_source=gold_browser_extension#heading-18

> 源码地址

https://gitee.com/dendi.ke/interview-learn

> 核心步骤：

- 1.切片，将一个大文件按照合理大小进行切分，分片上传。
- 2.利用web-worker子线程来计算md5值。
- 3.前端分片上传，并且根据md5值，检测是否已经上传过。
- 4.利用axios做取消处理，恢复上传时先读取服务器已上传的文件。

> 关键代码：

- 将文件切片

```js
const perChunkSize = 1048576; // 每个是1M 1024 * 1024
const chunkLength = Math.ceil(file.size / perChunkSize);
const chunks = [];
const chunkSize = Math.ceil(file.size / chunkLength);
let cur = 0;
while (cur < file.size) {
chunks.push({
file: file.slice(cur, cur + chunkSize),
filename: file.name,
});
cur += chunkSize;
}
return chunks;
```

- 利用webworker + SparkMd5计算md5的值
```js
const spark = new SparkMD5.ArrayBuffer();
const fileReader = new FileReader();
// 当前chunk数量
let currentChunk = 0;
fileReader.onload = function (e) {
    spark.append(e.target.result);                   // Append array buffer
    currentChunk++;
    // chunks表示总大小
    if (currentChunk < chunks) {
        loadNext();
    } else {
        console.log('finished loading');
        console.info('computed hash', spark.end());  // Compute hash
    }
};

function loadNext() {
  let start = currentChunk * chunkSize;
  let end = ((start + chunkSize) >= file.size) ? file.size : start + chunkSize;

  fileReader.readAsArrayBuffer(blobSlice.call(file, start, end));
}

```


- 通过axios来进行取消操作；

  ```js
  async _uploadChunks(uploadedList = []) {
    console.log(uploadedList);
    this.paused = false;
    const CancelToken = axios.CancelToken;
    const source = CancelToken.source();
    this.source = source;
    const promises = this.data
    .filter(({hash}) => !uploadedList.includes(hash))
    .map((item) => {
      const formData = new FormData();
      formData.append('chunk', item.chunk);
      formData.append('hash', item.hash);
      formData.append("filename", item.filename);
      return {formData, index: item.index}
    }).map(({formData, index}) => {
      console.log(index);
      return axios({
        url: 'file/v1/uploadChunks',
        method: 'post',
        baseURL: '/api',
        data: formData,
        onUploadProgress: this.createUploadHandler(this.data[index]),
        cancelToken: source.token
      });
    });
    
  pause() {
    if (this.source) {
      this.source.cancel();
      this.paused = true;
    }
  }
  ```

  

#### 总结

主要学到了两大知识点：1.文件切片、2.web worker的信息传递。

服务端的文件处理是本人自行处理的，主要是根据md5的值来判断文件是否已经上传过。实际应用中应该有同事进行配合，不用考虑太多。


