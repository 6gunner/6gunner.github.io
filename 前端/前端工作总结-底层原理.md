# 底层原理

## 浏览器渲染过程与性能优化

### 1.浏览器进程组成

现代浏览器都是多进程的，

每新增一个tab，就会创建一个进程；

每个进程又有多个线程进行协作；



<img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-10-135142.png" alt="16f7ee19a85b3c8f" style="zoom:50%;" />



参考文章：https://juejin.im/post/5e143104e51d45414a4715f7?utm_source=gold_browser_extension#heading-32



### 2.浏览器渲染流程

<img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-01-10-231904.png" alt="16f7ee2d9a5667b3" style="zoom:67%;" />

parser解析：html解析器和css解析器并行，生成dom树和style树；

dom树结合style树生成 Render树

layout：布局器负责根据Render树去计算元素位置以及大小；

paint：绘制器根据Render树绘制页面的像素信息；

display: 最后浏览器主进程将绘制的图层交给GPU进程去渲染，GPU进程将各个图层合并（composite），最后显示页面；

引申问题：[css为什么要放在js前面去加载？](./面试题总结#为什么要把css放在head里，而js放到body后去？)





## JavaScript事件循环模型

### 1.答题思路

1.1先说一下事件循环的基础知识点，哪些是宏任务，哪些是微任务。

1.2再说一下事件循环的一个流程，边说边画图。

1.3说一下async/await，promise，setTimeout，setInterval执行顺序，以及原理。

1.4可以再介绍一下nodejs的循环机制。

### 2.浏览器中的事件循环

js代码执行过程中，除了通过`调用栈`来控制函数执行顺序外，还通过`循环机制`来进行控制。每一个线程只有唯一的事件循环，但是会有多个任务队列。

任务队列里的任务分为：宏任务、微任务。同样也区分宏任务队列和微任务队列。

> 宏任务

- script(整体代码)
- setTimeout
- setInterval
- setImmediate
- I/O

> 微任务

- Promise
- Async/Await

> 事件循环流程

主线程从上往下执行代码。遇到函数时，会判断函数是否为同步任务。如果是同步任务会进入执行堆栈，遇到异步任务，会根据任务类型，将回调函数放入不同的任务队列中。

当执行堆栈的调用结束时，会去判断`微队列`中是否有任务。如果有，就会将`微任务队列`里的异步任务加入到执行队列中进行处理。

==如果微任务执行过程中产生了微任务，会继续放到当前微队列里。==

直到微队列里任务都执行完成，才会去执行下一个宏任务。

![img](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-04-132748.png)

### 3.async/await的原理以及执行顺序

> async是*generator函数的语法糖，那generator是什么？

generator函数是一个状态机，执行genetator函数会返回一个遍历对象，可以通过next()方法区遍历generator内部的每个状态。

```js
function* generator1() {
  yield 'hello';
  yield 'world';
  return 'ending';
}
```

```js
var hw = generator1();
hw.next()// { value: 'hello', done: false }
hw.next()// { value: 'world', done: false }
hw.next()// { value: 'ending', done: true }
hw.next()// { value: undefined, done: true }
```



> generator函数暂停、恢复原理。

协程：协程比线程更轻量级，允许执行被挂起与被恢复。线程之间会抢夺资源，但是协程，它本质上还是在一个线程上进行执行，他们之间是相互合作的，不会产生竞争。可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。

假设流程：

1. 协程`A`开始执行
2. 协程`A`执行到某个阶段，进入暂停，执行权转移到协程`B`
3. 协程`B`执行完成或暂停，将执行权交还`A`
4. 协程`A`恢复执行

A、B的执行有点像多线程，但协程的特点在于是一个线程执行，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。

第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。



> 执行器的概念

generator函数的自动执行依赖于`执行器`。执行器的要求是：能够执行异步函数，当异步函数返回的时候，能自动交回执行权。可以有两种实现方式：

1.回调函数。

2.Promise对象

```
function run(gen) {
  var g = gen();
  function next() {
    var result = g.next();
    if (result.done) {
      return result.value;
    }
    return new Promise(((resolve, reject) => {
      resolve();
    })).then(() => {
      next();
    })
  }
  next();
}
```

> async函数干了什么？

假设async 后面接了一个函数，那这个函数的返回值，会被封装为一个Promise对象并返回。

```js
async function f1() {
  return '1';
}

function f2() {
  return 2;
}

console.log(f1());
console.log(Promise.resolve('1'));
console.log(new Promise(resolve => {
  resolve('1');
}));
console.log(f2());
```

打印结果

```js
Promise {<resolved>: "1"}
Promise {<resolved>: "1"}
Promise {<resolved>: "1"}
2
```

从打印结果可以看出来，async的函数，返回的是一个立即执行的Promise函数。



> await 等待的执行顺序

await执行分两种情况，一种是await后面函数执行的结果返回的是promise对象，一种返回的是普通对象。

无论是哪种情况，程序遇到await语句时，都会先执行函数方法，然后跳出async函数，去执行async函数外的代码。等外部代码执行完（当前调用栈清空后），再跳回到async函数内部。这时，await 后面的代码返回：

- 如果返回的是promise对象

  会等到这个Promise对象变为fullfiled状态，将promise的代码作为await表达式的执行结果。

  await 语句的下面一行，会在promise之后，被加入微任务队列。

  也就是说，这个过程有2个微任务产生。

- 返回普通对象

  如果是普通的对象，会直接返回一个立即执行的Promise函数，await 语句的下一行代码，会直接被注册为微任务。

执行顺序：await后面的接的函数执行之后后，会跳出async函数。执行其他代码（模式就类似于协程A,B的切换）。当其他代码执行完毕后，再回到async函数去执行剩下的代码。然后await下面的一行代码会被注册到微任务队列里。

结合例子来看：

```js
console.log('script start') // 1.执行代码，输出script start。

async function async1() { 
  await async2();          // 3.调用async2(), 输出async2 end。跳出async1函数
  console.log('async1 end') // 8.当前微任务队列执行完毕。执行权回到async1. 执行await后面的语句,实际上会产生一个promise返回. 输出async1 end

  
}
async function async2() {
  console.log('async2 end'); 
}
async1() // 2.执行async1(),

setTimeout(function() { // 4.跳出async1函数，执行setTimeout，产生一个宏任务
  console.log('setTimeout') // 9 .输出setTimeout
}, 0)

new Promise(resolve => { // 5.执行Promise，输出Promise
  console.log('Promise')
  resolve()
})
  .then(function() { // 7.当前宏任务执行完毕)，开始执行当前宏任务产生的微任务队列，输出promise1，
    console.log('promise1') 
  })
  .then(function() { // 7.1该微任务遇到then，产生一个新的微任务. 执行产生的微任务，输出promise2,
    console.log('promise2')
  })

console.log('script end') // 6.继续执行代码，输出script end
```

<img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-03-141113.png" alt="image-20200303221113367" style="zoom:50%;" />

宏任务队列、微任务队列。

