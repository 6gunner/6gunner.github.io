## JS执行上下文

js执行上下文分3类：

全局上下文

函数上下文

eval



## JS执行栈

也就是浏览器里面的调用栈，栈数据结构，“后进先出“，用来存储代码运行时创建的执行上下文。

js调用函数时，会先将函数的`执行上下文`压入到栈里面；js引擎会执行位于栈顶的函数。函数执行结束后，会将上下文从栈里弹出。



## 变量提升

因为JS引擎在初次执行脚本时，会先去创建一个全局执行上下文。在这个过程里，会先去找到所有的var声明的变量，以及命名函数。然后去执行脚本。

这个过程产生了，引起了变量提前定义，从而造成了变量提升；

用const和let可以避免变量提升；



## 作用域链

首先说一下什么是作用域？

执行上下文其实就是作用域。函数在创建时，js引擎会把为函数创建一个执行上下文（内部作用域）。内部作用域包含：arguments,  this对象, 命名函数，函数内局部变量。

上面说的，js引擎会先创建一个全局上下文，也就是全局作用域。然后每执行一个函数，又会单独创建一个执行上下文。

这样内部作用域和外部作用域链接起来形成：`全局上下文`-> `执行上下文1` -> `执行上下文2`-> ... -> `执行上下文n`。形成了一个链式调用结构。

js引擎在做变量解析的时候，会从当前执行上下文一直向上查找，直到找到全局上下文。如果还没有找到该变量，就会认为变量未定义。

> 专业回答

JavaScript的作用域指的是变量的作用范围，内部作用域由函数的形参，实参，局部变量，函数构成，内部作用域和外部的作用域一层层的链接起来形成作用域链，当在在函数内部要访问一个变量的时候，首先查找自己的内部作用域有没有这个变量，如果没有就到这个对象的原型对象中去查找，还是没有的话，就到该作用域所在的作用域中找，直到到window所在的作用域，每个函数在声明的时候就默认有一个外部作用域的存在了。



## 闭包

所有的函数都是闭包;

一般我们都是用闭包，维持一个变量的存在；或者保护一些私有方法或属性

原理：垃圾回收机制，A函数执行完之后，返回的B函数依赖了A资源，而它的返回B又被别的对象引用，这样就不会把函数的占用的资源收回。

真正原理：作用域，执行环境，作用域链，活动对象。

就是说当A被定义的时候,会将它的父函数（window）的作用域链放在[[scope]]属性里面，当函数被执行时，会创建一个活动对象，活动对象里面包含函数的参数、变量的声明还有函数的声明。然后活动对象和[[scope]]属性加起来，推入作用域链里面。

然后a函数执行完毕后，a返回了b的引用给c，b的作用域包含了对a作用域链，b又被c引用，所以a在返回后不会被回收。

**1.JavaScript的数据类型都有什么？**

基本数据类型：boolean，string，null，undefined，number

引用数据类型：object，（Array，Date，Function，RegExp)

**2.javascript的事件流模式**

事件捕捉，目标阶段，事件冒泡

原始事件模型，捕获型事件模型，冒泡事件模型，

原始事件模型就是ele.onclick=function(){}这种类型的事件模型

冒泡事件模型是指事件从事件的发生地（目标元素），一直向上传递，直到document，

捕获型则恰好相反，事件是从document向下传递，直到事件的发生地（目标元素）

**3.冒泡与捕获：它们的定义，它们的区别，如何阻止冒泡？**

冒泡：事件从最下往上传递

捕获：事件从上往下传递，直到被目标捕获到。

阻止事件冒泡：e.stopPropagation() window.event.cancelBubble=true



**6.如何判断一个对象是方法？**

typeof object === 'function'

object.toString()

**7.**页面加载和渲染的过程

IE下载的顺序是从上到下，渲染的顺序也是从上到下，下载和渲染是同时进行，

如果有嵌入式的文件，会启用单独的链接进行下载。

css下载完成之后，会对所有的元素进行重新解析一遍。

js代码加载的时候，会停止网页的渲染和其他的下载。



**10.jquery的live和bind区别**

live和bind的功能相同，都是用来绑定事件。

bind方法只能给当前存在的元素绑定事件，对于事后采用JS等方式新生成的元素无效

live则基于事件委托机制，将事件绑定到dom根节点，所以创建新的元素后，依然能触发事件。

已经被on代替了。

**11.$('document').ready方法的实现机制**

监听DOMContentLoaded事件，当dom节点加载完全后，触发该事件。

onload方法是要等页面所有的元素都加载完成。。

**12.内存泄漏**

内存泄漏指的是浏览器不能正常的回收内存的现象

**13. 浏览器的垃圾回收机制**

垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，内存泄露和浏览器实现的垃圾回收机制息息相关， 而浏览器实现标识无用变量的策略主要有下两个方法：

**14. 模块化的理解**

前端模块话就是把复杂的文件分成一个个独立的模块，比如js文件，分成独立的模块之后有利于代码的重用和维护，但是这样又会引来模块与模块之间的依赖问题，所以就有了CommonJS、AMD、CMD规范

**15.同源策略**

同源策略是浏览器有一个很重要的概念。所谓同源是指，域名，协议，端口相同。不同源的客户端脚本(javascript、ActionScript)在没明确授权的情况下，不能读写对方的资源。简单的来说，浏览器允许包含在页面A的脚本访问第二个页面B的数据资源，这一切是建立在A和B页面是同源的基础上。

**16.改变函数内部this指针的指向函数**

call和apply，假设要改变fn函数内部的this的指向，指向obj，那么可以fn.call(obj);或者fn.apply(obj);那么问题来了，call和apply的区别是什么，其是call和apply的区别在于参数，他们两个的第一个参数都是一样的，表示调用该函数的对象，apply的第二个参数是数组，是[arg1,arg2,arg3]这种形式，而call是arg1,arg2,arg3这样的形式。还有一个bind函数，

var bar=fn.bind(obj);那么fn中的this就指向obj对象了，bind函数返回新的函数，这个函数内的this指针指向obj对象。



# DOM

**1. 行内元素与块级元素有什么不同？**

- 块级元素：div,p,h1,form,ul,li;
- 行内元素 : span>,a,label,input,img,strong,em;

**2. DOM文档加载的步骤为**

1. 解析HTML结构。
2. 加载外部脚本和样式表文件。
3. 解析并执行脚本代码。
4. DOM树构建完成。//DOMContentLoaded
5. 加载图片等外部文件。
6. 页面加载完毕。//load

**3.****什么是语义化的HTML?**

直观的认识标签 对于搜索引擎的抓取有好处，用正确的标签做正确的事情！

html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；

在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。

**4.****html5有哪些新特性、移除了那些元素？**

HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。

- 绘画 canvas
- 用于媒介回放的 video 和 audio 元素
- 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
- sessionStorage 的数据在浏览器关闭后自动删除
- 语意化更好的内容元素，比如 article、footer、header、nav、section
- 表单控件，calendar、date、time、email、url、search
- 新的技术webworker, websockt, Geolocation

移除的元素

- 纯表现的元素：basefont，big，center，font, s，strike，tt，u；
- 对可用性产生负面影响的元素：frame，frameset，noframes；

支持HTML5新标签：

- IE8/IE7/IE6支持通过document.createElement方法产生的标签，
- 可以利用这一特性让这些浏览器支持HTML5新标签，
- 浏览器支持新标签后，还需要添加标签默认的样式：

**5.请描述一下 cookies，sessionStorage 和 localStorage 的区别？**

- cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage不会
- sessionStorage和localStorage的存储空间更大；
- sessionStorage和localStorage有更多丰富易用的接口；
- sessionStorage和localStorage各自独立的存储空间；

