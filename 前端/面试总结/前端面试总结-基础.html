<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS基础 | Coda的博客</title>
    <meta name="generator" content="VuePress 1.5.1">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="闲着无聊？那就读书吧">
    <link rel="preload" href="/assets/css/0.styles.8b98dac0.css" as="style"><link rel="preload" href="/assets/js/app.32e12eb3.js" as="script"><link rel="preload" href="/assets/js/2.6edd83cd.js" as="script"><link rel="preload" href="/assets/js/59.de109384.js" as="script"><link rel="prefetch" href="/assets/js/10.5d860292.js"><link rel="prefetch" href="/assets/js/11.6cdb759c.js"><link rel="prefetch" href="/assets/js/12.bde1e69c.js"><link rel="prefetch" href="/assets/js/13.216bacd3.js"><link rel="prefetch" href="/assets/js/14.2a3abe69.js"><link rel="prefetch" href="/assets/js/15.3d9c6b68.js"><link rel="prefetch" href="/assets/js/16.18276b87.js"><link rel="prefetch" href="/assets/js/17.14218967.js"><link rel="prefetch" href="/assets/js/18.998f2171.js"><link rel="prefetch" href="/assets/js/19.2012aed8.js"><link rel="prefetch" href="/assets/js/20.6509a17b.js"><link rel="prefetch" href="/assets/js/21.0bc2a0f4.js"><link rel="prefetch" href="/assets/js/22.3111bd92.js"><link rel="prefetch" href="/assets/js/23.1bd76e73.js"><link rel="prefetch" href="/assets/js/24.b3607768.js"><link rel="prefetch" href="/assets/js/25.1452f3e8.js"><link rel="prefetch" href="/assets/js/26.0f8d5532.js"><link rel="prefetch" href="/assets/js/27.aaacbeb6.js"><link rel="prefetch" href="/assets/js/28.031d6cc2.js"><link rel="prefetch" href="/assets/js/29.f80d4218.js"><link rel="prefetch" href="/assets/js/3.528f2ac2.js"><link rel="prefetch" href="/assets/js/30.e73c5725.js"><link rel="prefetch" href="/assets/js/31.2c4fc103.js"><link rel="prefetch" href="/assets/js/32.5d9d70ee.js"><link rel="prefetch" href="/assets/js/33.3edc8ef9.js"><link rel="prefetch" href="/assets/js/34.d737b9d0.js"><link rel="prefetch" href="/assets/js/35.b1002ebc.js"><link rel="prefetch" href="/assets/js/36.f2521692.js"><link rel="prefetch" href="/assets/js/37.b6426d8e.js"><link rel="prefetch" href="/assets/js/38.d0a0ee87.js"><link rel="prefetch" href="/assets/js/39.f3679dc8.js"><link rel="prefetch" href="/assets/js/4.c4955446.js"><link rel="prefetch" href="/assets/js/40.357862d4.js"><link rel="prefetch" href="/assets/js/41.6fed3f80.js"><link rel="prefetch" href="/assets/js/42.80b27fdb.js"><link rel="prefetch" href="/assets/js/43.4370c74d.js"><link rel="prefetch" href="/assets/js/44.9715bcb9.js"><link rel="prefetch" href="/assets/js/45.68d22b79.js"><link rel="prefetch" href="/assets/js/46.9e4a3272.js"><link rel="prefetch" href="/assets/js/47.ad2a26dc.js"><link rel="prefetch" href="/assets/js/48.c50dd57f.js"><link rel="prefetch" href="/assets/js/49.d6d02e2b.js"><link rel="prefetch" href="/assets/js/5.790d3fc0.js"><link rel="prefetch" href="/assets/js/50.5471688c.js"><link rel="prefetch" href="/assets/js/51.2c0592ce.js"><link rel="prefetch" href="/assets/js/52.43dd2ad6.js"><link rel="prefetch" href="/assets/js/53.74915775.js"><link rel="prefetch" href="/assets/js/54.fb04a694.js"><link rel="prefetch" href="/assets/js/55.ad1ef4c8.js"><link rel="prefetch" href="/assets/js/56.9bde5166.js"><link rel="prefetch" href="/assets/js/57.ee0be054.js"><link rel="prefetch" href="/assets/js/58.8e80c160.js"><link rel="prefetch" href="/assets/js/6.720e350f.js"><link rel="prefetch" href="/assets/js/60.dc802ce2.js"><link rel="prefetch" href="/assets/js/61.1ce3d67f.js"><link rel="prefetch" href="/assets/js/62.9270017e.js"><link rel="prefetch" href="/assets/js/63.1496fed4.js"><link rel="prefetch" href="/assets/js/64.3ab620da.js"><link rel="prefetch" href="/assets/js/65.a0e7b609.js"><link rel="prefetch" href="/assets/js/66.0347d098.js"><link rel="prefetch" href="/assets/js/67.4407627b.js"><link rel="prefetch" href="/assets/js/68.48663ef7.js"><link rel="prefetch" href="/assets/js/69.518a0c93.js"><link rel="prefetch" href="/assets/js/7.9f6e7a1c.js"><link rel="prefetch" href="/assets/js/70.c04443a7.js"><link rel="prefetch" href="/assets/js/71.e6762531.js"><link rel="prefetch" href="/assets/js/72.a9e7fb91.js"><link rel="prefetch" href="/assets/js/73.3f904ce3.js"><link rel="prefetch" href="/assets/js/74.f694a8d1.js"><link rel="prefetch" href="/assets/js/75.ad47c556.js"><link rel="prefetch" href="/assets/js/76.77ad8060.js"><link rel="prefetch" href="/assets/js/77.2739103a.js"><link rel="prefetch" href="/assets/js/78.5c7ecb4e.js"><link rel="prefetch" href="/assets/js/79.a9b54f8a.js"><link rel="prefetch" href="/assets/js/8.77018880.js"><link rel="prefetch" href="/assets/js/9.0861933c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8b98dac0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Coda的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/服务端/" class="nav-link">
  服务端
</a></div><div class="nav-item"><a href="/前端/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/android/" class="nav-link">
  android
</a></div><div class="nav-item"><a href="/DevOps/" class="nav-link">
  devOps
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/服务端/" class="nav-link">
  服务端
</a></div><div class="nav-item"><a href="/前端/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/android/" class="nav-link">
  android
</a></div><div class="nav-item"><a href="/DevOps/" class="nav-link">
  devOps
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JS基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80.html#js执行上下文" class="sidebar-link">JS执行上下文</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80.html#js执行栈" class="sidebar-link">JS执行栈</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80.html#变量提升" class="sidebar-link">变量提升</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80.html#作用域链" class="sidebar-link">作用域链</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80.html#闭包" class="sidebar-link">闭包</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80.html#原型-继承" class="sidebar-link">原型/继承</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80.html#promise函数" class="sidebar-link">Promise函数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80.html#深浅拷贝" class="sidebar-link">深浅拷贝</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80.html#事件循环机制-event-loop" class="sidebar-link">事件循环机制/Event Loop</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80.html#_1-答题思路" class="sidebar-link">1.答题思路</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80.html#_2-浏览器中的事件循环" class="sidebar-link">2.浏览器中的事件循环</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80.html#_3-async-await的原理以及执行顺序" class="sidebar-link">3.async/await的原理以及执行顺序</a></li></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80.html#函数式编程" class="sidebar-link">函数式编程</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80.html#webworker" class="sidebar-link">WebWorker</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80.html#serviceworker" class="sidebar-link">ServiceWorker</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js基础"><a href="#js基础" class="header-anchor">#</a> JS基础</h1> <h2 id="js执行上下文"><a href="#js执行上下文" class="header-anchor">#</a> JS执行上下文</h2> <p>js执行上下文分3类：</p> <p>全局上下文</p> <p>函数上下文</p> <p>eval</p> <h2 id="js执行栈"><a href="#js执行栈" class="header-anchor">#</a> JS执行栈</h2> <p>也就是浏览器里面的调用栈，栈数据结构，“后进先出“，用来存储代码运行时创建的执行上下文。</p> <p>js调用函数时，会先将函数的<code>执行上下文</code>压入到栈里面；js引擎会执行位于栈顶的函数。函数执行结束后，会将上下文从栈里弹出。</p> <h2 id="变量提升"><a href="#变量提升" class="header-anchor">#</a> 变量提升</h2> <p>因为JS引擎在初次执行脚本时，会先去创建一个全局执行上下文。在这个过程里，会先去找到所有的var声明的变量，以及命名函数。然后去执行脚本。</p> <p>这个过程产生了，引起了变量提前定义，从而造成了变量提升；</p> <p>用const和let可以避免变量提升；</p> <h2 id="作用域链"><a href="#作用域链" class="header-anchor">#</a> 作用域链</h2> <p>首先说一下什么是作用域？</p> <p>执行上下文其实就是作用域。函数在创建时，js引擎会把为函数创建一个执行上下文（内部作用域）。内部作用域包含：arguments,  this对象, 命名函数，函数内局部变量。</p> <p>上面说的，js引擎会先创建一个全局上下文，也就是全局作用域。然后每执行一个函数，又会单独创建一个执行上下文。</p> <p>这样内部作用域和外部作用域链接起来形成：<code>全局上下文</code>-&gt; <code>执行上下文1</code> -&gt; <code>执行上下文2</code>-&gt; ... -&gt; <code>执行上下文n</code>。形成了一个链式调用结构。</p> <p>js引擎在做变量解析的时候，会从当前执行上下文一直向上查找，直到找到全局上下文。如果还没有找到该变量，就会认为变量未定义。</p> <blockquote><p>专业回答</p></blockquote> <p>JavaScript的作用域指的是变量的作用范围，内部作用域由函数的形参，实参，局部变量，函数构成，内部作用域和外部的作用域一层层的链接起来形成作用域链，当在在函数内部要访问一个变量的时候，首先查找自己的内部作用域有没有这个变量，如果没有就到这个对象的原型对象中去查找，还是没有的话，就到该作用域所在的作用域中找，直到到window所在的作用域，每个函数在声明的时候就默认有一个外部作用域的存在了。</p> <h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <p>要理解闭包，就得理解函数作用域。</p> <p>所有的函数都有自己独立的函数作用域。闭包也是一个函数，而它「记住了周围发生了什么」。简单可以理解为：</p> <p>一个函数体里定义了另一个函数。</p> <p>一般运用到闭包的地方，一种用途是保留内存，让变量能够被外部函数读取；另一种是用来保护一些私有方法或属性。</p> <p>保留内存的例子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">makeAdder</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> add2 <span class="token operator">=</span> <span class="token function">makeAdder</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> add5 <span class="token operator">=</span> <span class="token function">makerAdder</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">add2</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 7</span>
<span class="token function">add5</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10</span>
</code></pre></div><p>这个例子就可以明显看出来，我们保留了第一个参数x的的内存，让他能够在后面你的函数一直使用。</p> <p>保留内存的原理是是因为作用域链的依赖，导致内存不会被回收。</p> <p>比如👆例子，makerAdder函数执行完之后，返回的函数依赖了makerAdder的参数，而它的返回函数又被别的对象add2、add5引用，这样垃圾回收期就不会把函数的占用的资源收回。</p> <p>定义私有方法的例子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&quot;anybody&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>getName <span class="token operator">=</span> getName<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name <span class="token punctuation">)</span><span class="token comment">// 错误代码</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 私有化name属性，只能通过getName()进行访问</span>
</code></pre></div><p>闭包导致的问题</p> <p>由于闭包能够是变量的内存一直被占用，不被回收。所有会导致浏览器有内存泄露的风险。</p> <h2 id="原型-继承"><a href="#原型-继承" class="header-anchor">#</a> 原型/继承</h2> <p>要讲好原型，首先得说清楚<code>原型对象</code>、<code>构造函数</code>、<code>instance实例</code>的关系。</p> <img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-07-014355.png" alt="1.png" style="zoom:70%;"> <p>每一个对象都有一个<code>__proto__</code>属性，先称它为隐式<code>原型对象</code>。</p> <p>每一个函数都有一个<code>prototype</code>属性，指向一个对象，称这个对象为<code>原型对象</code>。</p> <p>构造函数是一个函数，所以构造函数有一个<code>prototype</code>指向一个对象，那么叫这个对象为构造函数的原型对象。</p> <p>构造函数的原型对象有一个单独的<code>constructor</code>属性，他会指回到<code>构造函数</code>。</p> <p>通过构造函数的创建的实例对象，它的<code>__proto__</code>属性，也会指向了这个构造函数的原型对象。</p> <p>就是说</p> <div class="language-js extra-class"><pre class="language-js"><code>对象实例<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">函数</span><span class="token punctuation">.</span>prototype
</code></pre></div><p><code>__proto__</code>和<code>prototype</code>概念区分</p> <p><code>__proto__</code>其实指的是对象的[[prototype]]属性，而prototype是函数独有的属性。</p> <p>那函数也是对象，它的<code>__proto__</code>指向什么呢？答案是Function.prototype。</p> <p>经典问题：</p> <blockquote><p>new关键字做了什么事情？</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>function _new() {
	var target = {}; // 创建实例对象
	const [constructor, ...args] = [...arguments];
	target.__proto__ = constructor.prototype; // 建立关系
	var result = constructor.apply(target, args); // 调用构造函数，将构造函数的属性赋值到target上
	if (result != null &amp;&amp; (typeof result == 'object' || typeof result == 'function')) {
		return result;
	}
	return target;
}
</code></pre></div><blockquote><p>instanceOf 方法的内部原理</p></blockquote> <p>obj instanceOf Constructor</p> <p>就是判断对象的原型链上是否出现了 构造函数这个原型。</p> <img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-14-081305.png" alt="img" style="zoom:67%;"> <blockquote><p>原型方法和属性方法的区别</p></blockquote> <p>构造函数的原型对象上的方法或者属性，每一个实例都会去共享。</p> <p>但是构造函数内部的方法，每一个实例都会单独拥有一个。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;keyang&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'Hello'</span> <span class="token operator">+</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token class-name">C</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">'Hi'</span> <span class="token operator">+</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span>sayHello <span class="token operator">==</span> c2<span class="token punctuation">.</span>sayHello<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span>sayHi <span class="token operator">==</span> c2<span class="token punctuation">.</span>sayHi<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div><p><strong>继承</strong></p> <p>java里继承的方式有2种，一种是通过实现接口，一种是通过extends来继承对象。</p> <p>js的继承方式只有1种，通过原型来继承。</p> <p>原型继承的原理是原型链。</p> <p>因为构造函数的原型他本身也是一个对象，所以它也有自己的原型对象。它指向的是super构造函数的原型。一层层向上追溯，最终形成原型链。</p> <p><strong>原型继承：</strong></p> <p>思路：不需要定义一个严格意义上的构造函数，而是直接借助原型基于已有对象来创建新对象</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">extendsObject</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>ECMAScript5新增Object.create()方法来规范化了原型式继承:</p> <p><code>Object.create(*proto*[, *propertiesObject*])</code>;</p> <p><strong>最常见的继承方式：组合继承</strong></p> <p>将原型继承和构造函数继承组合在一起。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">Foo</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// each Foo instance has a unique id</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">doFoo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Foo!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> <span class="token function-variable function">Bar</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>something <span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Bar</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 上面例子里，Bar 的实例都会有一个相同的id属性。因此,我们必须在每个实例上，调用父级构造函数。</span>
<span class="token keyword">var</span> <span class="token function-variable function">Bar</span><span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">Foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// set unique `id` on `this`</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>something <span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 区别在于，Object.create的对象，是没有id属性的</span>
<span class="token class-name">Bar</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="promise函数"><a href="#promise函数" class="header-anchor">#</a> Promise函数</h2> <p>promise函数主要是用来处理异步函数的。</p> <p>早起的异步函数，都是通过callback进行回调。但是带来一个问题，代码难以阅读。</p> <p>promise提供了一个promise().then().catch()的语法，再也不用 回调里面再回调了。</p> <p>promise定义了3种状态，pendding、fullfiled、rejected。</p> <p>promise构造函数接收一个Exeuctor函数，有两个参数为resolve、reject。</p> <p>resolve将pendding状态变成fullfiled状态，并将异步函数返回的结果，通过参数传递出去。</p> <p>reject将pendding状态变成rejected状态，可以将失败的原因通过参数传递出去。</p> <blockquote><p><a href="https://juejin.im/post/5e58c618e51d4526ed66b5cf?utm_source=gold_browser_extension" target="_blank" rel="noopener noreferrer">45道Promise面试题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h2 id="深浅拷贝"><a href="#深浅拷贝" class="header-anchor">#</a> 深浅拷贝</h2> <p>首先了解一下数据类型：</p> <p>基本数据类型：boolean，string，null，undefined，number</p> <p>引用数据类型：object，（Array，Date，Function，RegExp)</p> <p>基础数据类型放在栈内存中</p> <p>引用数据类型存放在堆内存中，引用这些数据的变量放在栈内存中。</p> <p><strong>所以堆内存存放new出来的object对象</strong></p> <p><strong>而栈内存存放一些基本的变量，以及对象的引用变量。</strong></p> <p><strong>浅拷贝(shallow copy) vs 深拷贝(deep copy)</strong></p> <p>对于基本类型来说，深浅拷贝都一致。</p> <p>对于引用对象来说，==浅拷贝==只copy引用对象的指针，而==深拷贝==会将引用对象在堆内存的地址也复制一份。</p> <p><strong>常见的浅拷贝操作</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 赋值操作</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> arr2 <span class="token operator">=</span> arr<span class="token punctuation">;</span>




</code></pre></div><p><strong>常见深拷贝操作</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var arr = ['a', 'b', 'c'];
var arrCopy = arr.slice(0);
arrCopy[0] = 'test'
console.log(arr); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
console.log(arrCopy); // [&quot;test&quot;, &quot;b&quot;, &quot;c&quot;]

</code></pre></div><p>这里有一个容易进入的误区。虽然Array.slice函数调用返回的数组内存地址和自身不相同。但是，如果数组里存放的是对象是引用类型的对象时，那么返回的数组里面每一个item的内存地址仍然是同一个。</p> <p><strong>深拷贝的实现方式</strong></p> <blockquote><p>最简单的方式</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>function deepClone(obj) {
	return JSON.parse(JSON.stringify(obj));
}
</code></pre></div><p>最简单的方式有缺陷，他只能适用于扁平化的，且没有Function、Regex的数据结构。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>
  key1<span class="token operator">:</span> <span class="token punctuation">{</span>
    name1<span class="token operator">:</span> <span class="token string">'name1'</span><span class="token punctuation">,</span>
    value1<span class="token operator">:</span> <span class="token string">'value1'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  key2<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
    name2<span class="token operator">:</span> <span class="token string">'name2'</span><span class="token punctuation">,</span>
    value2<span class="token operator">:</span><span class="token string">'value2'</span>
  <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function-variable function">key3</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  key4<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token regex">/regex/g</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token function">deepCloe1</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// key3、key4的属性都无法正常copy</span>
</code></pre></div><blockquote><p>复杂方式</p></blockquote> <p>复杂的实现逻辑就是依赖于递归</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">deepClone2</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> target<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    target <span class="token operator">=</span> obj<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> value <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Object <span class="token operator">||</span> obj<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone2</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> target<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> obj3 <span class="token operator">=</span> <span class="token function">deepClone2</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj1<span class="token punctuation">.</span>key1<span class="token punctuation">.</span>name1 <span class="token operator">=</span> <span class="token string">'dasfsaa'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj3<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="事件循环机制-event-loop"><a href="#事件循环机制-event-loop" class="header-anchor">#</a> 事件循环机制/Event Loop</h2> <h3 id="_1-答题思路"><a href="#_1-答题思路" class="header-anchor">#</a> 1.答题思路</h3> <p>1.1先说一下事件循环的基础知识点，哪些是宏任务，哪些是微任务。</p> <p>1.2再说一下事件循环的一个流程，边说边画图。</p> <p>1.3说一下async/await，promise，setTimeout，setInterval执行顺序，以及原理。</p> <p>1.4可以再介绍一下nodejs的循环机制。</p> <h3 id="_2-浏览器中的事件循环"><a href="#_2-浏览器中的事件循环" class="header-anchor">#</a> 2.浏览器中的事件循环</h3> <p>js代码执行过程中，除了通过<code>调用栈</code>来控制函数执行顺序外，还通过<code>循环机制</code>来进行控制。每一个线程只有唯一的事件循环，但是会有多个任务队列。</p> <p>任务队列里的任务分为：宏任务、微任务。同样也区分宏任务队列和微任务队列。</p> <blockquote><p>宏任务</p></blockquote> <ul><li>script(整体代码)</li> <li>setTimeout</li> <li>setInterval</li> <li>setImmediate</li> <li>I/O</li></ul> <blockquote><p>微任务</p></blockquote> <ul><li>Promise</li> <li>Async/Await</li></ul> <blockquote><p>事件循环流程</p></blockquote> <p>主线程从上往下执行代码。遇到函数时，会判断函数是否为同步任务。如果是同步任务会进入执行堆栈，遇到异步任务，会根据任务类型，将回调函数放入不同的任务队列中。</p> <p>当执行堆栈的调用结束时，会去判断<code>微队列</code>中是否有任务。如果有，就会将<code>微任务队列</code>里的异步任务加入到执行队列中进行处理。</p> <p>==如果微任务执行过程中产生了微任务，会继续放到当前微队列里。==</p> <p>直到微队列里任务都执行完成，才会去执行下一个宏任务。</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-07-090006.png" alt="img"></p> <h3 id="_3-async-await的原理以及执行顺序"><a href="#_3-async-await的原理以及执行顺序" class="header-anchor">#</a> 3.async/await的原理以及执行顺序</h3> <blockquote><p>async是*generator函数的语法糖，那generator是什么？</p></blockquote> <p>generator函数是一个状态机，执行genetator函数会返回一个遍历对象，可以通过next()方法区遍历generator内部的每个状态。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">generator1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token string">'world'</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token string">'ending'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> hw <span class="token operator">=</span> <span class="token function">generator1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
hw<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// { value: 'hello', done: false }</span>
hw<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// { value: 'world', done: false }</span>
hw<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// { value: 'ending', done: true }</span>
hw<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// { value: undefined, done: true }</span>
</code></pre></div><blockquote><p>generator函数暂停、恢复原理。</p></blockquote> <p>协程：协程比线程更轻量级，允许执行被挂起与被恢复。线程之间会抢夺资源，但是协程，它本质上还是在一个线程上进行执行，他们之间是相互合作的，不会产生竞争。可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。</p> <p>假设流程：</p> <ol><li>协程<code>A</code>开始执行</li> <li>协程<code>A</code>执行到某个阶段，进入暂停，执行权转移到协程<code>B</code></li> <li>协程<code>B</code>执行完成或暂停，将执行权交还<code>A</code></li> <li>协程<code>A</code>恢复执行</li></ol> <p>A、B的执行有点像多线程，但协程的特点在于是一个线程执行，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p> <p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p> <blockquote><p>执行器的概念</p></blockquote> <p>generator函数的自动执行依赖于<code>执行器</code>。执行器的要求是：能够执行异步函数，当异步函数返回的时候，能自动交回执行权。可以有两种实现方式：</p> <p>1.回调函数。</p> <p>2.Promise对象</p> <div class="language- extra-class"><pre class="language-text"><code>function run(gen) {
  var g = gen();
  function next() {
    var result = g.next();
    if (result.done) {
      return result.value;
    }
    return new Promise(((resolve, reject) =&gt; {
      resolve();
    })).then(() =&gt; {
      next();
    })
  }
  next();
}
</code></pre></div><blockquote><p>async函数干了什么？</p></blockquote> <p>假设async 后面接了一个函数，那这个函数的返回值，会被封装为一个Promise对象并返回。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">'1'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>打印结果</p> <div class="language-js extra-class"><pre class="language-js"><code>Promise <span class="token punctuation">{</span><span class="token operator">&lt;</span>resolved<span class="token operator">&gt;</span><span class="token operator">:</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">}</span>
Promise <span class="token punctuation">{</span><span class="token operator">&lt;</span>resolved<span class="token operator">&gt;</span><span class="token operator">:</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">}</span>
Promise <span class="token punctuation">{</span><span class="token operator">&lt;</span>resolved<span class="token operator">&gt;</span><span class="token operator">:</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">}</span>
<span class="token number">2</span>
</code></pre></div><p>从打印结果可以看出来，async的函数，返回的是一个立即执行的Promise函数。</p> <blockquote><p>await 等待的执行顺序</p></blockquote> <p>await执行分两种情况，一种是await后面函数执行的结果返回的是promise对象，一种返回的是普通对象。</p> <p>无论是哪种情况，程序遇到await语句时，都会先执行函数方法，然后跳出async函数，去执行async函数外的代码。等外部代码执行完（当前调用栈清空后），再跳回到async函数内部。这时，await 后面的代码返回：</p> <ul><li><p>如果返回的是promise对象</p> <p>会等到这个Promise对象变为fullfiled状态，将promise的代码作为await表达式的执行结果。</p> <p>await 语句的下面一行，会在promise之后，被加入微任务队列。</p> <p>也就是说，这个过程有2个微任务产生。</p></li> <li><p>返回普通对象</p> <p>如果是普通的对象，会直接返回一个立即执行的Promise函数，await 语句的下一行代码，会直接被注册为微任务。</p></li></ul> <p>执行顺序：await后面的接的函数执行之后后，会跳出async函数。执行其他代码（模式就类似于协程A,B的切换）。当其他代码执行完毕后，再回到async函数去执行剩下的代码。然后await下面的一行代码会被注册到微任务队列里。</p> <p>结合例子来看：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span> <span class="token comment">// 1.执行代码，输出script start。</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 3.调用async2(), 输出async2 end。跳出async1函数</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 end'</span><span class="token punctuation">)</span> <span class="token comment">// 8.当前微任务队列执行完毕。执行权回到async1. 执行await后面的语句,实际上会产生一个promise返回. 输出async1 end</span>

  
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async2 end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 2.执行async1(),</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 4.跳出async1函数，执行setTimeout，产生一个宏任务</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span> <span class="token comment">// 9 .输出setTimeout</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 5.执行Promise，输出Promise</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Promise'</span><span class="token punctuation">)</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 7.当前宏任务执行完毕)，开始执行当前宏任务产生的微任务队列，输出promise1，</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span> 
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 7.1该微任务遇到then，产生一个新的微任务. 执行产生的微任务，输出promise2,</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span> <span class="token comment">// 6.继续执行代码，输出script end</span>
</code></pre></div><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-03-141113.png" alt="image-20200303221113367" style="zoom:50%;"> <h2 id="函数式编程"><a href="#函数式编程" class="header-anchor">#</a> 函数式编程</h2> <blockquote><p>https://juejin.im/post/5d70e25de51d453c11684cc4#heading-26</p></blockquote> <p>函数式编程有几个重点</p> <p><strong>1.函数作为一等公民，可以将函数做为另一个函数的参数，传入的函数先执行。</strong></p> <p><strong>2.尽量使用纯函数（函数不依赖外部变量，也不修改变量，没有副作用），相同输入得到相同输出</strong></p> <p>存函数的好处：</p> <ul><li><p>可以缓存</p></li> <li><p>可移植性／自文档化</p></li> <li><p>可测试性</p> <p>这里我联想到了实际开发过程中，如果在代码里引用了一个外部变量，那么函数就变得不透明，不利于单元测试。</p></li> <li><p>合理性</p></li></ul> <p><strong>3.柯里化</strong></p> <p>将多参函数，转化为多个单参函数去执行调用。</p> <p>当传递一个参数去调用函数后，就返回一个新函数去处理剩余的参数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 原始</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token comment">// 柯里化</span>
<span class="token keyword">var</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> increment <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> addTen <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">increment</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token function">addTen</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 12</span>
</code></pre></div><p>柯里化的好处：</p> <p>可以传给函数一些参数，就能得到一个新的函数。</p> <p>https://ramda.cn/</p> <h2 id="webworker"><a href="#webworker" class="header-anchor">#</a> WebWorker</h2> <p>js实现多线程操作的一种方案。</p> <p>将一些复杂耗时的任务放在webworker中，通过message消息传递和主线程进行交互。从而避免主线程阻塞，提升web响应速度。</p> <p><strong>使用限制</strong></p> <p>js必须是同源的文件，而且必须是从网络进行加载</p> <p>可以发送ajax请求，但是不能进行DOM的操作</p> <p>使用完应该关闭webworker</p> <p><strong>常用一些功能</strong></p> <p>注册webWorker</p> <p>主线程向webworker发送消息</p> <p>worker通过监听事件，来处理消息。</p> <p>webworker向主线程发送消息</p> <p>主线程监听事件，处理消息</p> <p>webworker加载脚本, 通过importScripts();</p> <p>参考<a href="./WebWorker">WebWorker</a></p> <h2 id="serviceworker"><a href="#serviceworker" class="header-anchor">#</a> ServiceWorker</h2> <p>serviceWorker最主要的作用是用来做离线web应用的。它是ApplicationCache的替代方案。</p> <p>他可以对应用的资源进行细粒度的缓存，还可以去监听web应用的各种事件（请求fetch事件、message事件等）。</p> <p>SW和WebWorker有比较多的相似点：</p> <ul><li><p>同样是利用了浏览器的多线程，不会阻塞web应用中的主线程。</p></li> <li><p>只能加载同源的js代码，而且限制更多，只能是https的或者localhost环境。</p></li> <li><p>都是基于事件驱动，通过事件与主线程进行消息传递。</p></li> <li><p>都无法对DOM进行操作。而且ServiceWorker是有一个单独的作用域的概念，或者成为scope</p></li></ul> <p>使用说明</p> <p>serviceWorker声明周期如下：</p> <p><img src="https://ipic-coda.oss-cn-beijing.aliyuncs.com/2020-03-08-021853.png" alt="service worker生命周期"></p> <p>客户端发起注册register</p> <p>注册完成后，被浏览器解析parsed，但是还未安装</p> <p>installiing后触发==installed事件==，但是有可能存在历史版本的webworker，所以处于waiting状态</p> <p>激活后触发==actiived事件==</p> <p>参考<a href="./ServiceWorker">ServiceWorker</a></p> <p><strong>2.javascript的事件流模式</strong></p> <p>事件捕捉，目标阶段，事件冒泡</p> <p>原始事件模型，捕获型事件模型，冒泡事件模型，</p> <p>原始事件模型就是ele.onclick=function(){}这种类型的事件模型</p> <p>冒泡事件模型是指事件从事件的发生地（目标元素），一直向上传递，直到document，</p> <p>捕获型则恰好相反，事件是从document向下传递，直到事件的发生地（目标元素）</p> <p><strong>3.冒泡与捕获：它们的定义，它们的区别，如何阻止冒泡？</strong></p> <p>冒泡：事件从最下往上传递</p> <p>捕获：事件从上往下传递，直到被目标捕获到。</p> <p>阻止事件冒泡：e.stopPropagation() window.event.cancelBubble=true</p> <p><strong>6.如何判断一个对象是方法？</strong></p> <p>typeof object === 'function'</p> <p>object.toString()</p> <p>**7.**页面加载和渲染的过程</p> <p>IE下载的顺序是从上到下，渲染的顺序也是从上到下，下载和渲染是同时进行，</p> <p>如果有嵌入式的文件，会启用单独的链接进行下载。</p> <p>css下载完成之后，会对所有的元素进行重新解析一遍。</p> <p>js代码加载的时候，会停止网页的渲染和其他的下载。</p> <p><strong>10.jquery的live和bind区别</strong></p> <p>live和bind的功能相同，都是用来绑定事件。</p> <p>bind方法只能给当前存在的元素绑定事件，对于事后采用JS等方式新生成的元素无效</p> <p>live则基于事件委托机制，将事件绑定到dom根节点，所以创建新的元素后，依然能触发事件。</p> <p>已经被on代替了。</p> <p><strong>11.$('document').ready方法的实现机制</strong></p> <p>监听DOMContentLoaded事件，当dom节点加载完全后，触发该事件。</p> <p>onload方法是要等页面所有的元素都加载完成。。</p> <p><strong>13. 浏览器的垃圾回收机制</strong></p> <p>垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，内存泄露和浏览器实现的垃圾回收机制息息相关， 而浏览器实现标识无用变量的策略主要有下两个方法：</p> <p><strong>14. 模块化的理解</strong></p> <p>前端模块话就是把复杂的文件分成一个个独立的模块，比如js文件，分成独立的模块之后有利于代码的重用和维护，但是这样又会引来模块与模块之间的依赖问题，所以就有了CommonJS、AMD、CMD规范</p> <p><strong>15.同源策略</strong></p> <p>同源策略是浏览器有一个很重要的概念。所谓同源是指，域名，协议，端口相同。不同源的客户端脚本(javascript、ActionScript)在没明确授权的情况下，不能读写对方的资源。简单的来说，浏览器允许包含在页面A的脚本访问第二个页面B的数据资源，这一切是建立在A和B页面是同源的基础上。</p> <p><strong>16.改变函数内部this指针的指向函数</strong></p> <p>call和apply，假设要改变fn函数内部的this的指向，指向obj，那么可以fn.call(obj);或者fn.apply(obj);那么问题来了，call和apply的区别是什么，其是call和apply的区别在于参数，他们两个的第一个参数都是一样的，表示调用该函数的对象，apply的第二个参数是数组，是[arg1,arg2,arg3]这种形式，而call是arg1,arg2,arg3这样的形式。还有一个bind函数，</p> <p>var bar=fn.bind(obj);那么fn中的this就指向obj对象了，bind函数返回新的函数，这个函数内的this指针指向obj对象。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.32e12eb3.js" defer></script><script src="/assets/js/2.6edd83cd.js" defer></script><script src="/assets/js/59.de109384.js" defer></script>
  </body>
</html>
